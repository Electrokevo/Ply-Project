Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    COMMA
    DIVIDE_EQUAL
    DO
    DOT
    FILE
    FOR
    LSQBRACKET
    MINUS_EQUAL
    MODULE
    MODULE_EQUAL
    NEW
    NINT
    NUINT
    PLUS_EQUAL
    RSQBRACKET
    STRING
    THEN
    TIMES_EQUAL
    ULONG
    USHORT
    VAR

Grammar

Rule 0     S' -> program
Rule 1     program -> body
Rule 2     body -> lines SEMICOLON
Rule 3     body -> lines SEMICOLON body
Rule 4     function -> modifier data_type ID LPAREN declaration RPAREN block
Rule 5     function -> modifier VOID ID LPAREN declaration RPAREN block
Rule 6     using -> USING CLASSOBJECT SEMICOLON
Rule 7     return -> RETURN ID
Rule 8     return -> RETURN type
Rule 9     type -> FLOAT_TYPE
Rule 10    type -> DOUBLE_TYPE
Rule 11    type -> DECIMAL_TYPE
Rule 12    type -> INTEGER_TYPE
Rule 13    block -> LBRACKET body RBRACKET
Rule 14    if -> IF LPAREN logical_expression RPAREN block
Rule 15    elseif -> if ELSE LBRACKET body RBRACKET
Rule 16    while_loop -> WHILE LPAREN logical_expression RPAREN block
Rule 17    logical_expression -> logical_expression logical_operator logical_factor
Rule 18    logical_expression -> logical_factor
Rule 19    logical_factor -> TRUE
Rule 20    logical_factor -> FALSE
Rule 21    logical_factor -> ID
Rule 22    logical_factor -> logical_expression
Rule 23    logical_operator -> OR
Rule 24    logical_operator -> AND
Rule 25    logical_operator -> NOT
Rule 26    logical_operator -> GREATER_THAN
Rule 27    logical_operator -> LESS_THAN
Rule 28    logical_operator -> GREATER_EQUALS_THAN
Rule 29    logical_operator -> LESS_EQUALS_THAN
Rule 30    class -> modifier CLASS CLASSOBJECT block
Rule 31    modifier -> PUBLIC
Rule 32    modifier -> PRIVATE
Rule 33    modifier -> PROTECTED
Rule 34    modifier -> INTERNAL
Rule 35    data_type -> INT
Rule 36    data_type -> FLOAT
Rule 37    data_type -> BOOL
Rule 38    data_type -> BYTE
Rule 39    data_type -> CHAR
Rule 40    data_type -> SBYTE
Rule 41    data_type -> DECIMAL
Rule 42    data_type -> DOUBLE
Rule 43    data_type -> LONG
Rule 44    data_type -> SHORT
Rule 45    data_type -> UINT
Rule 46    lines -> assignment
Rule 47    lines -> expression
Rule 48    lines -> declaration
Rule 49    assignment -> ID EQUALS expression
Rule 50    assignment -> data_type ID EQUALS expression
Rule 51    assignment -> ID EQUALS ID
Rule 52    declaration -> data_type ID
Rule 53    expression -> expression PLUS term
Rule 54    expression -> expression MINUS term
Rule 55    expression -> term
Rule 56    term -> term TIMES factor
Rule 57    term -> term DIVIDE factor
Rule 58    term -> factor
Rule 59    factor -> INTEGER_TYPE
Rule 60    factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 24
BOOL                 : 37
BYTE                 : 38
CHAR                 : 39
CHARACTER            : 
CLASS                : 30
CLASSOBJECT          : 6 30
COMMA                : 
DECIMAL              : 41
DECIMAL_TYPE         : 11
DIVIDE               : 57
DIVIDE_EQUAL         : 
DO                   : 
DOT                  : 
DOUBLE               : 42
DOUBLE_TYPE          : 10
ELSE                 : 15
EQUALS               : 49 50 51
FALSE                : 20
FILE                 : 
FLOAT                : 36
FLOAT_TYPE           : 9
FOR                  : 
GREATER_EQUALS_THAN  : 28
GREATER_THAN         : 26
ID                   : 4 5 7 21 49 50 51 51 52
IF                   : 14
INT                  : 35
INTEGER_TYPE         : 12 59
INTERNAL             : 34
LBRACKET             : 13 15
LESS_EQUALS_THAN     : 29
LESS_THAN            : 27
LONG                 : 43
LPAREN               : 4 5 14 16 60
LSQBRACKET           : 
MINUS                : 54
MINUS_EQUAL          : 
MODULE               : 
MODULE_EQUAL         : 
NEW                  : 
NINT                 : 
NOT                  : 25
NUINT                : 
OR                   : 23
PLUS                 : 53
PLUS_EQUAL           : 
PRIVATE              : 32
PROTECTED            : 33
PUBLIC               : 31
RBRACKET             : 13 15
RETURN               : 7 8
RPAREN               : 4 5 14 16 60
RSQBRACKET           : 
SBYTE                : 40
SEMICOLON            : 2 3 6
SHORT                : 44
STRING               : 
THEN                 : 
TIMES                : 56
TIMES_EQUAL          : 
TRUE                 : 19
UINT                 : 45
ULONG                : 
USHORT               : 
USING                : 6
VAR                  : 
VOID                 : 5
WHILE                : 16
error                : 

Nonterminals, with rules where they appear

assignment           : 46
block                : 4 5 14 16 30
body                 : 1 3 13 15
class                : 
data_type            : 4 50 52
declaration          : 4 5 48
elseif               : 
expression           : 47 49 50 53 54 60
factor               : 56 57 58
function             : 
if                   : 15
lines                : 2 3
logical_expression   : 14 16 17 22
logical_factor       : 17 18
logical_operator     : 17
modifier             : 4 5 30
program              : 0
return               : 
term                 : 53 54 55 56 57
type                 : 8
using                : 
while_loop           : 

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . body
    (2) body -> . lines SEMICOLON
    (3) body -> . lines SEMICOLON body
    (46) lines -> . assignment
    (47) lines -> . expression
    (48) lines -> . declaration
    (49) assignment -> . ID EQUALS expression
    (50) assignment -> . data_type ID EQUALS expression
    (51) assignment -> . ID EQUALS ID
    (53) expression -> . expression PLUS term
    (54) expression -> . expression MINUS term
    (55) expression -> . term
    (52) declaration -> . data_type ID
    (35) data_type -> . INT
    (36) data_type -> . FLOAT
    (37) data_type -> . BOOL
    (38) data_type -> . BYTE
    (39) data_type -> . CHAR
    (40) data_type -> . SBYTE
    (41) data_type -> . DECIMAL
    (42) data_type -> . DOUBLE
    (43) data_type -> . LONG
    (44) data_type -> . SHORT
    (45) data_type -> . UINT
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 7
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    BYTE            shift and go to state 13
    CHAR            shift and go to state 14
    SBYTE           shift and go to state 15
    DECIMAL         shift and go to state 16
    DOUBLE          shift and go to state 17
    LONG            shift and go to state 18
    SHORT           shift and go to state 19
    UINT            shift and go to state 20
    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    program                        shift and go to state 1
    body                           shift and go to state 2
    lines                          shift and go to state 3
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    declaration                    shift and go to state 6
    data_type                      shift and go to state 8
    term                           shift and go to state 9
    factor                         shift and go to state 21

state 1

    (0) S' -> program .



state 2

    (1) program -> body .

    $end            reduce using rule 1 (program -> body .)


state 3

    (2) body -> lines . SEMICOLON
    (3) body -> lines . SEMICOLON body

    SEMICOLON       shift and go to state 24


state 4

    (46) lines -> assignment .

    SEMICOLON       reduce using rule 46 (lines -> assignment .)


state 5

    (47) lines -> expression .
    (53) expression -> expression . PLUS term
    (54) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 47 (lines -> expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26


state 6

    (48) lines -> declaration .

    SEMICOLON       reduce using rule 48 (lines -> declaration .)


state 7

    (49) assignment -> ID . EQUALS expression
    (51) assignment -> ID . EQUALS ID

    EQUALS          shift and go to state 27


state 8

    (50) assignment -> data_type . ID EQUALS expression
    (52) declaration -> data_type . ID

    ID              shift and go to state 28


state 9

    (55) expression -> term .
    (56) term -> term . TIMES factor
    (57) term -> term . DIVIDE factor

    PLUS            reduce using rule 55 (expression -> term .)
    MINUS           reduce using rule 55 (expression -> term .)
    SEMICOLON       reduce using rule 55 (expression -> term .)
    RPAREN          reduce using rule 55 (expression -> term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 10

    (35) data_type -> INT .

    ID              reduce using rule 35 (data_type -> INT .)


state 11

    (36) data_type -> FLOAT .

    ID              reduce using rule 36 (data_type -> FLOAT .)


state 12

    (37) data_type -> BOOL .

    ID              reduce using rule 37 (data_type -> BOOL .)


state 13

    (38) data_type -> BYTE .

    ID              reduce using rule 38 (data_type -> BYTE .)


state 14

    (39) data_type -> CHAR .

    ID              reduce using rule 39 (data_type -> CHAR .)


state 15

    (40) data_type -> SBYTE .

    ID              reduce using rule 40 (data_type -> SBYTE .)


state 16

    (41) data_type -> DECIMAL .

    ID              reduce using rule 41 (data_type -> DECIMAL .)


state 17

    (42) data_type -> DOUBLE .

    ID              reduce using rule 42 (data_type -> DOUBLE .)


state 18

    (43) data_type -> LONG .

    ID              reduce using rule 43 (data_type -> LONG .)


state 19

    (44) data_type -> SHORT .

    ID              reduce using rule 44 (data_type -> SHORT .)


state 20

    (45) data_type -> UINT .

    ID              reduce using rule 45 (data_type -> UINT .)


state 21

    (58) term -> factor .

    TIMES           reduce using rule 58 (term -> factor .)
    DIVIDE          reduce using rule 58 (term -> factor .)
    PLUS            reduce using rule 58 (term -> factor .)
    MINUS           reduce using rule 58 (term -> factor .)
    SEMICOLON       reduce using rule 58 (term -> factor .)
    RPAREN          reduce using rule 58 (term -> factor .)


state 22

    (59) factor -> INTEGER_TYPE .

    TIMES           reduce using rule 59 (factor -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 59 (factor -> INTEGER_TYPE .)
    PLUS            reduce using rule 59 (factor -> INTEGER_TYPE .)
    MINUS           reduce using rule 59 (factor -> INTEGER_TYPE .)
    SEMICOLON       reduce using rule 59 (factor -> INTEGER_TYPE .)
    RPAREN          reduce using rule 59 (factor -> INTEGER_TYPE .)


state 23

    (60) factor -> LPAREN . expression RPAREN
    (53) expression -> . expression PLUS term
    (54) expression -> . expression MINUS term
    (55) expression -> . term
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    expression                     shift and go to state 31
    term                           shift and go to state 9
    factor                         shift and go to state 21

state 24

    (2) body -> lines SEMICOLON .
    (3) body -> lines SEMICOLON . body
    (2) body -> . lines SEMICOLON
    (3) body -> . lines SEMICOLON body
    (46) lines -> . assignment
    (47) lines -> . expression
    (48) lines -> . declaration
    (49) assignment -> . ID EQUALS expression
    (50) assignment -> . data_type ID EQUALS expression
    (51) assignment -> . ID EQUALS ID
    (53) expression -> . expression PLUS term
    (54) expression -> . expression MINUS term
    (55) expression -> . term
    (52) declaration -> . data_type ID
    (35) data_type -> . INT
    (36) data_type -> . FLOAT
    (37) data_type -> . BOOL
    (38) data_type -> . BYTE
    (39) data_type -> . CHAR
    (40) data_type -> . SBYTE
    (41) data_type -> . DECIMAL
    (42) data_type -> . DOUBLE
    (43) data_type -> . LONG
    (44) data_type -> . SHORT
    (45) data_type -> . UINT
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    $end            reduce using rule 2 (body -> lines SEMICOLON .)
    ID              shift and go to state 7
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 12
    BYTE            shift and go to state 13
    CHAR            shift and go to state 14
    SBYTE           shift and go to state 15
    DECIMAL         shift and go to state 16
    DOUBLE          shift and go to state 17
    LONG            shift and go to state 18
    SHORT           shift and go to state 19
    UINT            shift and go to state 20
    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    lines                          shift and go to state 3
    body                           shift and go to state 32
    assignment                     shift and go to state 4
    expression                     shift and go to state 5
    declaration                    shift and go to state 6
    data_type                      shift and go to state 8
    term                           shift and go to state 9
    factor                         shift and go to state 21

state 25

    (53) expression -> expression PLUS . term
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    term                           shift and go to state 33
    factor                         shift and go to state 21

state 26

    (54) expression -> expression MINUS . term
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    term                           shift and go to state 34
    factor                         shift and go to state 21

state 27

    (49) assignment -> ID EQUALS . expression
    (51) assignment -> ID EQUALS . ID
    (53) expression -> . expression PLUS term
    (54) expression -> . expression MINUS term
    (55) expression -> . term
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 35
    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    expression                     shift and go to state 36
    term                           shift and go to state 9
    factor                         shift and go to state 21

state 28

    (50) assignment -> data_type ID . EQUALS expression
    (52) declaration -> data_type ID .

    EQUALS          shift and go to state 37
    SEMICOLON       reduce using rule 52 (declaration -> data_type ID .)


state 29

    (56) term -> term TIMES . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    factor                         shift and go to state 38

state 30

    (57) term -> term DIVIDE . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    factor                         shift and go to state 39

state 31

    (60) factor -> LPAREN expression . RPAREN
    (53) expression -> expression . PLUS term
    (54) expression -> expression . MINUS term

    RPAREN          shift and go to state 40
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26


state 32

    (3) body -> lines SEMICOLON body .

    $end            reduce using rule 3 (body -> lines SEMICOLON body .)


state 33

    (53) expression -> expression PLUS term .
    (56) term -> term . TIMES factor
    (57) term -> term . DIVIDE factor

    PLUS            reduce using rule 53 (expression -> expression PLUS term .)
    MINUS           reduce using rule 53 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 53 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 53 (expression -> expression PLUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 34

    (54) expression -> expression MINUS term .
    (56) term -> term . TIMES factor
    (57) term -> term . DIVIDE factor

    PLUS            reduce using rule 54 (expression -> expression MINUS term .)
    MINUS           reduce using rule 54 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 54 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 54 (expression -> expression MINUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 35

    (51) assignment -> ID EQUALS ID .

    SEMICOLON       reduce using rule 51 (assignment -> ID EQUALS ID .)


state 36

    (49) assignment -> ID EQUALS expression .
    (53) expression -> expression . PLUS term
    (54) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 49 (assignment -> ID EQUALS expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26


state 37

    (50) assignment -> data_type ID EQUALS . expression
    (53) expression -> . expression PLUS term
    (54) expression -> . expression MINUS term
    (55) expression -> . term
    (56) term -> . term TIMES factor
    (57) term -> . term DIVIDE factor
    (58) term -> . factor
    (59) factor -> . INTEGER_TYPE
    (60) factor -> . LPAREN expression RPAREN

    INTEGER_TYPE    shift and go to state 22
    LPAREN          shift and go to state 23

    expression                     shift and go to state 41
    term                           shift and go to state 9
    factor                         shift and go to state 21

state 38

    (56) term -> term TIMES factor .

    TIMES           reduce using rule 56 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 56 (term -> term TIMES factor .)
    PLUS            reduce using rule 56 (term -> term TIMES factor .)
    MINUS           reduce using rule 56 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 56 (term -> term TIMES factor .)
    RPAREN          reduce using rule 56 (term -> term TIMES factor .)


state 39

    (57) term -> term DIVIDE factor .

    TIMES           reduce using rule 57 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 57 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 57 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 57 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 57 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 57 (term -> term DIVIDE factor .)


state 40

    (60) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 60 (factor -> LPAREN expression RPAREN .)


state 41

    (50) assignment -> data_type ID EQUALS expression .
    (53) expression -> expression . PLUS term
    (54) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 50 (assignment -> data_type ID EQUALS expression .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26

