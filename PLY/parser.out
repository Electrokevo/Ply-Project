Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    DIVIDE_EQUAL
    DO
    FILE
    IN
    MINUS_EQUAL
    MODULE
    MODULE_EQUAL
    NEW
    NINT
    NUINT
    PLUS_EQUAL
    STRING
    THEN
    TIMES_EQUAL
    ULONG
    USHORT
    VAR

Grammar

Rule 0     S' -> program
Rule 1     program -> usings namespace class
Rule 2     program -> namespace class
Rule 3     usings -> using usings
Rule 4     usings -> using
Rule 5     using -> USING CLASSOBJECT SEMICOLON
Rule 6     namespace -> NAMESPACE CLASSOBJECT SEMICOLON
Rule 7     class -> modifier CLASS CLASSOBJECT block
Rule 8     class -> modifier STATIC CLASS CLASSOBJECT block
Rule 9     object_access -> ID DOT ID
Rule 10    object_access -> CLASSOBJECT DOT CLASSOBJECT
Rule 11    object_access -> ID DOT CLASSOBJECT
Rule 12    object_access -> CLASSOBJECT DOT ID
Rule 13    block -> LBRACKET body RBRACKET
Rule 14    body -> lines SEMICOLON
Rule 15    body -> lines SEMICOLON body
Rule 16    body -> function
Rule 17    lines -> assignment
Rule 18    lines -> expression
Rule 19    lines -> declaration
Rule 20    lines -> if
Rule 21    lines -> loop
Rule 22    lines -> return
Rule 23    function -> modifier data_type ID LPAREN declarations RPAREN block
Rule 24    function -> modifier VOID ID LPAREN declarations RPAREN block
Rule 25    function -> modifier STATIC data_type ID LPAREN declarations RPAREN block
Rule 26    function -> modifier STATIC VOID ID LPAREN declarations RPAREN block
Rule 27    return -> RETURN ID
Rule 28    return -> RETURN type
Rule 29    lambda_function -> LPAREN ID RPAREN ARROW expression
Rule 30    lambda_function -> LPAREN ID RPAREN ARROW block
Rule 31    expression -> object_access LPAREN expression RPAREN
Rule 32    expression -> object_access LPAREN RPAREN
Rule 33    type -> FLOAT_TYPE
Rule 34    type -> DOUBLE_TYPE
Rule 35    type -> DECIMAL_TYPE
Rule 36    type -> INTEGER_TYPE
Rule 37    if -> IF LPAREN logical_expression RPAREN block
Rule 38    if -> IF LPAREN logical_expression RPAREN block elseif
Rule 39    if -> IF LPAREN logical_expression RPAREN block else
Rule 40    elseif -> ELSE IF LPAREN logical_expression RPAREN block
Rule 41    elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif
Rule 42    elseif -> ELSE IF LPAREN logical_expression RPAREN block else
Rule 43    else -> ELSE block
Rule 44    loop -> while_loop
Rule 45    loop -> loop_for
Rule 46    loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
Rule 47    while_loop -> WHILE LPAREN logical_expression RPAREN block
Rule 48    logical_expression -> logical_expression logical_operator logical_factor
Rule 49    logical_expression -> logical_factor
Rule 50    logical_factor -> TRUE
Rule 51    logical_factor -> FALSE
Rule 52    logical_factor -> ID
Rule 53    logical_factor -> indexing
Rule 54    logical_factor -> type
Rule 55    logical_factor -> object_access
Rule 56    logical_factor -> LPAREN logical_expression RPAREN
Rule 57    logical_operator -> OR
Rule 58    logical_operator -> AND
Rule 59    logical_operator -> NOT
Rule 60    logical_operator -> GREATER_THAN
Rule 61    logical_operator -> LESS_THAN
Rule 62    logical_operator -> GREATER_EQUALS_THAN
Rule 63    logical_operator -> LESS_EQUALS_THAN
Rule 64    logical_operator -> EQUALITY
Rule 65    data_structure -> data_structure_list
Rule 66    data_structure -> data_structure_array
Rule 67    data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
Rule 68    data_structure_array -> primitive LSQBRACKET RSQBRACKET
Rule 69    data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET
Rule 70    assignment -> ID EQUALS expression
Rule 71    assignment -> data_type ID EQUALS expression
Rule 72    assignment -> CLASSOBJECT ID
Rule 73    declarations -> declaration
Rule 74    declarations -> declaration COMMA
Rule 75    declarations -> declaration COMMA declarations
Rule 76    declaration -> data_type ID
Rule 77    expression -> expression PLUS term
Rule 78    expression -> expression MINUS term
Rule 79    expression -> term
Rule 80    term -> term TIMES factor
Rule 81    term -> term DIVIDE factor
Rule 82    term -> factor
Rule 83    factor -> type
Rule 84    factor -> LPAREN expression RPAREN
Rule 85    factor -> object_access
Rule 86    factor -> ID
Rule 87    factor -> indexing
Rule 88    modifier -> PUBLIC
Rule 89    modifier -> PRIVATE
Rule 90    modifier -> PROTECTED
Rule 91    modifier -> INTERNAL
Rule 92    data_type -> primitive
Rule 93    data_type -> data_structure
Rule 94    primitive -> INT
Rule 95    primitive -> FLOAT
Rule 96    primitive -> BOOL
Rule 97    primitive -> BYTE
Rule 98    primitive -> CHAR
Rule 99    primitive -> SBYTE
Rule 100   primitive -> DECIMAL
Rule 101   primitive -> DOUBLE
Rule 102   primitive -> LONG
Rule 103   primitive -> SHORT
Rule 104   primitive -> UINT
Rule 105   indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET
Rule 106   indexing -> ID LSQBRACKET ID RSQBRACKET

Terminals, with rules where they appear

AND                  : 58
ARROW                : 29 30
BOOL                 : 96
BYTE                 : 97
CHAR                 : 98
CHARACTER            : 
CLASS                : 7 8
CLASSOBJECT          : 5 6 7 8 10 10 11 12 69 72
COMMA                : 74 75
DECIMAL              : 100
DECIMAL_TYPE         : 35
DIVIDE               : 81
DIVIDE_EQUAL         : 
DO                   : 
DOT                  : 9 10 11 12
DOUBLE               : 101
DOUBLE_TYPE          : 34
ELSE                 : 40 41 42 43
EQUALITY             : 64
EQUALS               : 70 71
FALSE                : 51
FILE                 : 
FLOAT                : 95
FLOAT_TYPE           : 33
FOR                  : 46
GREATER_EQUALS_THAN  : 62
GREATER_THAN         : 60 67
ID                   : 9 9 11 12 23 24 25 26 27 29 30 52 67 70 71 72 76 86 105 106 106
IF                   : 37 38 39 40 41 42
IN                   : 
INT                  : 94
INTEGER_TYPE         : 36 105
INTERNAL             : 91
LBRACKET             : 13
LESS_EQUALS_THAN     : 63
LESS_THAN            : 61 67
LIST                 : 67
LONG                 : 102
LPAREN               : 23 24 25 26 29 30 31 32 37 38 39 40 41 42 46 47 56 84
LSQBRACKET           : 67 68 69 105 106
MINUS                : 78
MINUS_EQUAL          : 
MODULE               : 
MODULE_EQUAL         : 
NAMESPACE            : 6
NEW                  : 
NINT                 : 
NOT                  : 59
NUINT                : 
OR                   : 57
PLUS                 : 77
PLUS_EQUAL           : 
PRIVATE              : 89
PROTECTED            : 90
PUBLIC               : 88
RBRACKET             : 13
RETURN               : 27 28
RPAREN               : 23 24 25 26 29 30 31 32 37 38 39 40 41 42 46 47 56 84
RSQBRACKET           : 67 68 69 105 106
SBYTE                : 99
SEMICOLON            : 5 6 14 15 46 46
SHORT                : 103
STATIC               : 8 25 26
STRING               : 
THEN                 : 
TIMES                : 80
TIMES_EQUAL          : 
TRUE                 : 50
UINT                 : 104
ULONG                : 
USHORT               : 
USING                : 5
VAR                  : 
VOID                 : 24 26
WHILE                : 47
error                : 

Nonterminals, with rules where they appear

assignment           : 17 46 46
block                : 7 8 23 24 25 26 30 37 38 39 40 41 42 43 46 47
body                 : 13 15
class                : 1 2
data_structure       : 93
data_structure_array : 66
data_structure_list  : 65
data_type            : 23 25 67 71 76
declaration          : 19 73 74 75
declarations         : 23 24 25 26 75
else                 : 39 42
elseif               : 38 41
expression           : 18 29 31 70 71 77 78 84
factor               : 80 81 82
function             : 16
if                   : 20
indexing             : 53 87
lambda_function      : 
lines                : 14 15
logical_expression   : 37 38 39 40 41 42 46 47 48 56
logical_factor       : 48 49
logical_operator     : 48
loop                 : 21
loop_for             : 45
modifier             : 7 8 23 24 25 26
namespace            : 1 2
object_access        : 31 32 55 85
primitive            : 68 92
program              : 0
return               : 22
term                 : 77 78 79 80 81
type                 : 28 54 67 83
using                : 3 4
usings               : 1 3
while_loop           : 44

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . usings namespace class
    (2) program -> . namespace class
    (3) usings -> . using usings
    (4) usings -> . using
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5
    USING           shift and go to state 6

    program                        shift and go to state 1
    usings                         shift and go to state 2
    namespace                      shift and go to state 3
    using                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> usings . namespace class
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5

    namespace                      shift and go to state 7

state 3

    (2) program -> namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (88) modifier -> . PUBLIC
    (89) modifier -> . PRIVATE
    (90) modifier -> . PROTECTED
    (91) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 8
    modifier                       shift and go to state 9

state 4

    (3) usings -> using . usings
    (4) usings -> using .
    (3) usings -> . using usings
    (4) usings -> . using
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       reduce using rule 4 (usings -> using .)
    USING           shift and go to state 6

    using                          shift and go to state 4
    usings                         shift and go to state 14

state 5

    (6) namespace -> NAMESPACE . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 15


state 6

    (5) using -> USING . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 16


state 7

    (1) program -> usings namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (88) modifier -> . PUBLIC
    (89) modifier -> . PRIVATE
    (90) modifier -> . PROTECTED
    (91) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 17
    modifier                       shift and go to state 9

state 8

    (2) program -> namespace class .

    $end            reduce using rule 2 (program -> namespace class .)


state 9

    (7) class -> modifier . CLASS CLASSOBJECT block
    (8) class -> modifier . STATIC CLASS CLASSOBJECT block

    CLASS           shift and go to state 18
    STATIC          shift and go to state 19


state 10

    (88) modifier -> PUBLIC .

    CLASS           reduce using rule 88 (modifier -> PUBLIC .)
    STATIC          reduce using rule 88 (modifier -> PUBLIC .)
    VOID            reduce using rule 88 (modifier -> PUBLIC .)
    INT             reduce using rule 88 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 88 (modifier -> PUBLIC .)
    BOOL            reduce using rule 88 (modifier -> PUBLIC .)
    BYTE            reduce using rule 88 (modifier -> PUBLIC .)
    CHAR            reduce using rule 88 (modifier -> PUBLIC .)
    SBYTE           reduce using rule 88 (modifier -> PUBLIC .)
    DECIMAL         reduce using rule 88 (modifier -> PUBLIC .)
    DOUBLE          reduce using rule 88 (modifier -> PUBLIC .)
    LONG            reduce using rule 88 (modifier -> PUBLIC .)
    SHORT           reduce using rule 88 (modifier -> PUBLIC .)
    UINT            reduce using rule 88 (modifier -> PUBLIC .)
    LIST            reduce using rule 88 (modifier -> PUBLIC .)
    CLASSOBJECT     reduce using rule 88 (modifier -> PUBLIC .)


state 11

    (89) modifier -> PRIVATE .

    CLASS           reduce using rule 89 (modifier -> PRIVATE .)
    STATIC          reduce using rule 89 (modifier -> PRIVATE .)
    VOID            reduce using rule 89 (modifier -> PRIVATE .)
    INT             reduce using rule 89 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 89 (modifier -> PRIVATE .)
    BOOL            reduce using rule 89 (modifier -> PRIVATE .)
    BYTE            reduce using rule 89 (modifier -> PRIVATE .)
    CHAR            reduce using rule 89 (modifier -> PRIVATE .)
    SBYTE           reduce using rule 89 (modifier -> PRIVATE .)
    DECIMAL         reduce using rule 89 (modifier -> PRIVATE .)
    DOUBLE          reduce using rule 89 (modifier -> PRIVATE .)
    LONG            reduce using rule 89 (modifier -> PRIVATE .)
    SHORT           reduce using rule 89 (modifier -> PRIVATE .)
    UINT            reduce using rule 89 (modifier -> PRIVATE .)
    LIST            reduce using rule 89 (modifier -> PRIVATE .)
    CLASSOBJECT     reduce using rule 89 (modifier -> PRIVATE .)


state 12

    (90) modifier -> PROTECTED .

    CLASS           reduce using rule 90 (modifier -> PROTECTED .)
    STATIC          reduce using rule 90 (modifier -> PROTECTED .)
    VOID            reduce using rule 90 (modifier -> PROTECTED .)
    INT             reduce using rule 90 (modifier -> PROTECTED .)
    FLOAT           reduce using rule 90 (modifier -> PROTECTED .)
    BOOL            reduce using rule 90 (modifier -> PROTECTED .)
    BYTE            reduce using rule 90 (modifier -> PROTECTED .)
    CHAR            reduce using rule 90 (modifier -> PROTECTED .)
    SBYTE           reduce using rule 90 (modifier -> PROTECTED .)
    DECIMAL         reduce using rule 90 (modifier -> PROTECTED .)
    DOUBLE          reduce using rule 90 (modifier -> PROTECTED .)
    LONG            reduce using rule 90 (modifier -> PROTECTED .)
    SHORT           reduce using rule 90 (modifier -> PROTECTED .)
    UINT            reduce using rule 90 (modifier -> PROTECTED .)
    LIST            reduce using rule 90 (modifier -> PROTECTED .)
    CLASSOBJECT     reduce using rule 90 (modifier -> PROTECTED .)


state 13

    (91) modifier -> INTERNAL .

    CLASS           reduce using rule 91 (modifier -> INTERNAL .)
    STATIC          reduce using rule 91 (modifier -> INTERNAL .)
    VOID            reduce using rule 91 (modifier -> INTERNAL .)
    INT             reduce using rule 91 (modifier -> INTERNAL .)
    FLOAT           reduce using rule 91 (modifier -> INTERNAL .)
    BOOL            reduce using rule 91 (modifier -> INTERNAL .)
    BYTE            reduce using rule 91 (modifier -> INTERNAL .)
    CHAR            reduce using rule 91 (modifier -> INTERNAL .)
    SBYTE           reduce using rule 91 (modifier -> INTERNAL .)
    DECIMAL         reduce using rule 91 (modifier -> INTERNAL .)
    DOUBLE          reduce using rule 91 (modifier -> INTERNAL .)
    LONG            reduce using rule 91 (modifier -> INTERNAL .)
    SHORT           reduce using rule 91 (modifier -> INTERNAL .)
    UINT            reduce using rule 91 (modifier -> INTERNAL .)
    LIST            reduce using rule 91 (modifier -> INTERNAL .)
    CLASSOBJECT     reduce using rule 91 (modifier -> INTERNAL .)


state 14

    (3) usings -> using usings .

    NAMESPACE       reduce using rule 3 (usings -> using usings .)


state 15

    (6) namespace -> NAMESPACE CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 20


state 16

    (5) using -> USING CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 21


state 17

    (1) program -> usings namespace class .

    $end            reduce using rule 1 (program -> usings namespace class .)


state 18

    (7) class -> modifier CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 22


state 19

    (8) class -> modifier STATIC . CLASS CLASSOBJECT block

    CLASS           shift and go to state 23


state 20

    (6) namespace -> NAMESPACE CLASSOBJECT SEMICOLON .

    PUBLIC          reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PRIVATE         reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PROTECTED       reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    INTERNAL        reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)


state 21

    (5) using -> USING CLASSOBJECT SEMICOLON .

    USING           reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)
    NAMESPACE       reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)


state 22

    (7) class -> modifier CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 24

state 23

    (8) class -> modifier STATIC CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 26


state 24

    (7) class -> modifier CLASS CLASSOBJECT block .

    $end            reduce using rule 7 (class -> modifier CLASS CLASSOBJECT block .)


state 25

    (13) block -> LBRACKET . body RBRACKET
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . function
    (17) lines -> . assignment
    (18) lines -> . expression
    (19) lines -> . declaration
    (20) lines -> . if
    (21) lines -> . loop
    (22) lines -> . return
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (70) assignment -> . ID EQUALS expression
    (71) assignment -> . data_type ID EQUALS expression
    (72) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (77) expression -> . expression PLUS term
    (78) expression -> . expression MINUS term
    (79) expression -> . term
    (76) declaration -> . data_type ID
    (37) if -> . IF LPAREN logical_expression RPAREN block
    (38) if -> . IF LPAREN logical_expression RPAREN block elseif
    (39) if -> . IF LPAREN logical_expression RPAREN block else
    (44) loop -> . while_loop
    (45) loop -> . loop_for
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (88) modifier -> . PUBLIC
    (89) modifier -> . PRIVATE
    (90) modifier -> . PROTECTED
    (91) modifier -> . INTERNAL
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (47) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (46) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 38
    CLASSOBJECT     shift and go to state 40
    IF              shift and go to state 43
    RETURN          shift and go to state 46
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LPAREN          shift and go to state 39
    LIST            shift and go to state 67
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    body                           shift and go to state 27
    lines                          shift and go to state 28
    function                       shift and go to state 29
    assignment                     shift and go to state 30
    expression                     shift and go to state 31
    declaration                    shift and go to state 32
    if                             shift and go to state 33
    loop                           shift and go to state 34
    return                         shift and go to state 35
    modifier                       shift and go to state 36
    data_type                      shift and go to state 37
    object_access                  shift and go to state 41
    term                           shift and go to state 42
    while_loop                     shift and go to state 44
    loop_for                       shift and go to state 45
    type                           shift and go to state 47
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    factor                         shift and go to state 50
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65
    indexing                       shift and go to state 66

state 26

    (8) class -> modifier STATIC CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 72

state 27

    (13) block -> LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 73


state 28

    (14) body -> lines . SEMICOLON
    (15) body -> lines . SEMICOLON body

    SEMICOLON       shift and go to state 74


state 29

    (16) body -> function .

    RBRACKET        reduce using rule 16 (body -> function .)


state 30

    (17) lines -> assignment .

    SEMICOLON       reduce using rule 17 (lines -> assignment .)


state 31

    (18) lines -> expression .
    (77) expression -> expression . PLUS term
    (78) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 18 (lines -> expression .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 32

    (19) lines -> declaration .

    SEMICOLON       reduce using rule 19 (lines -> declaration .)


state 33

    (20) lines -> if .

    SEMICOLON       reduce using rule 20 (lines -> if .)


state 34

    (21) lines -> loop .

    SEMICOLON       reduce using rule 21 (lines -> loop .)


state 35

    (22) lines -> return .

    SEMICOLON       reduce using rule 22 (lines -> return .)


state 36

    (23) function -> modifier . data_type ID LPAREN declarations RPAREN block
    (24) function -> modifier . VOID ID LPAREN declarations RPAREN block
    (25) function -> modifier . STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> modifier . STATIC VOID ID LPAREN declarations RPAREN block
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 78
    STATIC          shift and go to state 79
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    data_type                      shift and go to state 77
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 37

    (71) assignment -> data_type . ID EQUALS expression
    (76) declaration -> data_type . ID

    ID              shift and go to state 81


state 38

    (70) assignment -> ID . EQUALS expression
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (86) factor -> ID .
    (105) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> ID . LSQBRACKET ID RSQBRACKET

    EQUALS          shift and go to state 82
    DOT             shift and go to state 83
    TIMES           reduce using rule 86 (factor -> ID .)
    DIVIDE          reduce using rule 86 (factor -> ID .)
    PLUS            reduce using rule 86 (factor -> ID .)
    MINUS           reduce using rule 86 (factor -> ID .)
    SEMICOLON       reduce using rule 86 (factor -> ID .)
    LSQBRACKET      shift and go to state 84


state 39

    (84) factor -> LPAREN . expression RPAREN
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (77) expression -> . expression PLUS term
    (78) expression -> . expression MINUS term
    (79) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 39
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    expression                     shift and go to state 85
    object_access                  shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 50
    type                           shift and go to state 47
    indexing                       shift and go to state 66

state 40

    (72) assignment -> CLASSOBJECT . ID
    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID
    (69) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    ID              shift and go to state 88
    DOT             shift and go to state 89
    LSQBRACKET      shift and go to state 90


state 41

    (31) expression -> object_access . LPAREN expression RPAREN
    (32) expression -> object_access . LPAREN RPAREN
    (85) factor -> object_access .

    LPAREN          shift and go to state 91
    TIMES           reduce using rule 85 (factor -> object_access .)
    DIVIDE          reduce using rule 85 (factor -> object_access .)
    PLUS            reduce using rule 85 (factor -> object_access .)
    MINUS           reduce using rule 85 (factor -> object_access .)
    SEMICOLON       reduce using rule 85 (factor -> object_access .)
    RPAREN          reduce using rule 85 (factor -> object_access .)


state 42

    (79) expression -> term .
    (80) term -> term . TIMES factor
    (81) term -> term . DIVIDE factor

    PLUS            reduce using rule 79 (expression -> term .)
    MINUS           reduce using rule 79 (expression -> term .)
    SEMICOLON       reduce using rule 79 (expression -> term .)
    RPAREN          reduce using rule 79 (expression -> term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93


state 43

    (37) if -> IF . LPAREN logical_expression RPAREN block
    (38) if -> IF . LPAREN logical_expression RPAREN block elseif
    (39) if -> IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 94


state 44

    (44) loop -> while_loop .

    SEMICOLON       reduce using rule 44 (loop -> while_loop .)


state 45

    (45) loop -> loop_for .

    SEMICOLON       reduce using rule 45 (loop -> loop_for .)


state 46

    (27) return -> RETURN . ID
    (28) return -> RETURN . type
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE

    ID              shift and go to state 95
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    type                           shift and go to state 96

state 47

    (83) factor -> type .

    TIMES           reduce using rule 83 (factor -> type .)
    DIVIDE          reduce using rule 83 (factor -> type .)
    PLUS            reduce using rule 83 (factor -> type .)
    MINUS           reduce using rule 83 (factor -> type .)
    SEMICOLON       reduce using rule 83 (factor -> type .)
    RPAREN          reduce using rule 83 (factor -> type .)


state 48

    (92) data_type -> primitive .
    (68) data_structure_array -> primitive . LSQBRACKET RSQBRACKET

    ID              reduce using rule 92 (data_type -> primitive .)
    GREATER_THAN    reduce using rule 92 (data_type -> primitive .)
    LSQBRACKET      shift and go to state 97


state 49

    (93) data_type -> data_structure .

    ID              reduce using rule 93 (data_type -> data_structure .)
    GREATER_THAN    reduce using rule 93 (data_type -> data_structure .)


state 50

    (82) term -> factor .

    TIMES           reduce using rule 82 (term -> factor .)
    DIVIDE          reduce using rule 82 (term -> factor .)
    PLUS            reduce using rule 82 (term -> factor .)
    MINUS           reduce using rule 82 (term -> factor .)
    SEMICOLON       reduce using rule 82 (term -> factor .)
    RPAREN          reduce using rule 82 (term -> factor .)


state 51

    (47) while_loop -> WHILE . LPAREN logical_expression RPAREN block

    LPAREN          shift and go to state 98


state 52

    (46) loop_for -> FOR . LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block

    LPAREN          shift and go to state 99


state 53

    (94) primitive -> INT .

    LSQBRACKET      reduce using rule 94 (primitive -> INT .)
    ID              reduce using rule 94 (primitive -> INT .)
    GREATER_THAN    reduce using rule 94 (primitive -> INT .)


state 54

    (95) primitive -> FLOAT .

    LSQBRACKET      reduce using rule 95 (primitive -> FLOAT .)
    ID              reduce using rule 95 (primitive -> FLOAT .)
    GREATER_THAN    reduce using rule 95 (primitive -> FLOAT .)


state 55

    (96) primitive -> BOOL .

    LSQBRACKET      reduce using rule 96 (primitive -> BOOL .)
    ID              reduce using rule 96 (primitive -> BOOL .)
    GREATER_THAN    reduce using rule 96 (primitive -> BOOL .)


state 56

    (97) primitive -> BYTE .

    LSQBRACKET      reduce using rule 97 (primitive -> BYTE .)
    ID              reduce using rule 97 (primitive -> BYTE .)
    GREATER_THAN    reduce using rule 97 (primitive -> BYTE .)


state 57

    (98) primitive -> CHAR .

    LSQBRACKET      reduce using rule 98 (primitive -> CHAR .)
    ID              reduce using rule 98 (primitive -> CHAR .)
    GREATER_THAN    reduce using rule 98 (primitive -> CHAR .)


state 58

    (99) primitive -> SBYTE .

    LSQBRACKET      reduce using rule 99 (primitive -> SBYTE .)
    ID              reduce using rule 99 (primitive -> SBYTE .)
    GREATER_THAN    reduce using rule 99 (primitive -> SBYTE .)


state 59

    (100) primitive -> DECIMAL .

    LSQBRACKET      reduce using rule 100 (primitive -> DECIMAL .)
    ID              reduce using rule 100 (primitive -> DECIMAL .)
    GREATER_THAN    reduce using rule 100 (primitive -> DECIMAL .)


state 60

    (101) primitive -> DOUBLE .

    LSQBRACKET      reduce using rule 101 (primitive -> DOUBLE .)
    ID              reduce using rule 101 (primitive -> DOUBLE .)
    GREATER_THAN    reduce using rule 101 (primitive -> DOUBLE .)


state 61

    (102) primitive -> LONG .

    LSQBRACKET      reduce using rule 102 (primitive -> LONG .)
    ID              reduce using rule 102 (primitive -> LONG .)
    GREATER_THAN    reduce using rule 102 (primitive -> LONG .)


state 62

    (103) primitive -> SHORT .

    LSQBRACKET      reduce using rule 103 (primitive -> SHORT .)
    ID              reduce using rule 103 (primitive -> SHORT .)
    GREATER_THAN    reduce using rule 103 (primitive -> SHORT .)


state 63

    (104) primitive -> UINT .

    LSQBRACKET      reduce using rule 104 (primitive -> UINT .)
    ID              reduce using rule 104 (primitive -> UINT .)
    GREATER_THAN    reduce using rule 104 (primitive -> UINT .)


state 64

    (65) data_structure -> data_structure_list .

    ID              reduce using rule 65 (data_structure -> data_structure_list .)
    GREATER_THAN    reduce using rule 65 (data_structure -> data_structure_list .)


state 65

    (66) data_structure -> data_structure_array .

    ID              reduce using rule 66 (data_structure -> data_structure_array .)
    GREATER_THAN    reduce using rule 66 (data_structure -> data_structure_array .)


state 66

    (87) factor -> indexing .

    TIMES           reduce using rule 87 (factor -> indexing .)
    DIVIDE          reduce using rule 87 (factor -> indexing .)
    PLUS            reduce using rule 87 (factor -> indexing .)
    MINUS           reduce using rule 87 (factor -> indexing .)
    SEMICOLON       reduce using rule 87 (factor -> indexing .)
    RPAREN          reduce using rule 87 (factor -> indexing .)


state 67

    (67) data_structure_list -> LIST . LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET

    LESS_THAN       shift and go to state 100


state 68

    (33) type -> FLOAT_TYPE .

    TIMES           reduce using rule 33 (type -> FLOAT_TYPE .)
    DIVIDE          reduce using rule 33 (type -> FLOAT_TYPE .)
    PLUS            reduce using rule 33 (type -> FLOAT_TYPE .)
    MINUS           reduce using rule 33 (type -> FLOAT_TYPE .)
    SEMICOLON       reduce using rule 33 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 33 (type -> FLOAT_TYPE .)
    OR              reduce using rule 33 (type -> FLOAT_TYPE .)
    AND             reduce using rule 33 (type -> FLOAT_TYPE .)
    NOT             reduce using rule 33 (type -> FLOAT_TYPE .)
    GREATER_THAN    reduce using rule 33 (type -> FLOAT_TYPE .)
    LESS_THAN       reduce using rule 33 (type -> FLOAT_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 33 (type -> FLOAT_TYPE .)
    LESS_EQUALS_THAN reduce using rule 33 (type -> FLOAT_TYPE .)
    EQUALITY        reduce using rule 33 (type -> FLOAT_TYPE .)
    RSQBRACKET      reduce using rule 33 (type -> FLOAT_TYPE .)


state 69

    (34) type -> DOUBLE_TYPE .

    TIMES           reduce using rule 34 (type -> DOUBLE_TYPE .)
    DIVIDE          reduce using rule 34 (type -> DOUBLE_TYPE .)
    PLUS            reduce using rule 34 (type -> DOUBLE_TYPE .)
    MINUS           reduce using rule 34 (type -> DOUBLE_TYPE .)
    SEMICOLON       reduce using rule 34 (type -> DOUBLE_TYPE .)
    RPAREN          reduce using rule 34 (type -> DOUBLE_TYPE .)
    OR              reduce using rule 34 (type -> DOUBLE_TYPE .)
    AND             reduce using rule 34 (type -> DOUBLE_TYPE .)
    NOT             reduce using rule 34 (type -> DOUBLE_TYPE .)
    GREATER_THAN    reduce using rule 34 (type -> DOUBLE_TYPE .)
    LESS_THAN       reduce using rule 34 (type -> DOUBLE_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 34 (type -> DOUBLE_TYPE .)
    LESS_EQUALS_THAN reduce using rule 34 (type -> DOUBLE_TYPE .)
    EQUALITY        reduce using rule 34 (type -> DOUBLE_TYPE .)
    RSQBRACKET      reduce using rule 34 (type -> DOUBLE_TYPE .)


state 70

    (35) type -> DECIMAL_TYPE .

    TIMES           reduce using rule 35 (type -> DECIMAL_TYPE .)
    DIVIDE          reduce using rule 35 (type -> DECIMAL_TYPE .)
    PLUS            reduce using rule 35 (type -> DECIMAL_TYPE .)
    MINUS           reduce using rule 35 (type -> DECIMAL_TYPE .)
    SEMICOLON       reduce using rule 35 (type -> DECIMAL_TYPE .)
    RPAREN          reduce using rule 35 (type -> DECIMAL_TYPE .)
    OR              reduce using rule 35 (type -> DECIMAL_TYPE .)
    AND             reduce using rule 35 (type -> DECIMAL_TYPE .)
    NOT             reduce using rule 35 (type -> DECIMAL_TYPE .)
    GREATER_THAN    reduce using rule 35 (type -> DECIMAL_TYPE .)
    LESS_THAN       reduce using rule 35 (type -> DECIMAL_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 35 (type -> DECIMAL_TYPE .)
    LESS_EQUALS_THAN reduce using rule 35 (type -> DECIMAL_TYPE .)
    EQUALITY        reduce using rule 35 (type -> DECIMAL_TYPE .)
    RSQBRACKET      reduce using rule 35 (type -> DECIMAL_TYPE .)


state 71

    (36) type -> INTEGER_TYPE .

    TIMES           reduce using rule 36 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 36 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 36 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 36 (type -> INTEGER_TYPE .)
    SEMICOLON       reduce using rule 36 (type -> INTEGER_TYPE .)
    RPAREN          reduce using rule 36 (type -> INTEGER_TYPE .)
    OR              reduce using rule 36 (type -> INTEGER_TYPE .)
    AND             reduce using rule 36 (type -> INTEGER_TYPE .)
    NOT             reduce using rule 36 (type -> INTEGER_TYPE .)
    GREATER_THAN    reduce using rule 36 (type -> INTEGER_TYPE .)
    LESS_THAN       reduce using rule 36 (type -> INTEGER_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 36 (type -> INTEGER_TYPE .)
    LESS_EQUALS_THAN reduce using rule 36 (type -> INTEGER_TYPE .)
    EQUALITY        reduce using rule 36 (type -> INTEGER_TYPE .)
    RSQBRACKET      reduce using rule 36 (type -> INTEGER_TYPE .)


state 72

    (8) class -> modifier STATIC CLASS CLASSOBJECT block .

    $end            reduce using rule 8 (class -> modifier STATIC CLASS CLASSOBJECT block .)


state 73

    (13) block -> LBRACKET body RBRACKET .

    $end            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    ELSE            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    SEMICOLON       reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 13 (block -> LBRACKET body RBRACKET .)


state 74

    (14) body -> lines SEMICOLON .
    (15) body -> lines SEMICOLON . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . function
    (17) lines -> . assignment
    (18) lines -> . expression
    (19) lines -> . declaration
    (20) lines -> . if
    (21) lines -> . loop
    (22) lines -> . return
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (70) assignment -> . ID EQUALS expression
    (71) assignment -> . data_type ID EQUALS expression
    (72) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (77) expression -> . expression PLUS term
    (78) expression -> . expression MINUS term
    (79) expression -> . term
    (76) declaration -> . data_type ID
    (37) if -> . IF LPAREN logical_expression RPAREN block
    (38) if -> . IF LPAREN logical_expression RPAREN block elseif
    (39) if -> . IF LPAREN logical_expression RPAREN block else
    (44) loop -> . while_loop
    (45) loop -> . loop_for
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (88) modifier -> . PUBLIC
    (89) modifier -> . PRIVATE
    (90) modifier -> . PROTECTED
    (91) modifier -> . INTERNAL
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (47) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (46) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 14 (body -> lines SEMICOLON .)
    ID              shift and go to state 38
    CLASSOBJECT     shift and go to state 40
    IF              shift and go to state 43
    RETURN          shift and go to state 46
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LPAREN          shift and go to state 39
    LIST            shift and go to state 67
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    lines                          shift and go to state 28
    body                           shift and go to state 101
    function                       shift and go to state 29
    assignment                     shift and go to state 30
    expression                     shift and go to state 31
    declaration                    shift and go to state 32
    if                             shift and go to state 33
    loop                           shift and go to state 34
    return                         shift and go to state 35
    modifier                       shift and go to state 36
    data_type                      shift and go to state 37
    object_access                  shift and go to state 41
    term                           shift and go to state 42
    while_loop                     shift and go to state 44
    loop_for                       shift and go to state 45
    type                           shift and go to state 47
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    factor                         shift and go to state 50
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65
    indexing                       shift and go to state 66

state 75

    (77) expression -> expression PLUS . term
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 104
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    term                           shift and go to state 102
    factor                         shift and go to state 50
    type                           shift and go to state 47
    object_access                  shift and go to state 103
    indexing                       shift and go to state 66

state 76

    (78) expression -> expression MINUS . term
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 104
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    term                           shift and go to state 105
    factor                         shift and go to state 50
    type                           shift and go to state 47
    object_access                  shift and go to state 103
    indexing                       shift and go to state 66

state 77

    (23) function -> modifier data_type . ID LPAREN declarations RPAREN block

    ID              shift and go to state 106


state 78

    (24) function -> modifier VOID . ID LPAREN declarations RPAREN block

    ID              shift and go to state 107


state 79

    (25) function -> modifier STATIC . data_type ID LPAREN declarations RPAREN block
    (26) function -> modifier STATIC . VOID ID LPAREN declarations RPAREN block
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 109
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    data_type                      shift and go to state 108
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 80

    (69) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    LSQBRACKET      shift and go to state 90


state 81

    (71) assignment -> data_type ID . EQUALS expression
    (76) declaration -> data_type ID .

    EQUALS          shift and go to state 110
    SEMICOLON       reduce using rule 76 (declaration -> data_type ID .)


state 82

    (70) assignment -> ID EQUALS . expression
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (77) expression -> . expression PLUS term
    (78) expression -> . expression MINUS term
    (79) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 39
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    expression                     shift and go to state 111
    object_access                  shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 50
    type                           shift and go to state 47
    indexing                       shift and go to state 66

state 83

    (9) object_access -> ID DOT . ID
    (11) object_access -> ID DOT . CLASSOBJECT

    ID              shift and go to state 112
    CLASSOBJECT     shift and go to state 113


state 84

    (105) indexing -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (106) indexing -> ID LSQBRACKET . ID RSQBRACKET

    INTEGER_TYPE    shift and go to state 115
    ID              shift and go to state 114


state 85

    (84) factor -> LPAREN expression . RPAREN
    (77) expression -> expression . PLUS term
    (78) expression -> expression . MINUS term

    RPAREN          shift and go to state 116
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 86

    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (86) factor -> ID .
    (105) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> ID . LSQBRACKET ID RSQBRACKET

    DOT             shift and go to state 83
    TIMES           reduce using rule 86 (factor -> ID .)
    DIVIDE          reduce using rule 86 (factor -> ID .)
    RPAREN          reduce using rule 86 (factor -> ID .)
    PLUS            reduce using rule 86 (factor -> ID .)
    MINUS           reduce using rule 86 (factor -> ID .)
    SEMICOLON       reduce using rule 86 (factor -> ID .)
    LSQBRACKET      shift and go to state 84


state 87

    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID

    DOT             shift and go to state 89


state 88

    (72) assignment -> CLASSOBJECT ID .

    SEMICOLON       reduce using rule 72 (assignment -> CLASSOBJECT ID .)
    RPAREN          reduce using rule 72 (assignment -> CLASSOBJECT ID .)


state 89

    (10) object_access -> CLASSOBJECT DOT . CLASSOBJECT
    (12) object_access -> CLASSOBJECT DOT . ID

    CLASSOBJECT     shift and go to state 117
    ID              shift and go to state 118


state 90

    (69) data_structure_array -> CLASSOBJECT LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 119


state 91

    (31) expression -> object_access LPAREN . expression RPAREN
    (32) expression -> object_access LPAREN . RPAREN
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (77) expression -> . expression PLUS term
    (78) expression -> . expression MINUS term
    (79) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RPAREN          shift and go to state 121
    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 39
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    object_access                  shift and go to state 41
    expression                     shift and go to state 120
    term                           shift and go to state 42
    factor                         shift and go to state 50
    type                           shift and go to state 47
    indexing                       shift and go to state 66

state 92

    (80) term -> term TIMES . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 104
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    factor                         shift and go to state 122
    type                           shift and go to state 47
    object_access                  shift and go to state 103
    indexing                       shift and go to state 66

state 93

    (81) term -> term DIVIDE . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 104
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    factor                         shift and go to state 123
    type                           shift and go to state 47
    object_access                  shift and go to state 103
    indexing                       shift and go to state 66

state 94

    (37) if -> IF LPAREN . logical_expression RPAREN block
    (38) if -> IF LPAREN . logical_expression RPAREN block elseif
    (39) if -> IF LPAREN . logical_expression RPAREN block else
    (48) logical_expression -> . logical_expression logical_operator logical_factor
    (49) logical_expression -> . logical_factor
    (50) logical_factor -> . TRUE
    (51) logical_factor -> . FALSE
    (52) logical_factor -> . ID
    (53) logical_factor -> . indexing
    (54) logical_factor -> . type
    (55) logical_factor -> . object_access
    (56) logical_factor -> . LPAREN logical_expression RPAREN
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    logical_expression             shift and go to state 125
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 95

    (27) return -> RETURN ID .

    SEMICOLON       reduce using rule 27 (return -> RETURN ID .)


state 96

    (28) return -> RETURN type .

    SEMICOLON       reduce using rule 28 (return -> RETURN type .)


state 97

    (68) data_structure_array -> primitive LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 133


state 98

    (47) while_loop -> WHILE LPAREN . logical_expression RPAREN block
    (48) logical_expression -> . logical_expression logical_operator logical_factor
    (49) logical_expression -> . logical_factor
    (50) logical_factor -> . TRUE
    (51) logical_factor -> . FALSE
    (52) logical_factor -> . ID
    (53) logical_factor -> . indexing
    (54) logical_factor -> . type
    (55) logical_factor -> . object_access
    (56) logical_factor -> . LPAREN logical_expression RPAREN
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    logical_expression             shift and go to state 134
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 99

    (46) loop_for -> FOR LPAREN . assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (70) assignment -> . ID EQUALS expression
    (71) assignment -> . data_type ID EQUALS expression
    (72) assignment -> . CLASSOBJECT ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    ID              shift and go to state 136
    CLASSOBJECT     shift and go to state 138
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67

    assignment                     shift and go to state 135
    data_type                      shift and go to state 137
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 100

    (67) data_structure_list -> LIST LESS_THAN . data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    data_type                      shift and go to state 139
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 101

    (15) body -> lines SEMICOLON body .

    RBRACKET        reduce using rule 15 (body -> lines SEMICOLON body .)


state 102

    (77) expression -> expression PLUS term .
    (80) term -> term . TIMES factor
    (81) term -> term . DIVIDE factor

    PLUS            reduce using rule 77 (expression -> expression PLUS term .)
    MINUS           reduce using rule 77 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 77 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 77 (expression -> expression PLUS term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93


state 103

    (85) factor -> object_access .

    TIMES           reduce using rule 85 (factor -> object_access .)
    DIVIDE          reduce using rule 85 (factor -> object_access .)
    PLUS            reduce using rule 85 (factor -> object_access .)
    MINUS           reduce using rule 85 (factor -> object_access .)
    SEMICOLON       reduce using rule 85 (factor -> object_access .)
    RPAREN          reduce using rule 85 (factor -> object_access .)


state 104

    (86) factor -> ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (105) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> ID . LSQBRACKET ID RSQBRACKET

    TIMES           reduce using rule 86 (factor -> ID .)
    DIVIDE          reduce using rule 86 (factor -> ID .)
    PLUS            reduce using rule 86 (factor -> ID .)
    MINUS           reduce using rule 86 (factor -> ID .)
    SEMICOLON       reduce using rule 86 (factor -> ID .)
    RPAREN          reduce using rule 86 (factor -> ID .)
    DOT             shift and go to state 83
    LSQBRACKET      shift and go to state 84


state 105

    (78) expression -> expression MINUS term .
    (80) term -> term . TIMES factor
    (81) term -> term . DIVIDE factor

    PLUS            reduce using rule 78 (expression -> expression MINUS term .)
    MINUS           reduce using rule 78 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 78 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 78 (expression -> expression MINUS term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93


state 106

    (23) function -> modifier data_type ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 140


state 107

    (24) function -> modifier VOID ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 141


state 108

    (25) function -> modifier STATIC data_type . ID LPAREN declarations RPAREN block

    ID              shift and go to state 142


state 109

    (26) function -> modifier STATIC VOID . ID LPAREN declarations RPAREN block

    ID              shift and go to state 143


state 110

    (71) assignment -> data_type ID EQUALS . expression
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (77) expression -> . expression PLUS term
    (78) expression -> . expression MINUS term
    (79) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (80) term -> . term TIMES factor
    (81) term -> . term DIVIDE factor
    (82) term -> . factor
    (83) factor -> . type
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . object_access
    (86) factor -> . ID
    (87) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 39
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    expression                     shift and go to state 144
    object_access                  shift and go to state 41
    term                           shift and go to state 42
    factor                         shift and go to state 50
    type                           shift and go to state 47
    indexing                       shift and go to state 66

state 111

    (70) assignment -> ID EQUALS expression .
    (77) expression -> expression . PLUS term
    (78) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 70 (assignment -> ID EQUALS expression .)
    RPAREN          reduce using rule 70 (assignment -> ID EQUALS expression .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 112

    (9) object_access -> ID DOT ID .

    LPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    TIMES           reduce using rule 9 (object_access -> ID DOT ID .)
    DIVIDE          reduce using rule 9 (object_access -> ID DOT ID .)
    PLUS            reduce using rule 9 (object_access -> ID DOT ID .)
    MINUS           reduce using rule 9 (object_access -> ID DOT ID .)
    SEMICOLON       reduce using rule 9 (object_access -> ID DOT ID .)
    RPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    OR              reduce using rule 9 (object_access -> ID DOT ID .)
    AND             reduce using rule 9 (object_access -> ID DOT ID .)
    NOT             reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_THAN    reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_THAN       reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    EQUALITY        reduce using rule 9 (object_access -> ID DOT ID .)


state 113

    (11) object_access -> ID DOT CLASSOBJECT .

    LPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    TIMES           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    PLUS            reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    MINUS           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    RPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    OR              reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    AND             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    NOT             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)


state 114

    (106) indexing -> ID LSQBRACKET ID . RSQBRACKET

    RSQBRACKET      shift and go to state 145


state 115

    (105) indexing -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET

    RSQBRACKET      shift and go to state 146


state 116

    (84) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 84 (factor -> LPAREN expression RPAREN .)


state 117

    (10) object_access -> CLASSOBJECT DOT CLASSOBJECT .

    LPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    TIMES           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    PLUS            reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    MINUS           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    RPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    OR              reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    AND             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    NOT             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)


state 118

    (12) object_access -> CLASSOBJECT DOT ID .

    LPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    TIMES           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    DIVIDE          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    PLUS            reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    MINUS           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    SEMICOLON       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    RPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    OR              reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    AND             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    NOT             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_THAN    reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_THAN       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    EQUALITY        reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)


state 119

    (69) data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .

    ID              reduce using rule 69 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)
    GREATER_THAN    reduce using rule 69 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)


state 120

    (31) expression -> object_access LPAREN expression . RPAREN
    (77) expression -> expression . PLUS term
    (78) expression -> expression . MINUS term

    RPAREN          shift and go to state 147
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 121

    (32) expression -> object_access LPAREN RPAREN .

    PLUS            reduce using rule 32 (expression -> object_access LPAREN RPAREN .)
    MINUS           reduce using rule 32 (expression -> object_access LPAREN RPAREN .)
    SEMICOLON       reduce using rule 32 (expression -> object_access LPAREN RPAREN .)
    RPAREN          reduce using rule 32 (expression -> object_access LPAREN RPAREN .)


state 122

    (80) term -> term TIMES factor .

    TIMES           reduce using rule 80 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 80 (term -> term TIMES factor .)
    PLUS            reduce using rule 80 (term -> term TIMES factor .)
    MINUS           reduce using rule 80 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 80 (term -> term TIMES factor .)
    RPAREN          reduce using rule 80 (term -> term TIMES factor .)


state 123

    (81) term -> term DIVIDE factor .

    TIMES           reduce using rule 81 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 81 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 81 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 81 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 81 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 81 (term -> term DIVIDE factor .)


state 124

    (56) logical_factor -> LPAREN . logical_expression RPAREN
    (48) logical_expression -> . logical_expression logical_operator logical_factor
    (49) logical_expression -> . logical_factor
    (50) logical_factor -> . TRUE
    (51) logical_factor -> . FALSE
    (52) logical_factor -> . ID
    (53) logical_factor -> . indexing
    (54) logical_factor -> . type
    (55) logical_factor -> . object_access
    (56) logical_factor -> . LPAREN logical_expression RPAREN
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    logical_expression             shift and go to state 148
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 125

    (37) if -> IF LPAREN logical_expression . RPAREN block
    (38) if -> IF LPAREN logical_expression . RPAREN block elseif
    (39) if -> IF LPAREN logical_expression . RPAREN block else
    (48) logical_expression -> logical_expression . logical_operator logical_factor
    (57) logical_operator -> . OR
    (58) logical_operator -> . AND
    (59) logical_operator -> . NOT
    (60) logical_operator -> . GREATER_THAN
    (61) logical_operator -> . LESS_THAN
    (62) logical_operator -> . GREATER_EQUALS_THAN
    (63) logical_operator -> . LESS_EQUALS_THAN
    (64) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 149
    OR              shift and go to state 151
    AND             shift and go to state 152
    NOT             shift and go to state 153
    GREATER_THAN    shift and go to state 154
    LESS_THAN       shift and go to state 155
    GREATER_EQUALS_THAN shift and go to state 156
    LESS_EQUALS_THAN shift and go to state 157
    EQUALITY        shift and go to state 158

    logical_operator               shift and go to state 150

state 126

    (49) logical_expression -> logical_factor .

    RPAREN          reduce using rule 49 (logical_expression -> logical_factor .)
    OR              reduce using rule 49 (logical_expression -> logical_factor .)
    AND             reduce using rule 49 (logical_expression -> logical_factor .)
    NOT             reduce using rule 49 (logical_expression -> logical_factor .)
    GREATER_THAN    reduce using rule 49 (logical_expression -> logical_factor .)
    LESS_THAN       reduce using rule 49 (logical_expression -> logical_factor .)
    GREATER_EQUALS_THAN reduce using rule 49 (logical_expression -> logical_factor .)
    LESS_EQUALS_THAN reduce using rule 49 (logical_expression -> logical_factor .)
    EQUALITY        reduce using rule 49 (logical_expression -> logical_factor .)
    SEMICOLON       reduce using rule 49 (logical_expression -> logical_factor .)


state 127

    (50) logical_factor -> TRUE .

    RPAREN          reduce using rule 50 (logical_factor -> TRUE .)
    OR              reduce using rule 50 (logical_factor -> TRUE .)
    AND             reduce using rule 50 (logical_factor -> TRUE .)
    NOT             reduce using rule 50 (logical_factor -> TRUE .)
    GREATER_THAN    reduce using rule 50 (logical_factor -> TRUE .)
    LESS_THAN       reduce using rule 50 (logical_factor -> TRUE .)
    GREATER_EQUALS_THAN reduce using rule 50 (logical_factor -> TRUE .)
    LESS_EQUALS_THAN reduce using rule 50 (logical_factor -> TRUE .)
    EQUALITY        reduce using rule 50 (logical_factor -> TRUE .)
    SEMICOLON       reduce using rule 50 (logical_factor -> TRUE .)


state 128

    (51) logical_factor -> FALSE .

    RPAREN          reduce using rule 51 (logical_factor -> FALSE .)
    OR              reduce using rule 51 (logical_factor -> FALSE .)
    AND             reduce using rule 51 (logical_factor -> FALSE .)
    NOT             reduce using rule 51 (logical_factor -> FALSE .)
    GREATER_THAN    reduce using rule 51 (logical_factor -> FALSE .)
    LESS_THAN       reduce using rule 51 (logical_factor -> FALSE .)
    GREATER_EQUALS_THAN reduce using rule 51 (logical_factor -> FALSE .)
    LESS_EQUALS_THAN reduce using rule 51 (logical_factor -> FALSE .)
    EQUALITY        reduce using rule 51 (logical_factor -> FALSE .)
    SEMICOLON       reduce using rule 51 (logical_factor -> FALSE .)


state 129

    (52) logical_factor -> ID .
    (105) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT

    RPAREN          reduce using rule 52 (logical_factor -> ID .)
    OR              reduce using rule 52 (logical_factor -> ID .)
    AND             reduce using rule 52 (logical_factor -> ID .)
    NOT             reduce using rule 52 (logical_factor -> ID .)
    GREATER_THAN    reduce using rule 52 (logical_factor -> ID .)
    LESS_THAN       reduce using rule 52 (logical_factor -> ID .)
    GREATER_EQUALS_THAN reduce using rule 52 (logical_factor -> ID .)
    LESS_EQUALS_THAN reduce using rule 52 (logical_factor -> ID .)
    EQUALITY        reduce using rule 52 (logical_factor -> ID .)
    SEMICOLON       reduce using rule 52 (logical_factor -> ID .)
    LSQBRACKET      shift and go to state 84
    DOT             shift and go to state 83


state 130

    (53) logical_factor -> indexing .

    RPAREN          reduce using rule 53 (logical_factor -> indexing .)
    OR              reduce using rule 53 (logical_factor -> indexing .)
    AND             reduce using rule 53 (logical_factor -> indexing .)
    NOT             reduce using rule 53 (logical_factor -> indexing .)
    GREATER_THAN    reduce using rule 53 (logical_factor -> indexing .)
    LESS_THAN       reduce using rule 53 (logical_factor -> indexing .)
    GREATER_EQUALS_THAN reduce using rule 53 (logical_factor -> indexing .)
    LESS_EQUALS_THAN reduce using rule 53 (logical_factor -> indexing .)
    EQUALITY        reduce using rule 53 (logical_factor -> indexing .)
    SEMICOLON       reduce using rule 53 (logical_factor -> indexing .)


state 131

    (54) logical_factor -> type .

    RPAREN          reduce using rule 54 (logical_factor -> type .)
    OR              reduce using rule 54 (logical_factor -> type .)
    AND             reduce using rule 54 (logical_factor -> type .)
    NOT             reduce using rule 54 (logical_factor -> type .)
    GREATER_THAN    reduce using rule 54 (logical_factor -> type .)
    LESS_THAN       reduce using rule 54 (logical_factor -> type .)
    GREATER_EQUALS_THAN reduce using rule 54 (logical_factor -> type .)
    LESS_EQUALS_THAN reduce using rule 54 (logical_factor -> type .)
    EQUALITY        reduce using rule 54 (logical_factor -> type .)
    SEMICOLON       reduce using rule 54 (logical_factor -> type .)


state 132

    (55) logical_factor -> object_access .

    RPAREN          reduce using rule 55 (logical_factor -> object_access .)
    OR              reduce using rule 55 (logical_factor -> object_access .)
    AND             reduce using rule 55 (logical_factor -> object_access .)
    NOT             reduce using rule 55 (logical_factor -> object_access .)
    GREATER_THAN    reduce using rule 55 (logical_factor -> object_access .)
    LESS_THAN       reduce using rule 55 (logical_factor -> object_access .)
    GREATER_EQUALS_THAN reduce using rule 55 (logical_factor -> object_access .)
    LESS_EQUALS_THAN reduce using rule 55 (logical_factor -> object_access .)
    EQUALITY        reduce using rule 55 (logical_factor -> object_access .)
    SEMICOLON       reduce using rule 55 (logical_factor -> object_access .)


state 133

    (68) data_structure_array -> primitive LSQBRACKET RSQBRACKET .

    ID              reduce using rule 68 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)
    GREATER_THAN    reduce using rule 68 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)


state 134

    (47) while_loop -> WHILE LPAREN logical_expression . RPAREN block
    (48) logical_expression -> logical_expression . logical_operator logical_factor
    (57) logical_operator -> . OR
    (58) logical_operator -> . AND
    (59) logical_operator -> . NOT
    (60) logical_operator -> . GREATER_THAN
    (61) logical_operator -> . LESS_THAN
    (62) logical_operator -> . GREATER_EQUALS_THAN
    (63) logical_operator -> . LESS_EQUALS_THAN
    (64) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 159
    OR              shift and go to state 151
    AND             shift and go to state 152
    NOT             shift and go to state 153
    GREATER_THAN    shift and go to state 154
    LESS_THAN       shift and go to state 155
    GREATER_EQUALS_THAN shift and go to state 156
    LESS_EQUALS_THAN shift and go to state 157
    EQUALITY        shift and go to state 158

    logical_operator               shift and go to state 150

state 135

    (46) loop_for -> FOR LPAREN assignment . SEMICOLON logical_expression SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 160


state 136

    (70) assignment -> ID . EQUALS expression

    EQUALS          shift and go to state 82


state 137

    (71) assignment -> data_type . ID EQUALS expression

    ID              shift and go to state 161


state 138

    (72) assignment -> CLASSOBJECT . ID
    (69) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    ID              shift and go to state 88
    LSQBRACKET      shift and go to state 90


state 139

    (67) data_structure_list -> LIST LESS_THAN data_type . GREATER_THAN ID LSQBRACKET type RSQBRACKET

    GREATER_THAN    shift and go to state 162


state 140

    (23) function -> modifier data_type ID LPAREN . declarations RPAREN block
    (73) declarations -> . declaration
    (74) declarations -> . declaration COMMA
    (75) declarations -> . declaration COMMA declarations
    (76) declaration -> . data_type ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    data_type                      shift and go to state 163
    declarations                   shift and go to state 164
    declaration                    shift and go to state 165
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 141

    (24) function -> modifier VOID ID LPAREN . declarations RPAREN block
    (73) declarations -> . declaration
    (74) declarations -> . declaration COMMA
    (75) declarations -> . declaration COMMA declarations
    (76) declaration -> . data_type ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    declarations                   shift and go to state 166
    declaration                    shift and go to state 165
    data_type                      shift and go to state 163
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 142

    (25) function -> modifier STATIC data_type ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 167


state 143

    (26) function -> modifier STATIC VOID ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 168


state 144

    (71) assignment -> data_type ID EQUALS expression .
    (77) expression -> expression . PLUS term
    (78) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 71 (assignment -> data_type ID EQUALS expression .)
    RPAREN          reduce using rule 71 (assignment -> data_type ID EQUALS expression .)
    PLUS            shift and go to state 75
    MINUS           shift and go to state 76


state 145

    (106) indexing -> ID LSQBRACKET ID RSQBRACKET .

    TIMES           reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    DIVIDE          reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    PLUS            reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    MINUS           reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    SEMICOLON       reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    RPAREN          reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    OR              reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    AND             reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    NOT             reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_THAN    reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_THAN       reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    EQUALITY        reduce using rule 106 (indexing -> ID LSQBRACKET ID RSQBRACKET .)


state 146

    (105) indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .

    TIMES           reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    DIVIDE          reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    PLUS            reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    MINUS           reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    SEMICOLON       reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    RPAREN          reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    OR              reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    AND             reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    NOT             reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_THAN    reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_THAN       reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    EQUALITY        reduce using rule 105 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)


state 147

    (31) expression -> object_access LPAREN expression RPAREN .

    PLUS            reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)
    MINUS           reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)
    RPAREN          reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)


state 148

    (56) logical_factor -> LPAREN logical_expression . RPAREN
    (48) logical_expression -> logical_expression . logical_operator logical_factor
    (57) logical_operator -> . OR
    (58) logical_operator -> . AND
    (59) logical_operator -> . NOT
    (60) logical_operator -> . GREATER_THAN
    (61) logical_operator -> . LESS_THAN
    (62) logical_operator -> . GREATER_EQUALS_THAN
    (63) logical_operator -> . LESS_EQUALS_THAN
    (64) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 169
    OR              shift and go to state 151
    AND             shift and go to state 152
    NOT             shift and go to state 153
    GREATER_THAN    shift and go to state 154
    LESS_THAN       shift and go to state 155
    GREATER_EQUALS_THAN shift and go to state 156
    LESS_EQUALS_THAN shift and go to state 157
    EQUALITY        shift and go to state 158

    logical_operator               shift and go to state 150

state 149

    (37) if -> IF LPAREN logical_expression RPAREN . block
    (38) if -> IF LPAREN logical_expression RPAREN . block elseif
    (39) if -> IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 170

state 150

    (48) logical_expression -> logical_expression logical_operator . logical_factor
    (50) logical_factor -> . TRUE
    (51) logical_factor -> . FALSE
    (52) logical_factor -> . ID
    (53) logical_factor -> . indexing
    (54) logical_factor -> . type
    (55) logical_factor -> . object_access
    (56) logical_factor -> . LPAREN logical_expression RPAREN
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    logical_factor                 shift and go to state 171
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 151

    (57) logical_operator -> OR .

    TRUE            reduce using rule 57 (logical_operator -> OR .)
    FALSE           reduce using rule 57 (logical_operator -> OR .)
    ID              reduce using rule 57 (logical_operator -> OR .)
    LPAREN          reduce using rule 57 (logical_operator -> OR .)
    FLOAT_TYPE      reduce using rule 57 (logical_operator -> OR .)
    DOUBLE_TYPE     reduce using rule 57 (logical_operator -> OR .)
    DECIMAL_TYPE    reduce using rule 57 (logical_operator -> OR .)
    INTEGER_TYPE    reduce using rule 57 (logical_operator -> OR .)
    CLASSOBJECT     reduce using rule 57 (logical_operator -> OR .)


state 152

    (58) logical_operator -> AND .

    TRUE            reduce using rule 58 (logical_operator -> AND .)
    FALSE           reduce using rule 58 (logical_operator -> AND .)
    ID              reduce using rule 58 (logical_operator -> AND .)
    LPAREN          reduce using rule 58 (logical_operator -> AND .)
    FLOAT_TYPE      reduce using rule 58 (logical_operator -> AND .)
    DOUBLE_TYPE     reduce using rule 58 (logical_operator -> AND .)
    DECIMAL_TYPE    reduce using rule 58 (logical_operator -> AND .)
    INTEGER_TYPE    reduce using rule 58 (logical_operator -> AND .)
    CLASSOBJECT     reduce using rule 58 (logical_operator -> AND .)


state 153

    (59) logical_operator -> NOT .

    TRUE            reduce using rule 59 (logical_operator -> NOT .)
    FALSE           reduce using rule 59 (logical_operator -> NOT .)
    ID              reduce using rule 59 (logical_operator -> NOT .)
    LPAREN          reduce using rule 59 (logical_operator -> NOT .)
    FLOAT_TYPE      reduce using rule 59 (logical_operator -> NOT .)
    DOUBLE_TYPE     reduce using rule 59 (logical_operator -> NOT .)
    DECIMAL_TYPE    reduce using rule 59 (logical_operator -> NOT .)
    INTEGER_TYPE    reduce using rule 59 (logical_operator -> NOT .)
    CLASSOBJECT     reduce using rule 59 (logical_operator -> NOT .)


state 154

    (60) logical_operator -> GREATER_THAN .

    TRUE            reduce using rule 60 (logical_operator -> GREATER_THAN .)
    FALSE           reduce using rule 60 (logical_operator -> GREATER_THAN .)
    ID              reduce using rule 60 (logical_operator -> GREATER_THAN .)
    LPAREN          reduce using rule 60 (logical_operator -> GREATER_THAN .)
    FLOAT_TYPE      reduce using rule 60 (logical_operator -> GREATER_THAN .)
    DOUBLE_TYPE     reduce using rule 60 (logical_operator -> GREATER_THAN .)
    DECIMAL_TYPE    reduce using rule 60 (logical_operator -> GREATER_THAN .)
    INTEGER_TYPE    reduce using rule 60 (logical_operator -> GREATER_THAN .)
    CLASSOBJECT     reduce using rule 60 (logical_operator -> GREATER_THAN .)


state 155

    (61) logical_operator -> LESS_THAN .

    TRUE            reduce using rule 61 (logical_operator -> LESS_THAN .)
    FALSE           reduce using rule 61 (logical_operator -> LESS_THAN .)
    ID              reduce using rule 61 (logical_operator -> LESS_THAN .)
    LPAREN          reduce using rule 61 (logical_operator -> LESS_THAN .)
    FLOAT_TYPE      reduce using rule 61 (logical_operator -> LESS_THAN .)
    DOUBLE_TYPE     reduce using rule 61 (logical_operator -> LESS_THAN .)
    DECIMAL_TYPE    reduce using rule 61 (logical_operator -> LESS_THAN .)
    INTEGER_TYPE    reduce using rule 61 (logical_operator -> LESS_THAN .)
    CLASSOBJECT     reduce using rule 61 (logical_operator -> LESS_THAN .)


state 156

    (62) logical_operator -> GREATER_EQUALS_THAN .

    TRUE            reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    FALSE           reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    ID              reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    LPAREN          reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 62 (logical_operator -> GREATER_EQUALS_THAN .)


state 157

    (63) logical_operator -> LESS_EQUALS_THAN .

    TRUE            reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    FALSE           reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    ID              reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    LPAREN          reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 63 (logical_operator -> LESS_EQUALS_THAN .)


state 158

    (64) logical_operator -> EQUALITY .

    TRUE            reduce using rule 64 (logical_operator -> EQUALITY .)
    FALSE           reduce using rule 64 (logical_operator -> EQUALITY .)
    ID              reduce using rule 64 (logical_operator -> EQUALITY .)
    LPAREN          reduce using rule 64 (logical_operator -> EQUALITY .)
    FLOAT_TYPE      reduce using rule 64 (logical_operator -> EQUALITY .)
    DOUBLE_TYPE     reduce using rule 64 (logical_operator -> EQUALITY .)
    DECIMAL_TYPE    reduce using rule 64 (logical_operator -> EQUALITY .)
    INTEGER_TYPE    reduce using rule 64 (logical_operator -> EQUALITY .)
    CLASSOBJECT     reduce using rule 64 (logical_operator -> EQUALITY .)


state 159

    (47) while_loop -> WHILE LPAREN logical_expression RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 172

state 160

    (46) loop_for -> FOR LPAREN assignment SEMICOLON . logical_expression SEMICOLON assignment RPAREN block
    (48) logical_expression -> . logical_expression logical_operator logical_factor
    (49) logical_expression -> . logical_factor
    (50) logical_factor -> . TRUE
    (51) logical_factor -> . FALSE
    (52) logical_factor -> . ID
    (53) logical_factor -> . indexing
    (54) logical_factor -> . type
    (55) logical_factor -> . object_access
    (56) logical_factor -> . LPAREN logical_expression RPAREN
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    logical_expression             shift and go to state 173
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 161

    (71) assignment -> data_type ID . EQUALS expression

    EQUALS          shift and go to state 110


state 162

    (67) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN . ID LSQBRACKET type RSQBRACKET

    ID              shift and go to state 174


state 163

    (76) declaration -> data_type . ID

    ID              shift and go to state 175


state 164

    (23) function -> modifier data_type ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 176


state 165

    (73) declarations -> declaration .
    (74) declarations -> declaration . COMMA
    (75) declarations -> declaration . COMMA declarations

    RPAREN          reduce using rule 73 (declarations -> declaration .)
    COMMA           shift and go to state 177


state 166

    (24) function -> modifier VOID ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 178


state 167

    (25) function -> modifier STATIC data_type ID LPAREN . declarations RPAREN block
    (73) declarations -> . declaration
    (74) declarations -> . declaration COMMA
    (75) declarations -> . declaration COMMA declarations
    (76) declaration -> . data_type ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    data_type                      shift and go to state 163
    declarations                   shift and go to state 179
    declaration                    shift and go to state 165
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 168

    (26) function -> modifier STATIC VOID ID LPAREN . declarations RPAREN block
    (73) declarations -> . declaration
    (74) declarations -> . declaration COMMA
    (75) declarations -> . declaration COMMA declarations
    (76) declaration -> . data_type ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    declarations                   shift and go to state 180
    declaration                    shift and go to state 165
    data_type                      shift and go to state 163
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 169

    (56) logical_factor -> LPAREN logical_expression RPAREN .

    RPAREN          reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    OR              reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    AND             reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    NOT             reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_THAN    reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_THAN       reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_EQUALS_THAN reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_EQUALS_THAN reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    EQUALITY        reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)
    SEMICOLON       reduce using rule 56 (logical_factor -> LPAREN logical_expression RPAREN .)


state 170

    (37) if -> IF LPAREN logical_expression RPAREN block .
    (38) if -> IF LPAREN logical_expression RPAREN block . elseif
    (39) if -> IF LPAREN logical_expression RPAREN block . else
    (40) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (41) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (42) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (43) else -> . ELSE block

    SEMICOLON       reduce using rule 37 (if -> IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 183

    elseif                         shift and go to state 181
    else                           shift and go to state 182

state 171

    (48) logical_expression -> logical_expression logical_operator logical_factor .

    RPAREN          reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    OR              reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    AND             reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    NOT             reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    GREATER_THAN    reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    LESS_THAN       reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    GREATER_EQUALS_THAN reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    LESS_EQUALS_THAN reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    EQUALITY        reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)
    SEMICOLON       reduce using rule 48 (logical_expression -> logical_expression logical_operator logical_factor .)


state 172

    (47) while_loop -> WHILE LPAREN logical_expression RPAREN block .

    SEMICOLON       reduce using rule 47 (while_loop -> WHILE LPAREN logical_expression RPAREN block .)


state 173

    (46) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression . SEMICOLON assignment RPAREN block
    (48) logical_expression -> logical_expression . logical_operator logical_factor
    (57) logical_operator -> . OR
    (58) logical_operator -> . AND
    (59) logical_operator -> . NOT
    (60) logical_operator -> . GREATER_THAN
    (61) logical_operator -> . LESS_THAN
    (62) logical_operator -> . GREATER_EQUALS_THAN
    (63) logical_operator -> . LESS_EQUALS_THAN
    (64) logical_operator -> . EQUALITY

    SEMICOLON       shift and go to state 184
    OR              shift and go to state 151
    AND             shift and go to state 152
    NOT             shift and go to state 153
    GREATER_THAN    shift and go to state 154
    LESS_THAN       shift and go to state 155
    GREATER_EQUALS_THAN shift and go to state 156
    LESS_EQUALS_THAN shift and go to state 157
    EQUALITY        shift and go to state 158

    logical_operator               shift and go to state 150

state 174

    (67) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID . LSQBRACKET type RSQBRACKET

    LSQBRACKET      shift and go to state 185


state 175

    (76) declaration -> data_type ID .

    COMMA           reduce using rule 76 (declaration -> data_type ID .)
    RPAREN          reduce using rule 76 (declaration -> data_type ID .)


state 176

    (23) function -> modifier data_type ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 186

state 177

    (74) declarations -> declaration COMMA .
    (75) declarations -> declaration COMMA . declarations
    (73) declarations -> . declaration
    (74) declarations -> . declaration COMMA
    (75) declarations -> . declaration COMMA declarations
    (76) declaration -> . data_type ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    RPAREN          reduce using rule 74 (declarations -> declaration COMMA .)
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67
    CLASSOBJECT     shift and go to state 80

    declaration                    shift and go to state 165
    declarations                   shift and go to state 187
    data_type                      shift and go to state 163
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 178

    (24) function -> modifier VOID ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 188

state 179

    (25) function -> modifier STATIC data_type ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 189


state 180

    (26) function -> modifier STATIC VOID ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 190


state 181

    (38) if -> IF LPAREN logical_expression RPAREN block elseif .

    SEMICOLON       reduce using rule 38 (if -> IF LPAREN logical_expression RPAREN block elseif .)


state 182

    (39) if -> IF LPAREN logical_expression RPAREN block else .

    SEMICOLON       reduce using rule 39 (if -> IF LPAREN logical_expression RPAREN block else .)


state 183

    (40) elseif -> ELSE . IF LPAREN logical_expression RPAREN block
    (41) elseif -> ELSE . IF LPAREN logical_expression RPAREN block elseif
    (42) elseif -> ELSE . IF LPAREN logical_expression RPAREN block else
    (43) else -> ELSE . block
    (13) block -> . LBRACKET body RBRACKET

    IF              shift and go to state 191
    LBRACKET        shift and go to state 25

    block                          shift and go to state 192

state 184

    (46) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON . assignment RPAREN block
    (70) assignment -> . ID EQUALS expression
    (71) assignment -> . data_type ID EQUALS expression
    (72) assignment -> . CLASSOBJECT ID
    (92) data_type -> . primitive
    (93) data_type -> . data_structure
    (94) primitive -> . INT
    (95) primitive -> . FLOAT
    (96) primitive -> . BOOL
    (97) primitive -> . BYTE
    (98) primitive -> . CHAR
    (99) primitive -> . SBYTE
    (100) primitive -> . DECIMAL
    (101) primitive -> . DOUBLE
    (102) primitive -> . LONG
    (103) primitive -> . SHORT
    (104) primitive -> . UINT
    (65) data_structure -> . data_structure_list
    (66) data_structure -> . data_structure_array
    (67) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (68) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (69) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    ID              shift and go to state 136
    CLASSOBJECT     shift and go to state 138
    INT             shift and go to state 53
    FLOAT           shift and go to state 54
    BOOL            shift and go to state 55
    BYTE            shift and go to state 56
    CHAR            shift and go to state 57
    SBYTE           shift and go to state 58
    DECIMAL         shift and go to state 59
    DOUBLE          shift and go to state 60
    LONG            shift and go to state 61
    SHORT           shift and go to state 62
    UINT            shift and go to state 63
    LIST            shift and go to state 67

    assignment                     shift and go to state 193
    data_type                      shift and go to state 137
    primitive                      shift and go to state 48
    data_structure                 shift and go to state 49
    data_structure_list            shift and go to state 64
    data_structure_array           shift and go to state 65

state 185

    (67) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET . type RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE

    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71

    type                           shift and go to state 194

state 186

    (23) function -> modifier data_type ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 23 (function -> modifier data_type ID LPAREN declarations RPAREN block .)


state 187

    (75) declarations -> declaration COMMA declarations .

    RPAREN          reduce using rule 75 (declarations -> declaration COMMA declarations .)


state 188

    (24) function -> modifier VOID ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 24 (function -> modifier VOID ID LPAREN declarations RPAREN block .)


state 189

    (25) function -> modifier STATIC data_type ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 195

state 190

    (26) function -> modifier STATIC VOID ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 196

state 191

    (40) elseif -> ELSE IF . LPAREN logical_expression RPAREN block
    (41) elseif -> ELSE IF . LPAREN logical_expression RPAREN block elseif
    (42) elseif -> ELSE IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 197


state 192

    (43) else -> ELSE block .

    SEMICOLON       reduce using rule 43 (else -> ELSE block .)


state 193

    (46) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment . RPAREN block

    RPAREN          shift and go to state 198


state 194

    (67) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type . RSQBRACKET

    RSQBRACKET      shift and go to state 199


state 195

    (25) function -> modifier STATIC data_type ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 25 (function -> modifier STATIC data_type ID LPAREN declarations RPAREN block .)


state 196

    (26) function -> modifier STATIC VOID ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 26 (function -> modifier STATIC VOID ID LPAREN declarations RPAREN block .)


state 197

    (40) elseif -> ELSE IF LPAREN . logical_expression RPAREN block
    (41) elseif -> ELSE IF LPAREN . logical_expression RPAREN block elseif
    (42) elseif -> ELSE IF LPAREN . logical_expression RPAREN block else
    (48) logical_expression -> . logical_expression logical_operator logical_factor
    (49) logical_expression -> . logical_factor
    (50) logical_factor -> . TRUE
    (51) logical_factor -> . FALSE
    (52) logical_factor -> . ID
    (53) logical_factor -> . indexing
    (54) logical_factor -> . type
    (55) logical_factor -> . object_access
    (56) logical_factor -> . LPAREN logical_expression RPAREN
    (105) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (106) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 68
    DOUBLE_TYPE     shift and go to state 69
    DECIMAL_TYPE    shift and go to state 70
    INTEGER_TYPE    shift and go to state 71
    CLASSOBJECT     shift and go to state 87

    logical_expression             shift and go to state 200
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 198

    (46) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 201

state 199

    (67) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET .

    ID              reduce using rule 67 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET .)
    GREATER_THAN    reduce using rule 67 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET .)


state 200

    (40) elseif -> ELSE IF LPAREN logical_expression . RPAREN block
    (41) elseif -> ELSE IF LPAREN logical_expression . RPAREN block elseif
    (42) elseif -> ELSE IF LPAREN logical_expression . RPAREN block else
    (48) logical_expression -> logical_expression . logical_operator logical_factor
    (57) logical_operator -> . OR
    (58) logical_operator -> . AND
    (59) logical_operator -> . NOT
    (60) logical_operator -> . GREATER_THAN
    (61) logical_operator -> . LESS_THAN
    (62) logical_operator -> . GREATER_EQUALS_THAN
    (63) logical_operator -> . LESS_EQUALS_THAN
    (64) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 202
    OR              shift and go to state 151
    AND             shift and go to state 152
    NOT             shift and go to state 153
    GREATER_THAN    shift and go to state 154
    LESS_THAN       shift and go to state 155
    GREATER_EQUALS_THAN shift and go to state 156
    LESS_EQUALS_THAN shift and go to state 157
    EQUALITY        shift and go to state 158

    logical_operator               shift and go to state 150

state 201

    (46) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .

    SEMICOLON       reduce using rule 46 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)


state 202

    (40) elseif -> ELSE IF LPAREN logical_expression RPAREN . block
    (41) elseif -> ELSE IF LPAREN logical_expression RPAREN . block elseif
    (42) elseif -> ELSE IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 203

state 203

    (40) elseif -> ELSE IF LPAREN logical_expression RPAREN block .
    (41) elseif -> ELSE IF LPAREN logical_expression RPAREN block . elseif
    (42) elseif -> ELSE IF LPAREN logical_expression RPAREN block . else
    (40) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (41) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (42) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (43) else -> . ELSE block

    SEMICOLON       reduce using rule 40 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 183

    elseif                         shift and go to state 204
    else                           shift and go to state 205

state 204

    (41) elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .

    SEMICOLON       reduce using rule 41 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)


state 205

    (42) elseif -> ELSE IF LPAREN logical_expression RPAREN block else .

    SEMICOLON       reduce using rule 42 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)

