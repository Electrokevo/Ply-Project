Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    DIVIDE_EQUAL
    DO
    FILE
    IN
    MINUS_EQUAL
    MODULE
    MODULE_EQUAL
    NEW
    NINT
    NUINT
    PLUS_EQUAL
    STRING
    THEN
    TIMES_EQUAL
    ULONG
    USHORT
    VAR

Grammar

Rule 0     S' -> program
Rule 1     program -> usings namespace class
Rule 2     program -> namespace class
Rule 3     usings -> using usings
Rule 4     usings -> using
Rule 5     using -> USING CLASSOBJECT SEMICOLON
Rule 6     namespace -> NAMESPACE CLASSOBJECT SEMICOLON
Rule 7     class -> modifier CLASS CLASSOBJECT block
Rule 8     class -> modifier STATIC CLASS CLASSOBJECT block
Rule 9     object_access -> ID DOT ID
Rule 10    object_access -> CLASSOBJECT DOT CLASSOBJECT
Rule 11    object_access -> ID DOT CLASSOBJECT
Rule 12    object_access -> CLASSOBJECT DOT ID
Rule 13    block -> LBRACKET body RBRACKET
Rule 14    body -> lines SEMICOLON
Rule 15    body -> lines SEMICOLON body
Rule 16    body -> if
Rule 17    body -> loop
Rule 18    body -> function
Rule 19    lines -> assignment
Rule 20    lines -> expression
Rule 21    lines -> declaration
Rule 22    lines -> return
Rule 23    function -> modifier data_type ID LPAREN declarations RPAREN block
Rule 24    function -> modifier VOID ID LPAREN declarations RPAREN block
Rule 25    function -> modifier STATIC data_type ID LPAREN declarations RPAREN block
Rule 26    function -> modifier STATIC VOID ID LPAREN declarations RPAREN block
Rule 27    return -> RETURN ID
Rule 28    return -> RETURN type
Rule 29    lambda_function -> LPAREN ID RPAREN ARROW expression
Rule 30    lambda_function -> LPAREN ID RPAREN ARROW block
Rule 31    expression -> object_access LPAREN expression RPAREN
Rule 32    expression -> object_access LPAREN RPAREN
Rule 33    type -> FLOAT_TYPE
Rule 34    type -> DOUBLE_TYPE
Rule 35    type -> DECIMAL_TYPE
Rule 36    type -> INTEGER_TYPE
Rule 37    type -> MINUS FLOAT_TYPE
Rule 38    type -> MINUS DOUBLE_TYPE
Rule 39    type -> MINUS DECIMAL_TYPE
Rule 40    type -> MINUS INTEGER_TYPE
Rule 41    if -> IF LPAREN logical_expression RPAREN block
Rule 42    if -> IF LPAREN logical_expression RPAREN block body
Rule 43    if -> IF LPAREN logical_expression RPAREN block elseif
Rule 44    if -> IF LPAREN logical_expression RPAREN block else
Rule 45    elseif -> ELSE IF LPAREN logical_expression RPAREN block
Rule 46    elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif
Rule 47    elseif -> ELSE IF LPAREN logical_expression RPAREN block else
Rule 48    else -> ELSE block
Rule 49    else -> ELSE block body
Rule 50    loop -> while_loop
Rule 51    loop -> loop_for
Rule 52    loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
Rule 53    loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
Rule 54    while_loop -> WHILE LPAREN logical_expression RPAREN block
Rule 55    while_loop -> WHILE LPAREN logical_expression RPAREN block body
Rule 56    logical_expression -> logical_expression logical_operator logical_factor
Rule 57    logical_expression -> logical_factor
Rule 58    logical_factor -> TRUE
Rule 59    logical_factor -> FALSE
Rule 60    logical_factor -> ID
Rule 61    logical_factor -> indexing
Rule 62    logical_factor -> type
Rule 63    logical_factor -> object_access
Rule 64    logical_factor -> LPAREN logical_expression RPAREN
Rule 65    logical_operator -> OR
Rule 66    logical_operator -> AND
Rule 67    logical_operator -> NOT
Rule 68    logical_operator -> GREATER_THAN
Rule 69    logical_operator -> LESS_THAN
Rule 70    logical_operator -> GREATER_EQUALS_THAN
Rule 71    logical_operator -> LESS_EQUALS_THAN
Rule 72    logical_operator -> EQUALITY
Rule 73    data_structure -> data_structure_list
Rule 74    data_structure -> data_structure_array
Rule 75    data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
Rule 76    data_structure_array -> primitive LSQBRACKET RSQBRACKET
Rule 77    data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET
Rule 78    assignment -> ID EQUALS expression
Rule 79    assignment -> data_type ID EQUALS expression
Rule 80    assignment -> CLASSOBJECT ID
Rule 81    declarations -> declaration
Rule 82    declarations -> declaration COMMA
Rule 83    declarations -> declaration COMMA declarations
Rule 84    declaration -> data_type ID
Rule 85    expression -> expression PLUS term
Rule 86    expression -> expression MINUS term
Rule 87    expression -> term
Rule 88    term -> term TIMES factor
Rule 89    term -> term DIVIDE factor
Rule 90    term -> factor
Rule 91    factor -> type
Rule 92    factor -> LPAREN expression RPAREN
Rule 93    factor -> object_access
Rule 94    factor -> ID
Rule 95    factor -> indexing
Rule 96    modifier -> PUBLIC
Rule 97    modifier -> PRIVATE
Rule 98    modifier -> PROTECTED
Rule 99    modifier -> INTERNAL
Rule 100   data_type -> primitive
Rule 101   data_type -> data_structure
Rule 102   primitive -> INT
Rule 103   primitive -> FLOAT
Rule 104   primitive -> BOOL
Rule 105   primitive -> BYTE
Rule 106   primitive -> CHAR
Rule 107   primitive -> SBYTE
Rule 108   primitive -> DECIMAL
Rule 109   primitive -> DOUBLE
Rule 110   primitive -> LONG
Rule 111   primitive -> SHORT
Rule 112   primitive -> UINT
Rule 113   indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET
Rule 114   indexing -> ID LSQBRACKET ID RSQBRACKET

Terminals, with rules where they appear

AND                  : 66
ARROW                : 29 30
BOOL                 : 104
BYTE                 : 105
CHAR                 : 106
CHARACTER            : 
CLASS                : 7 8
CLASSOBJECT          : 5 6 7 8 10 10 11 12 77 80
COMMA                : 82 83
DECIMAL              : 108
DECIMAL_TYPE         : 35 39
DIVIDE               : 89
DIVIDE_EQUAL         : 
DO                   : 
DOT                  : 9 10 11 12
DOUBLE               : 109
DOUBLE_TYPE          : 34 38
ELSE                 : 45 46 47 48 49
EQUALITY             : 72
EQUALS               : 78 79
FALSE                : 59
FILE                 : 
FLOAT                : 103
FLOAT_TYPE           : 33 37
FOR                  : 52 53
GREATER_EQUALS_THAN  : 70
GREATER_THAN         : 68 75
ID                   : 9 9 11 12 23 24 25 26 27 29 30 60 75 78 79 80 84 94 113 114 114
IF                   : 41 42 43 44 45 46 47
IN                   : 
INT                  : 102
INTEGER_TYPE         : 36 40 113
INTERNAL             : 99
LBRACKET             : 13
LESS_EQUALS_THAN     : 71
LESS_THAN            : 69 75
LIST                 : 75
LONG                 : 110
LPAREN               : 23 24 25 26 29 30 31 32 41 42 43 44 45 46 47 52 53 54 55 64 92
LSQBRACKET           : 75 76 77 113 114
MINUS                : 37 38 39 40 86
MINUS_EQUAL          : 
MODULE               : 
MODULE_EQUAL         : 
NAMESPACE            : 6
NEW                  : 
NINT                 : 
NOT                  : 67
NUINT                : 
OR                   : 65
PLUS                 : 85
PLUS_EQUAL           : 
PRIVATE              : 97
PROTECTED            : 98
PUBLIC               : 96
RBRACKET             : 13
RETURN               : 27 28
RPAREN               : 23 24 25 26 29 30 31 32 41 42 43 44 45 46 47 52 53 54 55 64 92
RSQBRACKET           : 75 76 77 113 114
SBYTE                : 107
SEMICOLON            : 5 6 14 15 52 52 53 53
SHORT                : 111
STATIC               : 8 25 26
STRING               : 
THEN                 : 
TIMES                : 88
TIMES_EQUAL          : 
TRUE                 : 58
UINT                 : 112
ULONG                : 
USHORT               : 
USING                : 5
VAR                  : 
VOID                 : 24 26
WHILE                : 54 55
error                : 

Nonterminals, with rules where they appear

assignment           : 19 52 52 53 53
block                : 7 8 23 24 25 26 30 41 42 43 44 45 46 47 48 49 52 53 54 55
body                 : 13 15 42 49 53 55
class                : 1 2
data_structure       : 101
data_structure_array : 74
data_structure_list  : 73
data_type            : 23 25 75 79 84
declaration          : 21 81 82 83
declarations         : 23 24 25 26 83
else                 : 44 47
elseif               : 43 46
expression           : 20 29 31 78 79 85 86 92
factor               : 88 89 90
function             : 18
if                   : 16
indexing             : 61 95
lambda_function      : 
lines                : 14 15
logical_expression   : 41 42 43 44 45 46 47 52 53 54 55 56 64
logical_factor       : 56 57
logical_operator     : 56
loop                 : 17
loop_for             : 51
modifier             : 7 8 23 24 25 26
namespace            : 1 2
object_access        : 31 32 63 93
primitive            : 76 100
program              : 0
return               : 22
term                 : 85 86 87 88 89
type                 : 28 62 75 91
using                : 3 4
usings               : 1 3
while_loop           : 50

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . usings namespace class
    (2) program -> . namespace class
    (3) usings -> . using usings
    (4) usings -> . using
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5
    USING           shift and go to state 6

    program                        shift and go to state 1
    usings                         shift and go to state 2
    namespace                      shift and go to state 3
    using                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> usings . namespace class
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5

    namespace                      shift and go to state 7

state 3

    (2) program -> namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 8
    modifier                       shift and go to state 9

state 4

    (3) usings -> using . usings
    (4) usings -> using .
    (3) usings -> . using usings
    (4) usings -> . using
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       reduce using rule 4 (usings -> using .)
    USING           shift and go to state 6

    using                          shift and go to state 4
    usings                         shift and go to state 14

state 5

    (6) namespace -> NAMESPACE . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 15


state 6

    (5) using -> USING . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 16


state 7

    (1) program -> usings namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 17
    modifier                       shift and go to state 9

state 8

    (2) program -> namespace class .

    $end            reduce using rule 2 (program -> namespace class .)


state 9

    (7) class -> modifier . CLASS CLASSOBJECT block
    (8) class -> modifier . STATIC CLASS CLASSOBJECT block

    CLASS           shift and go to state 18
    STATIC          shift and go to state 19


state 10

    (96) modifier -> PUBLIC .

    CLASS           reduce using rule 96 (modifier -> PUBLIC .)
    STATIC          reduce using rule 96 (modifier -> PUBLIC .)
    VOID            reduce using rule 96 (modifier -> PUBLIC .)
    INT             reduce using rule 96 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 96 (modifier -> PUBLIC .)
    BOOL            reduce using rule 96 (modifier -> PUBLIC .)
    BYTE            reduce using rule 96 (modifier -> PUBLIC .)
    CHAR            reduce using rule 96 (modifier -> PUBLIC .)
    SBYTE           reduce using rule 96 (modifier -> PUBLIC .)
    DECIMAL         reduce using rule 96 (modifier -> PUBLIC .)
    DOUBLE          reduce using rule 96 (modifier -> PUBLIC .)
    LONG            reduce using rule 96 (modifier -> PUBLIC .)
    SHORT           reduce using rule 96 (modifier -> PUBLIC .)
    UINT            reduce using rule 96 (modifier -> PUBLIC .)
    LIST            reduce using rule 96 (modifier -> PUBLIC .)
    CLASSOBJECT     reduce using rule 96 (modifier -> PUBLIC .)


state 11

    (97) modifier -> PRIVATE .

    CLASS           reduce using rule 97 (modifier -> PRIVATE .)
    STATIC          reduce using rule 97 (modifier -> PRIVATE .)
    VOID            reduce using rule 97 (modifier -> PRIVATE .)
    INT             reduce using rule 97 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 97 (modifier -> PRIVATE .)
    BOOL            reduce using rule 97 (modifier -> PRIVATE .)
    BYTE            reduce using rule 97 (modifier -> PRIVATE .)
    CHAR            reduce using rule 97 (modifier -> PRIVATE .)
    SBYTE           reduce using rule 97 (modifier -> PRIVATE .)
    DECIMAL         reduce using rule 97 (modifier -> PRIVATE .)
    DOUBLE          reduce using rule 97 (modifier -> PRIVATE .)
    LONG            reduce using rule 97 (modifier -> PRIVATE .)
    SHORT           reduce using rule 97 (modifier -> PRIVATE .)
    UINT            reduce using rule 97 (modifier -> PRIVATE .)
    LIST            reduce using rule 97 (modifier -> PRIVATE .)
    CLASSOBJECT     reduce using rule 97 (modifier -> PRIVATE .)


state 12

    (98) modifier -> PROTECTED .

    CLASS           reduce using rule 98 (modifier -> PROTECTED .)
    STATIC          reduce using rule 98 (modifier -> PROTECTED .)
    VOID            reduce using rule 98 (modifier -> PROTECTED .)
    INT             reduce using rule 98 (modifier -> PROTECTED .)
    FLOAT           reduce using rule 98 (modifier -> PROTECTED .)
    BOOL            reduce using rule 98 (modifier -> PROTECTED .)
    BYTE            reduce using rule 98 (modifier -> PROTECTED .)
    CHAR            reduce using rule 98 (modifier -> PROTECTED .)
    SBYTE           reduce using rule 98 (modifier -> PROTECTED .)
    DECIMAL         reduce using rule 98 (modifier -> PROTECTED .)
    DOUBLE          reduce using rule 98 (modifier -> PROTECTED .)
    LONG            reduce using rule 98 (modifier -> PROTECTED .)
    SHORT           reduce using rule 98 (modifier -> PROTECTED .)
    UINT            reduce using rule 98 (modifier -> PROTECTED .)
    LIST            reduce using rule 98 (modifier -> PROTECTED .)
    CLASSOBJECT     reduce using rule 98 (modifier -> PROTECTED .)


state 13

    (99) modifier -> INTERNAL .

    CLASS           reduce using rule 99 (modifier -> INTERNAL .)
    STATIC          reduce using rule 99 (modifier -> INTERNAL .)
    VOID            reduce using rule 99 (modifier -> INTERNAL .)
    INT             reduce using rule 99 (modifier -> INTERNAL .)
    FLOAT           reduce using rule 99 (modifier -> INTERNAL .)
    BOOL            reduce using rule 99 (modifier -> INTERNAL .)
    BYTE            reduce using rule 99 (modifier -> INTERNAL .)
    CHAR            reduce using rule 99 (modifier -> INTERNAL .)
    SBYTE           reduce using rule 99 (modifier -> INTERNAL .)
    DECIMAL         reduce using rule 99 (modifier -> INTERNAL .)
    DOUBLE          reduce using rule 99 (modifier -> INTERNAL .)
    LONG            reduce using rule 99 (modifier -> INTERNAL .)
    SHORT           reduce using rule 99 (modifier -> INTERNAL .)
    UINT            reduce using rule 99 (modifier -> INTERNAL .)
    LIST            reduce using rule 99 (modifier -> INTERNAL .)
    CLASSOBJECT     reduce using rule 99 (modifier -> INTERNAL .)


state 14

    (3) usings -> using usings .

    NAMESPACE       reduce using rule 3 (usings -> using usings .)


state 15

    (6) namespace -> NAMESPACE CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 20


state 16

    (5) using -> USING CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 21


state 17

    (1) program -> usings namespace class .

    $end            reduce using rule 1 (program -> usings namespace class .)


state 18

    (7) class -> modifier CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 22


state 19

    (8) class -> modifier STATIC . CLASS CLASSOBJECT block

    CLASS           shift and go to state 23


state 20

    (6) namespace -> NAMESPACE CLASSOBJECT SEMICOLON .

    PUBLIC          reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PRIVATE         reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PROTECTED       reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    INTERNAL        reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)


state 21

    (5) using -> USING CLASSOBJECT SEMICOLON .

    USING           reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)
    NAMESPACE       reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)


state 22

    (7) class -> modifier CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 24

state 23

    (8) class -> modifier STATIC CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 26


state 24

    (7) class -> modifier CLASS CLASSOBJECT block .

    $end            reduce using rule 7 (class -> modifier CLASS CLASSOBJECT block .)


state 25

    (13) block -> LBRACKET . body RBRACKET
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (41) if -> . IF LPAREN logical_expression RPAREN block
    (42) if -> . IF LPAREN logical_expression RPAREN block body
    (43) if -> . IF LPAREN logical_expression RPAREN block elseif
    (44) if -> . IF LPAREN logical_expression RPAREN block else
    (50) loop -> . while_loop
    (51) loop -> . loop_for
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (84) declaration -> . data_type ID
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (54) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (55) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (52) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    IF              shift and go to state 36
    ID              shift and go to state 42
    CLASSOBJECT     shift and go to state 43
    RETURN          shift and go to state 47
    WHILE           shift and go to state 49
    FOR             shift and go to state 50
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LPAREN          shift and go to state 37
    LIST            shift and go to state 68
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    body                           shift and go to state 27
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    type                           shift and go to state 48
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    factor                         shift and go to state 53
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66
    indexing                       shift and go to state 67

state 26

    (8) class -> modifier STATIC CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 73

state 27

    (13) block -> LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 74


state 28

    (14) body -> lines . SEMICOLON
    (15) body -> lines . SEMICOLON body

    SEMICOLON       shift and go to state 75


state 29

    (16) body -> if .

    RBRACKET        reduce using rule 16 (body -> if .)


state 30

    (17) body -> loop .

    RBRACKET        reduce using rule 17 (body -> loop .)


state 31

    (18) body -> function .

    RBRACKET        reduce using rule 18 (body -> function .)


state 32

    (19) lines -> assignment .

    SEMICOLON       reduce using rule 19 (lines -> assignment .)


state 33

    (20) lines -> expression .
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 20 (lines -> expression .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77


state 34

    (21) lines -> declaration .

    SEMICOLON       reduce using rule 21 (lines -> declaration .)


state 35

    (22) lines -> return .

    SEMICOLON       reduce using rule 22 (lines -> return .)


state 36

    (41) if -> IF . LPAREN logical_expression RPAREN block
    (42) if -> IF . LPAREN logical_expression RPAREN block body
    (43) if -> IF . LPAREN logical_expression RPAREN block elseif
    (44) if -> IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 78


state 37

    (92) factor -> LPAREN . expression RPAREN
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 80
    CLASSOBJECT     shift and go to state 81
    LPAREN          shift and go to state 37
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    expression                     shift and go to state 79
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 53
    type                           shift and go to state 48
    indexing                       shift and go to state 67

state 38

    (50) loop -> while_loop .

    RBRACKET        reduce using rule 50 (loop -> while_loop .)


state 39

    (51) loop -> loop_for .

    RBRACKET        reduce using rule 51 (loop -> loop_for .)


state 40

    (23) function -> modifier . data_type ID LPAREN declarations RPAREN block
    (24) function -> modifier . VOID ID LPAREN declarations RPAREN block
    (25) function -> modifier . STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> modifier . STATIC VOID ID LPAREN declarations RPAREN block
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 83
    STATIC          shift and go to state 84
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    data_type                      shift and go to state 82
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 41

    (79) assignment -> data_type . ID EQUALS expression
    (84) declaration -> data_type . ID

    ID              shift and go to state 86


state 42

    (78) assignment -> ID . EQUALS expression
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (94) factor -> ID .
    (113) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> ID . LSQBRACKET ID RSQBRACKET

    EQUALS          shift and go to state 87
    DOT             shift and go to state 88
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)
    SEMICOLON       reduce using rule 94 (factor -> ID .)
    LSQBRACKET      shift and go to state 89


state 43

    (80) assignment -> CLASSOBJECT . ID
    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID
    (77) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    ID              shift and go to state 90
    DOT             shift and go to state 91
    LSQBRACKET      shift and go to state 92


state 44

    (31) expression -> object_access . LPAREN expression RPAREN
    (32) expression -> object_access . LPAREN RPAREN
    (93) factor -> object_access .

    LPAREN          shift and go to state 93
    TIMES           reduce using rule 93 (factor -> object_access .)
    DIVIDE          reduce using rule 93 (factor -> object_access .)
    PLUS            reduce using rule 93 (factor -> object_access .)
    MINUS           reduce using rule 93 (factor -> object_access .)
    SEMICOLON       reduce using rule 93 (factor -> object_access .)
    RPAREN          reduce using rule 93 (factor -> object_access .)


state 45

    (87) expression -> term .
    (88) term -> term . TIMES factor
    (89) term -> term . DIVIDE factor

    PLUS            reduce using rule 87 (expression -> term .)
    MINUS           reduce using rule 87 (expression -> term .)
    SEMICOLON       reduce using rule 87 (expression -> term .)
    RPAREN          reduce using rule 87 (expression -> term .)
    TIMES           shift and go to state 94
    DIVIDE          shift and go to state 95


state 46

    (37) type -> MINUS . FLOAT_TYPE
    (38) type -> MINUS . DOUBLE_TYPE
    (39) type -> MINUS . DECIMAL_TYPE
    (40) type -> MINUS . INTEGER_TYPE

    FLOAT_TYPE      shift and go to state 96
    DOUBLE_TYPE     shift and go to state 97
    DECIMAL_TYPE    shift and go to state 98
    INTEGER_TYPE    shift and go to state 99


state 47

    (27) return -> RETURN . ID
    (28) return -> RETURN . type
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE

    ID              shift and go to state 100
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    type                           shift and go to state 101

state 48

    (91) factor -> type .

    TIMES           reduce using rule 91 (factor -> type .)
    DIVIDE          reduce using rule 91 (factor -> type .)
    PLUS            reduce using rule 91 (factor -> type .)
    MINUS           reduce using rule 91 (factor -> type .)
    SEMICOLON       reduce using rule 91 (factor -> type .)
    RPAREN          reduce using rule 91 (factor -> type .)


state 49

    (54) while_loop -> WHILE . LPAREN logical_expression RPAREN block
    (55) while_loop -> WHILE . LPAREN logical_expression RPAREN block body

    LPAREN          shift and go to state 102


state 50

    (52) loop_for -> FOR . LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> FOR . LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body

    LPAREN          shift and go to state 103


state 51

    (100) data_type -> primitive .
    (76) data_structure_array -> primitive . LSQBRACKET RSQBRACKET

    ID              reduce using rule 100 (data_type -> primitive .)
    GREATER_THAN    reduce using rule 100 (data_type -> primitive .)
    LSQBRACKET      shift and go to state 104


state 52

    (101) data_type -> data_structure .

    ID              reduce using rule 101 (data_type -> data_structure .)
    GREATER_THAN    reduce using rule 101 (data_type -> data_structure .)


state 53

    (90) term -> factor .

    TIMES           reduce using rule 90 (term -> factor .)
    DIVIDE          reduce using rule 90 (term -> factor .)
    PLUS            reduce using rule 90 (term -> factor .)
    MINUS           reduce using rule 90 (term -> factor .)
    SEMICOLON       reduce using rule 90 (term -> factor .)
    RPAREN          reduce using rule 90 (term -> factor .)


state 54

    (102) primitive -> INT .

    LSQBRACKET      reduce using rule 102 (primitive -> INT .)
    ID              reduce using rule 102 (primitive -> INT .)
    GREATER_THAN    reduce using rule 102 (primitive -> INT .)


state 55

    (103) primitive -> FLOAT .

    LSQBRACKET      reduce using rule 103 (primitive -> FLOAT .)
    ID              reduce using rule 103 (primitive -> FLOAT .)
    GREATER_THAN    reduce using rule 103 (primitive -> FLOAT .)


state 56

    (104) primitive -> BOOL .

    LSQBRACKET      reduce using rule 104 (primitive -> BOOL .)
    ID              reduce using rule 104 (primitive -> BOOL .)
    GREATER_THAN    reduce using rule 104 (primitive -> BOOL .)


state 57

    (105) primitive -> BYTE .

    LSQBRACKET      reduce using rule 105 (primitive -> BYTE .)
    ID              reduce using rule 105 (primitive -> BYTE .)
    GREATER_THAN    reduce using rule 105 (primitive -> BYTE .)


state 58

    (106) primitive -> CHAR .

    LSQBRACKET      reduce using rule 106 (primitive -> CHAR .)
    ID              reduce using rule 106 (primitive -> CHAR .)
    GREATER_THAN    reduce using rule 106 (primitive -> CHAR .)


state 59

    (107) primitive -> SBYTE .

    LSQBRACKET      reduce using rule 107 (primitive -> SBYTE .)
    ID              reduce using rule 107 (primitive -> SBYTE .)
    GREATER_THAN    reduce using rule 107 (primitive -> SBYTE .)


state 60

    (108) primitive -> DECIMAL .

    LSQBRACKET      reduce using rule 108 (primitive -> DECIMAL .)
    ID              reduce using rule 108 (primitive -> DECIMAL .)
    GREATER_THAN    reduce using rule 108 (primitive -> DECIMAL .)


state 61

    (109) primitive -> DOUBLE .

    LSQBRACKET      reduce using rule 109 (primitive -> DOUBLE .)
    ID              reduce using rule 109 (primitive -> DOUBLE .)
    GREATER_THAN    reduce using rule 109 (primitive -> DOUBLE .)


state 62

    (110) primitive -> LONG .

    LSQBRACKET      reduce using rule 110 (primitive -> LONG .)
    ID              reduce using rule 110 (primitive -> LONG .)
    GREATER_THAN    reduce using rule 110 (primitive -> LONG .)


state 63

    (111) primitive -> SHORT .

    LSQBRACKET      reduce using rule 111 (primitive -> SHORT .)
    ID              reduce using rule 111 (primitive -> SHORT .)
    GREATER_THAN    reduce using rule 111 (primitive -> SHORT .)


state 64

    (112) primitive -> UINT .

    LSQBRACKET      reduce using rule 112 (primitive -> UINT .)
    ID              reduce using rule 112 (primitive -> UINT .)
    GREATER_THAN    reduce using rule 112 (primitive -> UINT .)


state 65

    (73) data_structure -> data_structure_list .

    ID              reduce using rule 73 (data_structure -> data_structure_list .)
    GREATER_THAN    reduce using rule 73 (data_structure -> data_structure_list .)


state 66

    (74) data_structure -> data_structure_array .

    ID              reduce using rule 74 (data_structure -> data_structure_array .)
    GREATER_THAN    reduce using rule 74 (data_structure -> data_structure_array .)


state 67

    (95) factor -> indexing .

    TIMES           reduce using rule 95 (factor -> indexing .)
    DIVIDE          reduce using rule 95 (factor -> indexing .)
    PLUS            reduce using rule 95 (factor -> indexing .)
    MINUS           reduce using rule 95 (factor -> indexing .)
    SEMICOLON       reduce using rule 95 (factor -> indexing .)
    RPAREN          reduce using rule 95 (factor -> indexing .)


state 68

    (75) data_structure_list -> LIST . LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET

    LESS_THAN       shift and go to state 105


state 69

    (33) type -> FLOAT_TYPE .

    TIMES           reduce using rule 33 (type -> FLOAT_TYPE .)
    DIVIDE          reduce using rule 33 (type -> FLOAT_TYPE .)
    PLUS            reduce using rule 33 (type -> FLOAT_TYPE .)
    MINUS           reduce using rule 33 (type -> FLOAT_TYPE .)
    SEMICOLON       reduce using rule 33 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 33 (type -> FLOAT_TYPE .)
    OR              reduce using rule 33 (type -> FLOAT_TYPE .)
    AND             reduce using rule 33 (type -> FLOAT_TYPE .)
    NOT             reduce using rule 33 (type -> FLOAT_TYPE .)
    GREATER_THAN    reduce using rule 33 (type -> FLOAT_TYPE .)
    LESS_THAN       reduce using rule 33 (type -> FLOAT_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 33 (type -> FLOAT_TYPE .)
    LESS_EQUALS_THAN reduce using rule 33 (type -> FLOAT_TYPE .)
    EQUALITY        reduce using rule 33 (type -> FLOAT_TYPE .)
    RSQBRACKET      reduce using rule 33 (type -> FLOAT_TYPE .)


state 70

    (34) type -> DOUBLE_TYPE .

    TIMES           reduce using rule 34 (type -> DOUBLE_TYPE .)
    DIVIDE          reduce using rule 34 (type -> DOUBLE_TYPE .)
    PLUS            reduce using rule 34 (type -> DOUBLE_TYPE .)
    MINUS           reduce using rule 34 (type -> DOUBLE_TYPE .)
    SEMICOLON       reduce using rule 34 (type -> DOUBLE_TYPE .)
    RPAREN          reduce using rule 34 (type -> DOUBLE_TYPE .)
    OR              reduce using rule 34 (type -> DOUBLE_TYPE .)
    AND             reduce using rule 34 (type -> DOUBLE_TYPE .)
    NOT             reduce using rule 34 (type -> DOUBLE_TYPE .)
    GREATER_THAN    reduce using rule 34 (type -> DOUBLE_TYPE .)
    LESS_THAN       reduce using rule 34 (type -> DOUBLE_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 34 (type -> DOUBLE_TYPE .)
    LESS_EQUALS_THAN reduce using rule 34 (type -> DOUBLE_TYPE .)
    EQUALITY        reduce using rule 34 (type -> DOUBLE_TYPE .)
    RSQBRACKET      reduce using rule 34 (type -> DOUBLE_TYPE .)


state 71

    (35) type -> DECIMAL_TYPE .

    TIMES           reduce using rule 35 (type -> DECIMAL_TYPE .)
    DIVIDE          reduce using rule 35 (type -> DECIMAL_TYPE .)
    PLUS            reduce using rule 35 (type -> DECIMAL_TYPE .)
    MINUS           reduce using rule 35 (type -> DECIMAL_TYPE .)
    SEMICOLON       reduce using rule 35 (type -> DECIMAL_TYPE .)
    RPAREN          reduce using rule 35 (type -> DECIMAL_TYPE .)
    OR              reduce using rule 35 (type -> DECIMAL_TYPE .)
    AND             reduce using rule 35 (type -> DECIMAL_TYPE .)
    NOT             reduce using rule 35 (type -> DECIMAL_TYPE .)
    GREATER_THAN    reduce using rule 35 (type -> DECIMAL_TYPE .)
    LESS_THAN       reduce using rule 35 (type -> DECIMAL_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 35 (type -> DECIMAL_TYPE .)
    LESS_EQUALS_THAN reduce using rule 35 (type -> DECIMAL_TYPE .)
    EQUALITY        reduce using rule 35 (type -> DECIMAL_TYPE .)
    RSQBRACKET      reduce using rule 35 (type -> DECIMAL_TYPE .)


state 72

    (36) type -> INTEGER_TYPE .

    TIMES           reduce using rule 36 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 36 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 36 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 36 (type -> INTEGER_TYPE .)
    SEMICOLON       reduce using rule 36 (type -> INTEGER_TYPE .)
    RPAREN          reduce using rule 36 (type -> INTEGER_TYPE .)
    OR              reduce using rule 36 (type -> INTEGER_TYPE .)
    AND             reduce using rule 36 (type -> INTEGER_TYPE .)
    NOT             reduce using rule 36 (type -> INTEGER_TYPE .)
    GREATER_THAN    reduce using rule 36 (type -> INTEGER_TYPE .)
    LESS_THAN       reduce using rule 36 (type -> INTEGER_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 36 (type -> INTEGER_TYPE .)
    LESS_EQUALS_THAN reduce using rule 36 (type -> INTEGER_TYPE .)
    EQUALITY        reduce using rule 36 (type -> INTEGER_TYPE .)
    RSQBRACKET      reduce using rule 36 (type -> INTEGER_TYPE .)


state 73

    (8) class -> modifier STATIC CLASS CLASSOBJECT block .

    $end            reduce using rule 8 (class -> modifier STATIC CLASS CLASSOBJECT block .)


state 74

    (13) block -> LBRACKET body RBRACKET .

    $end            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    ELSE            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    IF              reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    ID              reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    CLASSOBJECT     reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    RETURN          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    WHILE           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    FOR             reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    PUBLIC          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    PRIVATE         reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    PROTECTED       reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    INTERNAL        reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    INT             reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    FLOAT           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    BOOL            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    BYTE            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    CHAR            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    SBYTE           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DECIMAL         reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DOUBLE          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LONG            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    SHORT           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    UINT            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LPAREN          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LIST            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    FLOAT_TYPE      reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DOUBLE_TYPE     reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DECIMAL_TYPE    reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    INTEGER_TYPE    reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    MINUS           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 13 (block -> LBRACKET body RBRACKET .)


state 75

    (14) body -> lines SEMICOLON .
    (15) body -> lines SEMICOLON . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (41) if -> . IF LPAREN logical_expression RPAREN block
    (42) if -> . IF LPAREN logical_expression RPAREN block body
    (43) if -> . IF LPAREN logical_expression RPAREN block elseif
    (44) if -> . IF LPAREN logical_expression RPAREN block else
    (50) loop -> . while_loop
    (51) loop -> . loop_for
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (84) declaration -> . data_type ID
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (54) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (55) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (52) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 14 (body -> lines SEMICOLON .)
    IF              shift and go to state 36
    ID              shift and go to state 42
    CLASSOBJECT     shift and go to state 43
    RETURN          shift and go to state 47
    WHILE           shift and go to state 49
    FOR             shift and go to state 50
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LPAREN          shift and go to state 37
    LIST            shift and go to state 68
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    lines                          shift and go to state 28
    body                           shift and go to state 106
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    type                           shift and go to state 48
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    factor                         shift and go to state 53
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66
    indexing                       shift and go to state 67

state 76

    (85) expression -> expression PLUS . term
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 37
    ID              shift and go to state 109
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    term                           shift and go to state 107
    factor                         shift and go to state 53
    type                           shift and go to state 48
    object_access                  shift and go to state 108
    indexing                       shift and go to state 67

state 77

    (86) expression -> expression MINUS . term
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 37
    ID              shift and go to state 109
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    term                           shift and go to state 110
    factor                         shift and go to state 53
    type                           shift and go to state 48
    object_access                  shift and go to state 108
    indexing                       shift and go to state 67

state 78

    (41) if -> IF LPAREN . logical_expression RPAREN block
    (42) if -> IF LPAREN . logical_expression RPAREN block body
    (43) if -> IF LPAREN . logical_expression RPAREN block elseif
    (44) if -> IF LPAREN . logical_expression RPAREN block else
    (56) logical_expression -> . logical_expression logical_operator logical_factor
    (57) logical_expression -> . logical_factor
    (58) logical_factor -> . TRUE
    (59) logical_factor -> . FALSE
    (60) logical_factor -> . ID
    (61) logical_factor -> . indexing
    (62) logical_factor -> . type
    (63) logical_factor -> . object_access
    (64) logical_factor -> . LPAREN logical_expression RPAREN
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 116
    LPAREN          shift and go to state 111
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    logical_expression             shift and go to state 112
    logical_factor                 shift and go to state 113
    indexing                       shift and go to state 117
    type                           shift and go to state 118
    object_access                  shift and go to state 119

state 79

    (92) factor -> LPAREN expression . RPAREN
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RPAREN          shift and go to state 120
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77


state 80

    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (94) factor -> ID .
    (113) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> ID . LSQBRACKET ID RSQBRACKET

    DOT             shift and go to state 88
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    RPAREN          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)
    SEMICOLON       reduce using rule 94 (factor -> ID .)
    LSQBRACKET      shift and go to state 89


state 81

    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID

    DOT             shift and go to state 91


state 82

    (23) function -> modifier data_type . ID LPAREN declarations RPAREN block

    ID              shift and go to state 121


state 83

    (24) function -> modifier VOID . ID LPAREN declarations RPAREN block

    ID              shift and go to state 122


state 84

    (25) function -> modifier STATIC . data_type ID LPAREN declarations RPAREN block
    (26) function -> modifier STATIC . VOID ID LPAREN declarations RPAREN block
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 124
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    data_type                      shift and go to state 123
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 85

    (77) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    LSQBRACKET      shift and go to state 92


state 86

    (79) assignment -> data_type ID . EQUALS expression
    (84) declaration -> data_type ID .

    EQUALS          shift and go to state 125
    SEMICOLON       reduce using rule 84 (declaration -> data_type ID .)


state 87

    (78) assignment -> ID EQUALS . expression
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 80
    CLASSOBJECT     shift and go to state 81
    LPAREN          shift and go to state 37
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    expression                     shift and go to state 126
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 53
    type                           shift and go to state 48
    indexing                       shift and go to state 67

state 88

    (9) object_access -> ID DOT . ID
    (11) object_access -> ID DOT . CLASSOBJECT

    ID              shift and go to state 127
    CLASSOBJECT     shift and go to state 128


state 89

    (113) indexing -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (114) indexing -> ID LSQBRACKET . ID RSQBRACKET

    INTEGER_TYPE    shift and go to state 130
    ID              shift and go to state 129


state 90

    (80) assignment -> CLASSOBJECT ID .

    SEMICOLON       reduce using rule 80 (assignment -> CLASSOBJECT ID .)
    RPAREN          reduce using rule 80 (assignment -> CLASSOBJECT ID .)


state 91

    (10) object_access -> CLASSOBJECT DOT . CLASSOBJECT
    (12) object_access -> CLASSOBJECT DOT . ID

    CLASSOBJECT     shift and go to state 131
    ID              shift and go to state 132


state 92

    (77) data_structure_array -> CLASSOBJECT LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 133


state 93

    (31) expression -> object_access LPAREN . expression RPAREN
    (32) expression -> object_access LPAREN . RPAREN
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RPAREN          shift and go to state 135
    ID              shift and go to state 80
    CLASSOBJECT     shift and go to state 81
    LPAREN          shift and go to state 37
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    object_access                  shift and go to state 44
    expression                     shift and go to state 134
    term                           shift and go to state 45
    factor                         shift and go to state 53
    type                           shift and go to state 48
    indexing                       shift and go to state 67

state 94

    (88) term -> term TIMES . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 37
    ID              shift and go to state 109
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    factor                         shift and go to state 136
    type                           shift and go to state 48
    object_access                  shift and go to state 108
    indexing                       shift and go to state 67

state 95

    (89) term -> term DIVIDE . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 37
    ID              shift and go to state 109
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    factor                         shift and go to state 137
    type                           shift and go to state 48
    object_access                  shift and go to state 108
    indexing                       shift and go to state 67

state 96

    (37) type -> MINUS FLOAT_TYPE .

    TIMES           reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    DIVIDE          reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    PLUS            reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    MINUS           reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    SEMICOLON       reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    RPAREN          reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    OR              reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    AND             reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    NOT             reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    GREATER_THAN    reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    LESS_THAN       reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    LESS_EQUALS_THAN reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    EQUALITY        reduce using rule 37 (type -> MINUS FLOAT_TYPE .)
    RSQBRACKET      reduce using rule 37 (type -> MINUS FLOAT_TYPE .)


state 97

    (38) type -> MINUS DOUBLE_TYPE .

    TIMES           reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    DIVIDE          reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    PLUS            reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    MINUS           reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    SEMICOLON       reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    RPAREN          reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    OR              reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    AND             reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    NOT             reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    GREATER_THAN    reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    LESS_THAN       reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    LESS_EQUALS_THAN reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    EQUALITY        reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)
    RSQBRACKET      reduce using rule 38 (type -> MINUS DOUBLE_TYPE .)


state 98

    (39) type -> MINUS DECIMAL_TYPE .

    TIMES           reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    DIVIDE          reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    PLUS            reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    MINUS           reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    SEMICOLON       reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    RPAREN          reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    OR              reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    AND             reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    NOT             reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    GREATER_THAN    reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    LESS_THAN       reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    LESS_EQUALS_THAN reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    EQUALITY        reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)
    RSQBRACKET      reduce using rule 39 (type -> MINUS DECIMAL_TYPE .)


state 99

    (40) type -> MINUS INTEGER_TYPE .

    TIMES           reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    DIVIDE          reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    PLUS            reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    MINUS           reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    SEMICOLON       reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    RPAREN          reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    OR              reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    AND             reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    NOT             reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    GREATER_THAN    reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    LESS_THAN       reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    LESS_EQUALS_THAN reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    EQUALITY        reduce using rule 40 (type -> MINUS INTEGER_TYPE .)
    RSQBRACKET      reduce using rule 40 (type -> MINUS INTEGER_TYPE .)


state 100

    (27) return -> RETURN ID .

    SEMICOLON       reduce using rule 27 (return -> RETURN ID .)


state 101

    (28) return -> RETURN type .

    SEMICOLON       reduce using rule 28 (return -> RETURN type .)


state 102

    (54) while_loop -> WHILE LPAREN . logical_expression RPAREN block
    (55) while_loop -> WHILE LPAREN . logical_expression RPAREN block body
    (56) logical_expression -> . logical_expression logical_operator logical_factor
    (57) logical_expression -> . logical_factor
    (58) logical_factor -> . TRUE
    (59) logical_factor -> . FALSE
    (60) logical_factor -> . ID
    (61) logical_factor -> . indexing
    (62) logical_factor -> . type
    (63) logical_factor -> . object_access
    (64) logical_factor -> . LPAREN logical_expression RPAREN
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 116
    LPAREN          shift and go to state 111
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    logical_expression             shift and go to state 138
    logical_factor                 shift and go to state 113
    indexing                       shift and go to state 117
    type                           shift and go to state 118
    object_access                  shift and go to state 119

state 103

    (52) loop_for -> FOR LPAREN . assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> FOR LPAREN . assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    ID              shift and go to state 140
    CLASSOBJECT     shift and go to state 142
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68

    assignment                     shift and go to state 139
    data_type                      shift and go to state 141
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 104

    (76) data_structure_array -> primitive LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 143


state 105

    (75) data_structure_list -> LIST LESS_THAN . data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    data_type                      shift and go to state 144
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 106

    (15) body -> lines SEMICOLON body .

    RBRACKET        reduce using rule 15 (body -> lines SEMICOLON body .)


state 107

    (85) expression -> expression PLUS term .
    (88) term -> term . TIMES factor
    (89) term -> term . DIVIDE factor

    PLUS            reduce using rule 85 (expression -> expression PLUS term .)
    MINUS           reduce using rule 85 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 85 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 85 (expression -> expression PLUS term .)
    TIMES           shift and go to state 94
    DIVIDE          shift and go to state 95


state 108

    (93) factor -> object_access .

    TIMES           reduce using rule 93 (factor -> object_access .)
    DIVIDE          reduce using rule 93 (factor -> object_access .)
    PLUS            reduce using rule 93 (factor -> object_access .)
    MINUS           reduce using rule 93 (factor -> object_access .)
    SEMICOLON       reduce using rule 93 (factor -> object_access .)
    RPAREN          reduce using rule 93 (factor -> object_access .)


state 109

    (94) factor -> ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (113) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> ID . LSQBRACKET ID RSQBRACKET

    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)
    SEMICOLON       reduce using rule 94 (factor -> ID .)
    RPAREN          reduce using rule 94 (factor -> ID .)
    DOT             shift and go to state 88
    LSQBRACKET      shift and go to state 89


state 110

    (86) expression -> expression MINUS term .
    (88) term -> term . TIMES factor
    (89) term -> term . DIVIDE factor

    PLUS            reduce using rule 86 (expression -> expression MINUS term .)
    MINUS           reduce using rule 86 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 86 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 86 (expression -> expression MINUS term .)
    TIMES           shift and go to state 94
    DIVIDE          shift and go to state 95


state 111

    (64) logical_factor -> LPAREN . logical_expression RPAREN
    (56) logical_expression -> . logical_expression logical_operator logical_factor
    (57) logical_expression -> . logical_factor
    (58) logical_factor -> . TRUE
    (59) logical_factor -> . FALSE
    (60) logical_factor -> . ID
    (61) logical_factor -> . indexing
    (62) logical_factor -> . type
    (63) logical_factor -> . object_access
    (64) logical_factor -> . LPAREN logical_expression RPAREN
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 116
    LPAREN          shift and go to state 111
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    logical_expression             shift and go to state 145
    logical_factor                 shift and go to state 113
    indexing                       shift and go to state 117
    type                           shift and go to state 118
    object_access                  shift and go to state 119

state 112

    (41) if -> IF LPAREN logical_expression . RPAREN block
    (42) if -> IF LPAREN logical_expression . RPAREN block body
    (43) if -> IF LPAREN logical_expression . RPAREN block elseif
    (44) if -> IF LPAREN logical_expression . RPAREN block else
    (56) logical_expression -> logical_expression . logical_operator logical_factor
    (65) logical_operator -> . OR
    (66) logical_operator -> . AND
    (67) logical_operator -> . NOT
    (68) logical_operator -> . GREATER_THAN
    (69) logical_operator -> . LESS_THAN
    (70) logical_operator -> . GREATER_EQUALS_THAN
    (71) logical_operator -> . LESS_EQUALS_THAN
    (72) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 146
    OR              shift and go to state 148
    AND             shift and go to state 149
    NOT             shift and go to state 150
    GREATER_THAN    shift and go to state 151
    LESS_THAN       shift and go to state 152
    GREATER_EQUALS_THAN shift and go to state 153
    LESS_EQUALS_THAN shift and go to state 154
    EQUALITY        shift and go to state 155

    logical_operator               shift and go to state 147

state 113

    (57) logical_expression -> logical_factor .

    RPAREN          reduce using rule 57 (logical_expression -> logical_factor .)
    OR              reduce using rule 57 (logical_expression -> logical_factor .)
    AND             reduce using rule 57 (logical_expression -> logical_factor .)
    NOT             reduce using rule 57 (logical_expression -> logical_factor .)
    GREATER_THAN    reduce using rule 57 (logical_expression -> logical_factor .)
    LESS_THAN       reduce using rule 57 (logical_expression -> logical_factor .)
    GREATER_EQUALS_THAN reduce using rule 57 (logical_expression -> logical_factor .)
    LESS_EQUALS_THAN reduce using rule 57 (logical_expression -> logical_factor .)
    EQUALITY        reduce using rule 57 (logical_expression -> logical_factor .)
    SEMICOLON       reduce using rule 57 (logical_expression -> logical_factor .)


state 114

    (58) logical_factor -> TRUE .

    RPAREN          reduce using rule 58 (logical_factor -> TRUE .)
    OR              reduce using rule 58 (logical_factor -> TRUE .)
    AND             reduce using rule 58 (logical_factor -> TRUE .)
    NOT             reduce using rule 58 (logical_factor -> TRUE .)
    GREATER_THAN    reduce using rule 58 (logical_factor -> TRUE .)
    LESS_THAN       reduce using rule 58 (logical_factor -> TRUE .)
    GREATER_EQUALS_THAN reduce using rule 58 (logical_factor -> TRUE .)
    LESS_EQUALS_THAN reduce using rule 58 (logical_factor -> TRUE .)
    EQUALITY        reduce using rule 58 (logical_factor -> TRUE .)
    SEMICOLON       reduce using rule 58 (logical_factor -> TRUE .)


state 115

    (59) logical_factor -> FALSE .

    RPAREN          reduce using rule 59 (logical_factor -> FALSE .)
    OR              reduce using rule 59 (logical_factor -> FALSE .)
    AND             reduce using rule 59 (logical_factor -> FALSE .)
    NOT             reduce using rule 59 (logical_factor -> FALSE .)
    GREATER_THAN    reduce using rule 59 (logical_factor -> FALSE .)
    LESS_THAN       reduce using rule 59 (logical_factor -> FALSE .)
    GREATER_EQUALS_THAN reduce using rule 59 (logical_factor -> FALSE .)
    LESS_EQUALS_THAN reduce using rule 59 (logical_factor -> FALSE .)
    EQUALITY        reduce using rule 59 (logical_factor -> FALSE .)
    SEMICOLON       reduce using rule 59 (logical_factor -> FALSE .)


state 116

    (60) logical_factor -> ID .
    (113) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT

    RPAREN          reduce using rule 60 (logical_factor -> ID .)
    OR              reduce using rule 60 (logical_factor -> ID .)
    AND             reduce using rule 60 (logical_factor -> ID .)
    NOT             reduce using rule 60 (logical_factor -> ID .)
    GREATER_THAN    reduce using rule 60 (logical_factor -> ID .)
    LESS_THAN       reduce using rule 60 (logical_factor -> ID .)
    GREATER_EQUALS_THAN reduce using rule 60 (logical_factor -> ID .)
    LESS_EQUALS_THAN reduce using rule 60 (logical_factor -> ID .)
    EQUALITY        reduce using rule 60 (logical_factor -> ID .)
    SEMICOLON       reduce using rule 60 (logical_factor -> ID .)
    LSQBRACKET      shift and go to state 89
    DOT             shift and go to state 88


state 117

    (61) logical_factor -> indexing .

    RPAREN          reduce using rule 61 (logical_factor -> indexing .)
    OR              reduce using rule 61 (logical_factor -> indexing .)
    AND             reduce using rule 61 (logical_factor -> indexing .)
    NOT             reduce using rule 61 (logical_factor -> indexing .)
    GREATER_THAN    reduce using rule 61 (logical_factor -> indexing .)
    LESS_THAN       reduce using rule 61 (logical_factor -> indexing .)
    GREATER_EQUALS_THAN reduce using rule 61 (logical_factor -> indexing .)
    LESS_EQUALS_THAN reduce using rule 61 (logical_factor -> indexing .)
    EQUALITY        reduce using rule 61 (logical_factor -> indexing .)
    SEMICOLON       reduce using rule 61 (logical_factor -> indexing .)


state 118

    (62) logical_factor -> type .

    RPAREN          reduce using rule 62 (logical_factor -> type .)
    OR              reduce using rule 62 (logical_factor -> type .)
    AND             reduce using rule 62 (logical_factor -> type .)
    NOT             reduce using rule 62 (logical_factor -> type .)
    GREATER_THAN    reduce using rule 62 (logical_factor -> type .)
    LESS_THAN       reduce using rule 62 (logical_factor -> type .)
    GREATER_EQUALS_THAN reduce using rule 62 (logical_factor -> type .)
    LESS_EQUALS_THAN reduce using rule 62 (logical_factor -> type .)
    EQUALITY        reduce using rule 62 (logical_factor -> type .)
    SEMICOLON       reduce using rule 62 (logical_factor -> type .)


state 119

    (63) logical_factor -> object_access .

    RPAREN          reduce using rule 63 (logical_factor -> object_access .)
    OR              reduce using rule 63 (logical_factor -> object_access .)
    AND             reduce using rule 63 (logical_factor -> object_access .)
    NOT             reduce using rule 63 (logical_factor -> object_access .)
    GREATER_THAN    reduce using rule 63 (logical_factor -> object_access .)
    LESS_THAN       reduce using rule 63 (logical_factor -> object_access .)
    GREATER_EQUALS_THAN reduce using rule 63 (logical_factor -> object_access .)
    LESS_EQUALS_THAN reduce using rule 63 (logical_factor -> object_access .)
    EQUALITY        reduce using rule 63 (logical_factor -> object_access .)
    SEMICOLON       reduce using rule 63 (logical_factor -> object_access .)


state 120

    (92) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 92 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 92 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 92 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 92 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 92 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 92 (factor -> LPAREN expression RPAREN .)


state 121

    (23) function -> modifier data_type ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 156


state 122

    (24) function -> modifier VOID ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 157


state 123

    (25) function -> modifier STATIC data_type . ID LPAREN declarations RPAREN block

    ID              shift and go to state 158


state 124

    (26) function -> modifier STATIC VOID . ID LPAREN declarations RPAREN block

    ID              shift and go to state 159


state 125

    (79) assignment -> data_type ID EQUALS . expression
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 80
    CLASSOBJECT     shift and go to state 81
    LPAREN          shift and go to state 37
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    expression                     shift and go to state 160
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    factor                         shift and go to state 53
    type                           shift and go to state 48
    indexing                       shift and go to state 67

state 126

    (78) assignment -> ID EQUALS expression .
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 78 (assignment -> ID EQUALS expression .)
    RPAREN          reduce using rule 78 (assignment -> ID EQUALS expression .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77


state 127

    (9) object_access -> ID DOT ID .

    LPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    TIMES           reduce using rule 9 (object_access -> ID DOT ID .)
    DIVIDE          reduce using rule 9 (object_access -> ID DOT ID .)
    PLUS            reduce using rule 9 (object_access -> ID DOT ID .)
    MINUS           reduce using rule 9 (object_access -> ID DOT ID .)
    SEMICOLON       reduce using rule 9 (object_access -> ID DOT ID .)
    RPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    OR              reduce using rule 9 (object_access -> ID DOT ID .)
    AND             reduce using rule 9 (object_access -> ID DOT ID .)
    NOT             reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_THAN    reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_THAN       reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    EQUALITY        reduce using rule 9 (object_access -> ID DOT ID .)


state 128

    (11) object_access -> ID DOT CLASSOBJECT .

    LPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    TIMES           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    PLUS            reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    MINUS           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    RPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    OR              reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    AND             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    NOT             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)


state 129

    (114) indexing -> ID LSQBRACKET ID . RSQBRACKET

    RSQBRACKET      shift and go to state 161


state 130

    (113) indexing -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET

    RSQBRACKET      shift and go to state 162


state 131

    (10) object_access -> CLASSOBJECT DOT CLASSOBJECT .

    LPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    TIMES           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    PLUS            reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    MINUS           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    RPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    OR              reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    AND             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    NOT             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)


state 132

    (12) object_access -> CLASSOBJECT DOT ID .

    LPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    TIMES           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    DIVIDE          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    PLUS            reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    MINUS           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    SEMICOLON       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    RPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    OR              reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    AND             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    NOT             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_THAN    reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_THAN       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    EQUALITY        reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)


state 133

    (77) data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .

    ID              reduce using rule 77 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)
    GREATER_THAN    reduce using rule 77 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)


state 134

    (31) expression -> object_access LPAREN expression . RPAREN
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    RPAREN          shift and go to state 163
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77


state 135

    (32) expression -> object_access LPAREN RPAREN .

    PLUS            reduce using rule 32 (expression -> object_access LPAREN RPAREN .)
    MINUS           reduce using rule 32 (expression -> object_access LPAREN RPAREN .)
    SEMICOLON       reduce using rule 32 (expression -> object_access LPAREN RPAREN .)
    RPAREN          reduce using rule 32 (expression -> object_access LPAREN RPAREN .)


state 136

    (88) term -> term TIMES factor .

    TIMES           reduce using rule 88 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 88 (term -> term TIMES factor .)
    PLUS            reduce using rule 88 (term -> term TIMES factor .)
    MINUS           reduce using rule 88 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 88 (term -> term TIMES factor .)
    RPAREN          reduce using rule 88 (term -> term TIMES factor .)


state 137

    (89) term -> term DIVIDE factor .

    TIMES           reduce using rule 89 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 89 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 89 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 89 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 89 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 89 (term -> term DIVIDE factor .)


state 138

    (54) while_loop -> WHILE LPAREN logical_expression . RPAREN block
    (55) while_loop -> WHILE LPAREN logical_expression . RPAREN block body
    (56) logical_expression -> logical_expression . logical_operator logical_factor
    (65) logical_operator -> . OR
    (66) logical_operator -> . AND
    (67) logical_operator -> . NOT
    (68) logical_operator -> . GREATER_THAN
    (69) logical_operator -> . LESS_THAN
    (70) logical_operator -> . GREATER_EQUALS_THAN
    (71) logical_operator -> . LESS_EQUALS_THAN
    (72) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 164
    OR              shift and go to state 148
    AND             shift and go to state 149
    NOT             shift and go to state 150
    GREATER_THAN    shift and go to state 151
    LESS_THAN       shift and go to state 152
    GREATER_EQUALS_THAN shift and go to state 153
    LESS_EQUALS_THAN shift and go to state 154
    EQUALITY        shift and go to state 155

    logical_operator               shift and go to state 147

state 139

    (52) loop_for -> FOR LPAREN assignment . SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> FOR LPAREN assignment . SEMICOLON logical_expression SEMICOLON assignment RPAREN block body

    SEMICOLON       shift and go to state 165


state 140

    (78) assignment -> ID . EQUALS expression

    EQUALS          shift and go to state 87


state 141

    (79) assignment -> data_type . ID EQUALS expression

    ID              shift and go to state 166


state 142

    (80) assignment -> CLASSOBJECT . ID
    (77) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    ID              shift and go to state 90
    LSQBRACKET      shift and go to state 92


state 143

    (76) data_structure_array -> primitive LSQBRACKET RSQBRACKET .

    ID              reduce using rule 76 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)
    GREATER_THAN    reduce using rule 76 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)


state 144

    (75) data_structure_list -> LIST LESS_THAN data_type . GREATER_THAN ID LSQBRACKET type RSQBRACKET

    GREATER_THAN    shift and go to state 167


state 145

    (64) logical_factor -> LPAREN logical_expression . RPAREN
    (56) logical_expression -> logical_expression . logical_operator logical_factor
    (65) logical_operator -> . OR
    (66) logical_operator -> . AND
    (67) logical_operator -> . NOT
    (68) logical_operator -> . GREATER_THAN
    (69) logical_operator -> . LESS_THAN
    (70) logical_operator -> . GREATER_EQUALS_THAN
    (71) logical_operator -> . LESS_EQUALS_THAN
    (72) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 168
    OR              shift and go to state 148
    AND             shift and go to state 149
    NOT             shift and go to state 150
    GREATER_THAN    shift and go to state 151
    LESS_THAN       shift and go to state 152
    GREATER_EQUALS_THAN shift and go to state 153
    LESS_EQUALS_THAN shift and go to state 154
    EQUALITY        shift and go to state 155

    logical_operator               shift and go to state 147

state 146

    (41) if -> IF LPAREN logical_expression RPAREN . block
    (42) if -> IF LPAREN logical_expression RPAREN . block body
    (43) if -> IF LPAREN logical_expression RPAREN . block elseif
    (44) if -> IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 169

state 147

    (56) logical_expression -> logical_expression logical_operator . logical_factor
    (58) logical_factor -> . TRUE
    (59) logical_factor -> . FALSE
    (60) logical_factor -> . ID
    (61) logical_factor -> . indexing
    (62) logical_factor -> . type
    (63) logical_factor -> . object_access
    (64) logical_factor -> . LPAREN logical_expression RPAREN
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 116
    LPAREN          shift and go to state 111
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    logical_factor                 shift and go to state 170
    indexing                       shift and go to state 117
    type                           shift and go to state 118
    object_access                  shift and go to state 119

state 148

    (65) logical_operator -> OR .

    TRUE            reduce using rule 65 (logical_operator -> OR .)
    FALSE           reduce using rule 65 (logical_operator -> OR .)
    ID              reduce using rule 65 (logical_operator -> OR .)
    LPAREN          reduce using rule 65 (logical_operator -> OR .)
    FLOAT_TYPE      reduce using rule 65 (logical_operator -> OR .)
    DOUBLE_TYPE     reduce using rule 65 (logical_operator -> OR .)
    DECIMAL_TYPE    reduce using rule 65 (logical_operator -> OR .)
    INTEGER_TYPE    reduce using rule 65 (logical_operator -> OR .)
    MINUS           reduce using rule 65 (logical_operator -> OR .)
    CLASSOBJECT     reduce using rule 65 (logical_operator -> OR .)


state 149

    (66) logical_operator -> AND .

    TRUE            reduce using rule 66 (logical_operator -> AND .)
    FALSE           reduce using rule 66 (logical_operator -> AND .)
    ID              reduce using rule 66 (logical_operator -> AND .)
    LPAREN          reduce using rule 66 (logical_operator -> AND .)
    FLOAT_TYPE      reduce using rule 66 (logical_operator -> AND .)
    DOUBLE_TYPE     reduce using rule 66 (logical_operator -> AND .)
    DECIMAL_TYPE    reduce using rule 66 (logical_operator -> AND .)
    INTEGER_TYPE    reduce using rule 66 (logical_operator -> AND .)
    MINUS           reduce using rule 66 (logical_operator -> AND .)
    CLASSOBJECT     reduce using rule 66 (logical_operator -> AND .)


state 150

    (67) logical_operator -> NOT .

    TRUE            reduce using rule 67 (logical_operator -> NOT .)
    FALSE           reduce using rule 67 (logical_operator -> NOT .)
    ID              reduce using rule 67 (logical_operator -> NOT .)
    LPAREN          reduce using rule 67 (logical_operator -> NOT .)
    FLOAT_TYPE      reduce using rule 67 (logical_operator -> NOT .)
    DOUBLE_TYPE     reduce using rule 67 (logical_operator -> NOT .)
    DECIMAL_TYPE    reduce using rule 67 (logical_operator -> NOT .)
    INTEGER_TYPE    reduce using rule 67 (logical_operator -> NOT .)
    MINUS           reduce using rule 67 (logical_operator -> NOT .)
    CLASSOBJECT     reduce using rule 67 (logical_operator -> NOT .)


state 151

    (68) logical_operator -> GREATER_THAN .

    TRUE            reduce using rule 68 (logical_operator -> GREATER_THAN .)
    FALSE           reduce using rule 68 (logical_operator -> GREATER_THAN .)
    ID              reduce using rule 68 (logical_operator -> GREATER_THAN .)
    LPAREN          reduce using rule 68 (logical_operator -> GREATER_THAN .)
    FLOAT_TYPE      reduce using rule 68 (logical_operator -> GREATER_THAN .)
    DOUBLE_TYPE     reduce using rule 68 (logical_operator -> GREATER_THAN .)
    DECIMAL_TYPE    reduce using rule 68 (logical_operator -> GREATER_THAN .)
    INTEGER_TYPE    reduce using rule 68 (logical_operator -> GREATER_THAN .)
    MINUS           reduce using rule 68 (logical_operator -> GREATER_THAN .)
    CLASSOBJECT     reduce using rule 68 (logical_operator -> GREATER_THAN .)


state 152

    (69) logical_operator -> LESS_THAN .

    TRUE            reduce using rule 69 (logical_operator -> LESS_THAN .)
    FALSE           reduce using rule 69 (logical_operator -> LESS_THAN .)
    ID              reduce using rule 69 (logical_operator -> LESS_THAN .)
    LPAREN          reduce using rule 69 (logical_operator -> LESS_THAN .)
    FLOAT_TYPE      reduce using rule 69 (logical_operator -> LESS_THAN .)
    DOUBLE_TYPE     reduce using rule 69 (logical_operator -> LESS_THAN .)
    DECIMAL_TYPE    reduce using rule 69 (logical_operator -> LESS_THAN .)
    INTEGER_TYPE    reduce using rule 69 (logical_operator -> LESS_THAN .)
    MINUS           reduce using rule 69 (logical_operator -> LESS_THAN .)
    CLASSOBJECT     reduce using rule 69 (logical_operator -> LESS_THAN .)


state 153

    (70) logical_operator -> GREATER_EQUALS_THAN .

    TRUE            reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    FALSE           reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    ID              reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    LPAREN          reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    MINUS           reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 70 (logical_operator -> GREATER_EQUALS_THAN .)


state 154

    (71) logical_operator -> LESS_EQUALS_THAN .

    TRUE            reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    FALSE           reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    ID              reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    LPAREN          reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    MINUS           reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 71 (logical_operator -> LESS_EQUALS_THAN .)


state 155

    (72) logical_operator -> EQUALITY .

    TRUE            reduce using rule 72 (logical_operator -> EQUALITY .)
    FALSE           reduce using rule 72 (logical_operator -> EQUALITY .)
    ID              reduce using rule 72 (logical_operator -> EQUALITY .)
    LPAREN          reduce using rule 72 (logical_operator -> EQUALITY .)
    FLOAT_TYPE      reduce using rule 72 (logical_operator -> EQUALITY .)
    DOUBLE_TYPE     reduce using rule 72 (logical_operator -> EQUALITY .)
    DECIMAL_TYPE    reduce using rule 72 (logical_operator -> EQUALITY .)
    INTEGER_TYPE    reduce using rule 72 (logical_operator -> EQUALITY .)
    MINUS           reduce using rule 72 (logical_operator -> EQUALITY .)
    CLASSOBJECT     reduce using rule 72 (logical_operator -> EQUALITY .)


state 156

    (23) function -> modifier data_type ID LPAREN . declarations RPAREN block
    (81) declarations -> . declaration
    (82) declarations -> . declaration COMMA
    (83) declarations -> . declaration COMMA declarations
    (84) declaration -> . data_type ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    data_type                      shift and go to state 171
    declarations                   shift and go to state 172
    declaration                    shift and go to state 173
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 157

    (24) function -> modifier VOID ID LPAREN . declarations RPAREN block
    (81) declarations -> . declaration
    (82) declarations -> . declaration COMMA
    (83) declarations -> . declaration COMMA declarations
    (84) declaration -> . data_type ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    declarations                   shift and go to state 174
    declaration                    shift and go to state 173
    data_type                      shift and go to state 171
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 158

    (25) function -> modifier STATIC data_type ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 175


state 159

    (26) function -> modifier STATIC VOID ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 176


state 160

    (79) assignment -> data_type ID EQUALS expression .
    (85) expression -> expression . PLUS term
    (86) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 79 (assignment -> data_type ID EQUALS expression .)
    RPAREN          reduce using rule 79 (assignment -> data_type ID EQUALS expression .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77


state 161

    (114) indexing -> ID LSQBRACKET ID RSQBRACKET .

    TIMES           reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    DIVIDE          reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    PLUS            reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    MINUS           reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    SEMICOLON       reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    RPAREN          reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    OR              reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    AND             reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    NOT             reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_THAN    reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_THAN       reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    EQUALITY        reduce using rule 114 (indexing -> ID LSQBRACKET ID RSQBRACKET .)


state 162

    (113) indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .

    TIMES           reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    DIVIDE          reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    PLUS            reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    MINUS           reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    SEMICOLON       reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    RPAREN          reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    OR              reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    AND             reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    NOT             reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_THAN    reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_THAN       reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    EQUALITY        reduce using rule 113 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)


state 163

    (31) expression -> object_access LPAREN expression RPAREN .

    PLUS            reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)
    MINUS           reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)
    RPAREN          reduce using rule 31 (expression -> object_access LPAREN expression RPAREN .)


state 164

    (54) while_loop -> WHILE LPAREN logical_expression RPAREN . block
    (55) while_loop -> WHILE LPAREN logical_expression RPAREN . block body
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 177

state 165

    (52) loop_for -> FOR LPAREN assignment SEMICOLON . logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> FOR LPAREN assignment SEMICOLON . logical_expression SEMICOLON assignment RPAREN block body
    (56) logical_expression -> . logical_expression logical_operator logical_factor
    (57) logical_expression -> . logical_factor
    (58) logical_factor -> . TRUE
    (59) logical_factor -> . FALSE
    (60) logical_factor -> . ID
    (61) logical_factor -> . indexing
    (62) logical_factor -> . type
    (63) logical_factor -> . object_access
    (64) logical_factor -> . LPAREN logical_expression RPAREN
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 116
    LPAREN          shift and go to state 111
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    logical_expression             shift and go to state 178
    logical_factor                 shift and go to state 113
    indexing                       shift and go to state 117
    type                           shift and go to state 118
    object_access                  shift and go to state 119

state 166

    (79) assignment -> data_type ID . EQUALS expression

    EQUALS          shift and go to state 125


state 167

    (75) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN . ID LSQBRACKET type RSQBRACKET

    ID              shift and go to state 179


state 168

    (64) logical_factor -> LPAREN logical_expression RPAREN .

    RPAREN          reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    OR              reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    AND             reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    NOT             reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_THAN    reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_THAN       reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_EQUALS_THAN reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_EQUALS_THAN reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    EQUALITY        reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)
    SEMICOLON       reduce using rule 64 (logical_factor -> LPAREN logical_expression RPAREN .)


state 169

    (41) if -> IF LPAREN logical_expression RPAREN block .
    (42) if -> IF LPAREN logical_expression RPAREN block . body
    (43) if -> IF LPAREN logical_expression RPAREN block . elseif
    (44) if -> IF LPAREN logical_expression RPAREN block . else
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (45) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (46) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (47) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (48) else -> . ELSE block
    (49) else -> . ELSE block body
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (41) if -> . IF LPAREN logical_expression RPAREN block
    (42) if -> . IF LPAREN logical_expression RPAREN block body
    (43) if -> . IF LPAREN logical_expression RPAREN block elseif
    (44) if -> . IF LPAREN logical_expression RPAREN block else
    (50) loop -> . while_loop
    (51) loop -> . loop_for
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (84) declaration -> . data_type ID
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (54) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (55) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (52) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 41 (if -> IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 183
    IF              shift and go to state 36
    ID              shift and go to state 42
    CLASSOBJECT     shift and go to state 43
    RETURN          shift and go to state 47
    WHILE           shift and go to state 49
    FOR             shift and go to state 50
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LPAREN          shift and go to state 37
    LIST            shift and go to state 68
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    body                           shift and go to state 180
    elseif                         shift and go to state 181
    else                           shift and go to state 182
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    type                           shift and go to state 48
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    factor                         shift and go to state 53
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66
    indexing                       shift and go to state 67

state 170

    (56) logical_expression -> logical_expression logical_operator logical_factor .

    RPAREN          reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    OR              reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    AND             reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    NOT             reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    GREATER_THAN    reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    LESS_THAN       reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    GREATER_EQUALS_THAN reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    LESS_EQUALS_THAN reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    EQUALITY        reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)
    SEMICOLON       reduce using rule 56 (logical_expression -> logical_expression logical_operator logical_factor .)


state 171

    (84) declaration -> data_type . ID

    ID              shift and go to state 184


state 172

    (23) function -> modifier data_type ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 185


state 173

    (81) declarations -> declaration .
    (82) declarations -> declaration . COMMA
    (83) declarations -> declaration . COMMA declarations

    RPAREN          reduce using rule 81 (declarations -> declaration .)
    COMMA           shift and go to state 186


state 174

    (24) function -> modifier VOID ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 187


state 175

    (25) function -> modifier STATIC data_type ID LPAREN . declarations RPAREN block
    (81) declarations -> . declaration
    (82) declarations -> . declaration COMMA
    (83) declarations -> . declaration COMMA declarations
    (84) declaration -> . data_type ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    data_type                      shift and go to state 171
    declarations                   shift and go to state 188
    declaration                    shift and go to state 173
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 176

    (26) function -> modifier STATIC VOID ID LPAREN . declarations RPAREN block
    (81) declarations -> . declaration
    (82) declarations -> . declaration COMMA
    (83) declarations -> . declaration COMMA declarations
    (84) declaration -> . data_type ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    declarations                   shift and go to state 189
    declaration                    shift and go to state 173
    data_type                      shift and go to state 171
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 177

    (54) while_loop -> WHILE LPAREN logical_expression RPAREN block .
    (55) while_loop -> WHILE LPAREN logical_expression RPAREN block . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (41) if -> . IF LPAREN logical_expression RPAREN block
    (42) if -> . IF LPAREN logical_expression RPAREN block body
    (43) if -> . IF LPAREN logical_expression RPAREN block elseif
    (44) if -> . IF LPAREN logical_expression RPAREN block else
    (50) loop -> . while_loop
    (51) loop -> . loop_for
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (84) declaration -> . data_type ID
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (54) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (55) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (52) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 54 (while_loop -> WHILE LPAREN logical_expression RPAREN block .)
    IF              shift and go to state 36
    ID              shift and go to state 42
    CLASSOBJECT     shift and go to state 43
    RETURN          shift and go to state 47
    WHILE           shift and go to state 49
    FOR             shift and go to state 50
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LPAREN          shift and go to state 37
    LIST            shift and go to state 68
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    body                           shift and go to state 190
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    type                           shift and go to state 48
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    factor                         shift and go to state 53
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66
    indexing                       shift and go to state 67

state 178

    (52) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression . SEMICOLON assignment RPAREN block
    (53) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression . SEMICOLON assignment RPAREN block body
    (56) logical_expression -> logical_expression . logical_operator logical_factor
    (65) logical_operator -> . OR
    (66) logical_operator -> . AND
    (67) logical_operator -> . NOT
    (68) logical_operator -> . GREATER_THAN
    (69) logical_operator -> . LESS_THAN
    (70) logical_operator -> . GREATER_EQUALS_THAN
    (71) logical_operator -> . LESS_EQUALS_THAN
    (72) logical_operator -> . EQUALITY

    SEMICOLON       shift and go to state 191
    OR              shift and go to state 148
    AND             shift and go to state 149
    NOT             shift and go to state 150
    GREATER_THAN    shift and go to state 151
    LESS_THAN       shift and go to state 152
    GREATER_EQUALS_THAN shift and go to state 153
    LESS_EQUALS_THAN shift and go to state 154
    EQUALITY        shift and go to state 155

    logical_operator               shift and go to state 147

state 179

    (75) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID . LSQBRACKET type RSQBRACKET

    LSQBRACKET      shift and go to state 192


state 180

    (42) if -> IF LPAREN logical_expression RPAREN block body .

    RBRACKET        reduce using rule 42 (if -> IF LPAREN logical_expression RPAREN block body .)


state 181

    (43) if -> IF LPAREN logical_expression RPAREN block elseif .

    RBRACKET        reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block elseif .)


state 182

    (44) if -> IF LPAREN logical_expression RPAREN block else .

    RBRACKET        reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block else .)


state 183

    (45) elseif -> ELSE . IF LPAREN logical_expression RPAREN block
    (46) elseif -> ELSE . IF LPAREN logical_expression RPAREN block elseif
    (47) elseif -> ELSE . IF LPAREN logical_expression RPAREN block else
    (48) else -> ELSE . block
    (49) else -> ELSE . block body
    (13) block -> . LBRACKET body RBRACKET

    IF              shift and go to state 193
    LBRACKET        shift and go to state 25

    block                          shift and go to state 194

state 184

    (84) declaration -> data_type ID .

    COMMA           reduce using rule 84 (declaration -> data_type ID .)
    RPAREN          reduce using rule 84 (declaration -> data_type ID .)


state 185

    (23) function -> modifier data_type ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 195

state 186

    (82) declarations -> declaration COMMA .
    (83) declarations -> declaration COMMA . declarations
    (81) declarations -> . declaration
    (82) declarations -> . declaration COMMA
    (83) declarations -> . declaration COMMA declarations
    (84) declaration -> . data_type ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    RPAREN          reduce using rule 82 (declarations -> declaration COMMA .)
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68
    CLASSOBJECT     shift and go to state 85

    declaration                    shift and go to state 173
    declarations                   shift and go to state 196
    data_type                      shift and go to state 171
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 187

    (24) function -> modifier VOID ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 197

state 188

    (25) function -> modifier STATIC data_type ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 198


state 189

    (26) function -> modifier STATIC VOID ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 199


state 190

    (55) while_loop -> WHILE LPAREN logical_expression RPAREN block body .

    RBRACKET        reduce using rule 55 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)


state 191

    (52) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON . assignment RPAREN block
    (53) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON . assignment RPAREN block body
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    ID              shift and go to state 140
    CLASSOBJECT     shift and go to state 142
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LIST            shift and go to state 68

    assignment                     shift and go to state 200
    data_type                      shift and go to state 141
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66

state 192

    (75) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET . type RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE

    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    type                           shift and go to state 201

state 193

    (45) elseif -> ELSE IF . LPAREN logical_expression RPAREN block
    (46) elseif -> ELSE IF . LPAREN logical_expression RPAREN block elseif
    (47) elseif -> ELSE IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 202


state 194

    (48) else -> ELSE block .
    (49) else -> ELSE block . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (41) if -> . IF LPAREN logical_expression RPAREN block
    (42) if -> . IF LPAREN logical_expression RPAREN block body
    (43) if -> . IF LPAREN logical_expression RPAREN block elseif
    (44) if -> . IF LPAREN logical_expression RPAREN block else
    (50) loop -> . while_loop
    (51) loop -> . loop_for
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (84) declaration -> . data_type ID
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (54) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (55) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (52) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 48 (else -> ELSE block .)
    IF              shift and go to state 36
    ID              shift and go to state 42
    CLASSOBJECT     shift and go to state 43
    RETURN          shift and go to state 47
    WHILE           shift and go to state 49
    FOR             shift and go to state 50
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LPAREN          shift and go to state 37
    LIST            shift and go to state 68
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    body                           shift and go to state 203
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    type                           shift and go to state 48
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    factor                         shift and go to state 53
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66
    indexing                       shift and go to state 67

state 195

    (23) function -> modifier data_type ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 23 (function -> modifier data_type ID LPAREN declarations RPAREN block .)


state 196

    (83) declarations -> declaration COMMA declarations .

    RPAREN          reduce using rule 83 (declarations -> declaration COMMA declarations .)


state 197

    (24) function -> modifier VOID ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 24 (function -> modifier VOID ID LPAREN declarations RPAREN block .)


state 198

    (25) function -> modifier STATIC data_type ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 204

state 199

    (26) function -> modifier STATIC VOID ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 205

state 200

    (52) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment . RPAREN block
    (53) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment . RPAREN block body

    RPAREN          shift and go to state 206


state 201

    (75) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type . RSQBRACKET

    RSQBRACKET      shift and go to state 207


state 202

    (45) elseif -> ELSE IF LPAREN . logical_expression RPAREN block
    (46) elseif -> ELSE IF LPAREN . logical_expression RPAREN block elseif
    (47) elseif -> ELSE IF LPAREN . logical_expression RPAREN block else
    (56) logical_expression -> . logical_expression logical_operator logical_factor
    (57) logical_expression -> . logical_factor
    (58) logical_factor -> . TRUE
    (59) logical_factor -> . FALSE
    (60) logical_factor -> . ID
    (61) logical_factor -> . indexing
    (62) logical_factor -> . type
    (63) logical_factor -> . object_access
    (64) logical_factor -> . LPAREN logical_expression RPAREN
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 116
    LPAREN          shift and go to state 111
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46
    CLASSOBJECT     shift and go to state 81

    logical_expression             shift and go to state 208
    logical_factor                 shift and go to state 113
    indexing                       shift and go to state 117
    type                           shift and go to state 118
    object_access                  shift and go to state 119

state 203

    (49) else -> ELSE block body .

    RBRACKET        reduce using rule 49 (else -> ELSE block body .)


state 204

    (25) function -> modifier STATIC data_type ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 25 (function -> modifier STATIC data_type ID LPAREN declarations RPAREN block .)


state 205

    (26) function -> modifier STATIC VOID ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 26 (function -> modifier STATIC VOID ID LPAREN declarations RPAREN block .)


state 206

    (52) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN . block
    (53) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN . block body
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 209

state 207

    (75) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET .

    ID              reduce using rule 75 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET .)
    GREATER_THAN    reduce using rule 75 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET .)


state 208

    (45) elseif -> ELSE IF LPAREN logical_expression . RPAREN block
    (46) elseif -> ELSE IF LPAREN logical_expression . RPAREN block elseif
    (47) elseif -> ELSE IF LPAREN logical_expression . RPAREN block else
    (56) logical_expression -> logical_expression . logical_operator logical_factor
    (65) logical_operator -> . OR
    (66) logical_operator -> . AND
    (67) logical_operator -> . NOT
    (68) logical_operator -> . GREATER_THAN
    (69) logical_operator -> . LESS_THAN
    (70) logical_operator -> . GREATER_EQUALS_THAN
    (71) logical_operator -> . LESS_EQUALS_THAN
    (72) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 210
    OR              shift and go to state 148
    AND             shift and go to state 149
    NOT             shift and go to state 150
    GREATER_THAN    shift and go to state 151
    LESS_THAN       shift and go to state 152
    GREATER_EQUALS_THAN shift and go to state 153
    LESS_EQUALS_THAN shift and go to state 154
    EQUALITY        shift and go to state 155

    logical_operator               shift and go to state 147

state 209

    (52) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .
    (53) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (41) if -> . IF LPAREN logical_expression RPAREN block
    (42) if -> . IF LPAREN logical_expression RPAREN block body
    (43) if -> . IF LPAREN logical_expression RPAREN block elseif
    (44) if -> . IF LPAREN logical_expression RPAREN block else
    (50) loop -> . while_loop
    (51) loop -> . loop_for
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (78) assignment -> . ID EQUALS expression
    (79) assignment -> . data_type ID EQUALS expression
    (80) assignment -> . CLASSOBJECT ID
    (31) expression -> . object_access LPAREN expression RPAREN
    (32) expression -> . object_access LPAREN RPAREN
    (85) expression -> . expression PLUS term
    (86) expression -> . expression MINUS term
    (87) expression -> . term
    (84) declaration -> . data_type ID
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (54) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (55) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (52) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (53) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body
    (96) modifier -> . PUBLIC
    (97) modifier -> . PRIVATE
    (98) modifier -> . PROTECTED
    (99) modifier -> . INTERNAL
    (100) data_type -> . primitive
    (101) data_type -> . data_structure
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (88) term -> . term TIMES factor
    (89) term -> . term DIVIDE factor
    (90) term -> . factor
    (102) primitive -> . INT
    (103) primitive -> . FLOAT
    (104) primitive -> . BOOL
    (105) primitive -> . BYTE
    (106) primitive -> . CHAR
    (107) primitive -> . SBYTE
    (108) primitive -> . DECIMAL
    (109) primitive -> . DOUBLE
    (110) primitive -> . LONG
    (111) primitive -> . SHORT
    (112) primitive -> . UINT
    (73) data_structure -> . data_structure_list
    (74) data_structure -> . data_structure_array
    (91) factor -> . type
    (92) factor -> . LPAREN expression RPAREN
    (93) factor -> . object_access
    (94) factor -> . ID
    (95) factor -> . indexing
    (75) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN ID LSQBRACKET type RSQBRACKET
    (76) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (77) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (33) type -> . FLOAT_TYPE
    (34) type -> . DOUBLE_TYPE
    (35) type -> . DECIMAL_TYPE
    (36) type -> . INTEGER_TYPE
    (37) type -> . MINUS FLOAT_TYPE
    (38) type -> . MINUS DOUBLE_TYPE
    (39) type -> . MINUS DECIMAL_TYPE
    (40) type -> . MINUS INTEGER_TYPE
    (113) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (114) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 52 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    IF              shift and go to state 36
    ID              shift and go to state 42
    CLASSOBJECT     shift and go to state 43
    RETURN          shift and go to state 47
    WHILE           shift and go to state 49
    FOR             shift and go to state 50
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 54
    FLOAT           shift and go to state 55
    BOOL            shift and go to state 56
    BYTE            shift and go to state 57
    CHAR            shift and go to state 58
    SBYTE           shift and go to state 59
    DECIMAL         shift and go to state 60
    DOUBLE          shift and go to state 61
    LONG            shift and go to state 62
    SHORT           shift and go to state 63
    UINT            shift and go to state 64
    LPAREN          shift and go to state 37
    LIST            shift and go to state 68
    FLOAT_TYPE      shift and go to state 69
    DOUBLE_TYPE     shift and go to state 70
    DECIMAL_TYPE    shift and go to state 71
    INTEGER_TYPE    shift and go to state 72
    MINUS           shift and go to state 46

    assignment                     shift and go to state 32
    body                           shift and go to state 211
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    object_access                  shift and go to state 44
    term                           shift and go to state 45
    type                           shift and go to state 48
    primitive                      shift and go to state 51
    data_structure                 shift and go to state 52
    factor                         shift and go to state 53
    data_structure_list            shift and go to state 65
    data_structure_array           shift and go to state 66
    indexing                       shift and go to state 67

state 210

    (45) elseif -> ELSE IF LPAREN logical_expression RPAREN . block
    (46) elseif -> ELSE IF LPAREN logical_expression RPAREN . block elseif
    (47) elseif -> ELSE IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 212

state 211

    (53) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body .

    RBRACKET        reduce using rule 53 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block body .)


state 212

    (45) elseif -> ELSE IF LPAREN logical_expression RPAREN block .
    (46) elseif -> ELSE IF LPAREN logical_expression RPAREN block . elseif
    (47) elseif -> ELSE IF LPAREN logical_expression RPAREN block . else
    (45) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (46) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (47) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (48) else -> . ELSE block
    (49) else -> . ELSE block body

    RBRACKET        reduce using rule 45 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 183

    elseif                         shift and go to state 213
    else                           shift and go to state 214

state 213

    (46) elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .

    RBRACKET        reduce using rule 46 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)


state 214

    (47) elseif -> ELSE IF LPAREN logical_expression RPAREN block else .

    RBRACKET        reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)

