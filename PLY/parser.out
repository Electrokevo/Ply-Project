Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    DIVIDE_EQUAL
    DO
    FILE
    FOR
    MINUS_EQUAL
    MODULE
    MODULE_EQUAL
    NEW
    NINT
    NUINT
    PLUS_EQUAL
    STRING
    THEN
    TIMES_EQUAL
    ULONG
    USHORT
    VAR

Grammar

Rule 0     S' -> program
Rule 1     program -> usings namespace class
Rule 2     program -> namespace class
Rule 3     usings -> using usings
Rule 4     usings -> using
Rule 5     using -> USING CLASSOBJECT SEMICOLON
Rule 6     namespace -> NAMESPACE CLASSOBJECT SEMICOLON
Rule 7     class -> modifier CLASS CLASSOBJECT block
Rule 8     class -> modifier STATIC CLASS CLASSOBJECT block
Rule 9     object_access -> ID DOT ID
Rule 10    object_access -> CLASSOBJECT DOT CLASSOBJECT
Rule 11    object_access -> ID DOT CLASSOBJECT
Rule 12    object_access -> CLASSOBJECT DOT ID
Rule 13    block -> LBRACKET body RBRACKET
Rule 14    body -> lines SEMICOLON
Rule 15    body -> lines SEMICOLON body
Rule 16    body -> function
Rule 17    lines -> assignment
Rule 18    lines -> expression
Rule 19    lines -> declaration
Rule 20    lines -> if
Rule 21    lines -> loop
Rule 22    lines -> return
Rule 23    function -> modifier data_type ID LPAREN declarations RPAREN block
Rule 24    function -> modifier VOID ID LPAREN declarations RPAREN block
Rule 25    function -> modifier STATIC data_type ID LPAREN declarations RPAREN block
Rule 26    function -> modifier STATIC VOID ID LPAREN declarations RPAREN block
Rule 27    return -> RETURN ID
Rule 28    return -> RETURN type
Rule 29    type -> FLOAT_TYPE
Rule 30    type -> DOUBLE_TYPE
Rule 31    type -> DECIMAL_TYPE
Rule 32    type -> INTEGER_TYPE
Rule 33    if -> IF LPAREN logical_expression RPAREN block
Rule 34    if -> IF LPAREN logical_expression RPAREN block elseif
Rule 35    if -> IF LPAREN logical_expression RPAREN block else
Rule 36    elseif -> ELSE IF LPAREN logical_expression RPAREN block
Rule 37    elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif
Rule 38    elseif -> ELSE IF LPAREN logical_expression RPAREN block else
Rule 39    else -> ELSE block
Rule 40    loop -> while_loop
Rule 41    while_loop -> WHILE LPAREN logical_expression RPAREN block
Rule 42    logical_expression -> logical_expression logical_operator logical_factor
Rule 43    logical_expression -> logical_factor
Rule 44    logical_factor -> TRUE
Rule 45    logical_factor -> FALSE
Rule 46    logical_factor -> ID
Rule 47    logical_factor -> indexing
Rule 48    logical_factor -> type
Rule 49    logical_factor -> object_access
Rule 50    logical_factor -> LPAREN logical_expression RPAREN
Rule 51    logical_operator -> OR
Rule 52    logical_operator -> AND
Rule 53    logical_operator -> NOT
Rule 54    logical_operator -> GREATER_THAN
Rule 55    logical_operator -> LESS_THAN
Rule 56    logical_operator -> GREATER_EQUALS_THAN
Rule 57    logical_operator -> LESS_EQUALS_THAN
Rule 58    logical_operator -> EQUALITY
Rule 59    assignment -> ID EQUALS expression
Rule 60    assignment -> data_type ID EQUALS expression
Rule 61    assignment -> CLASSOBJECT ID
Rule 62    declarations -> declaration
Rule 63    declarations -> declaration COMMA
Rule 64    declarations -> declaration COMMA declarations
Rule 65    declaration -> data_type ID
Rule 66    expression -> expression PLUS term
Rule 67    expression -> expression MINUS term
Rule 68    expression -> term
Rule 69    term -> term TIMES factor
Rule 70    term -> term DIVIDE factor
Rule 71    term -> factor
Rule 72    factor -> type
Rule 73    factor -> LPAREN expression RPAREN
Rule 74    factor -> object_access
Rule 75    factor -> ID
Rule 76    factor -> indexing
Rule 77    modifier -> PUBLIC
Rule 78    modifier -> PRIVATE
Rule 79    modifier -> PROTECTED
Rule 80    modifier -> INTERNAL
Rule 81    data_type -> primitive
Rule 82    data_type -> data_structure
Rule 83    primitive -> INT
Rule 84    primitive -> FLOAT
Rule 85    primitive -> BOOL
Rule 86    primitive -> BYTE
Rule 87    primitive -> CHAR
Rule 88    primitive -> SBYTE
Rule 89    primitive -> DECIMAL
Rule 90    primitive -> DOUBLE
Rule 91    primitive -> LONG
Rule 92    primitive -> SHORT
Rule 93    primitive -> UINT
Rule 94    data_structure -> array
Rule 95    array -> primitive LSQBRACKET RSQBRACKET
Rule 96    array -> CLASSOBJECT LSQBRACKET RSQBRACKET
Rule 97    indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET
Rule 98    indexing -> ID LSQBRACKET ID RSQBRACKET

Terminals, with rules where they appear

AND                  : 52
BOOL                 : 85
BYTE                 : 86
CHAR                 : 87
CHARACTER            : 
CLASS                : 7 8
CLASSOBJECT          : 5 6 7 8 10 10 11 12 61 96
COMMA                : 63 64
DECIMAL              : 89
DECIMAL_TYPE         : 31
DIVIDE               : 70
DIVIDE_EQUAL         : 
DO                   : 
DOT                  : 9 10 11 12
DOUBLE               : 90
DOUBLE_TYPE          : 30
ELSE                 : 36 37 38 39
EQUALITY             : 58
EQUALS               : 59 60
FALSE                : 45
FILE                 : 
FLOAT                : 84
FLOAT_TYPE           : 29
FOR                  : 
GREATER_EQUALS_THAN  : 56
GREATER_THAN         : 54
ID                   : 9 9 11 12 23 24 25 26 27 46 59 60 61 65 75 97 98 98
IF                   : 33 34 35 36 37 38
INT                  : 83
INTEGER_TYPE         : 32 97
INTERNAL             : 80
LBRACKET             : 13
LESS_EQUALS_THAN     : 57
LESS_THAN            : 55
LONG                 : 91
LPAREN               : 23 24 25 26 33 34 35 36 37 38 41 50 73
LSQBRACKET           : 95 96 97 98
MINUS                : 67
MINUS_EQUAL          : 
MODULE               : 
MODULE_EQUAL         : 
NAMESPACE            : 6
NEW                  : 
NINT                 : 
NOT                  : 53
NUINT                : 
OR                   : 51
PLUS                 : 66
PLUS_EQUAL           : 
PRIVATE              : 78
PROTECTED            : 79
PUBLIC               : 77
RBRACKET             : 13
RETURN               : 27 28
RPAREN               : 23 24 25 26 33 34 35 36 37 38 41 50 73
RSQBRACKET           : 95 96 97 98
SBYTE                : 88
SEMICOLON            : 5 6 14 15
SHORT                : 92
STATIC               : 8 25 26
STRING               : 
THEN                 : 
TIMES                : 69
TIMES_EQUAL          : 
TRUE                 : 44
UINT                 : 93
ULONG                : 
USHORT               : 
USING                : 5
VAR                  : 
VOID                 : 24 26
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

array                : 94
assignment           : 17
block                : 7 8 23 24 25 26 33 34 35 36 37 38 39 41
body                 : 13 15
class                : 1 2
data_structure       : 82
data_type            : 23 25 60 65
declaration          : 19 62 63 64
declarations         : 23 24 25 26 64
else                 : 35 38
elseif               : 34 37
expression           : 18 59 60 66 67 73
factor               : 69 70 71
function             : 16
if                   : 20
indexing             : 47 76
lines                : 14 15
logical_expression   : 33 34 35 36 37 38 41 42 50
logical_factor       : 42 43
logical_operator     : 42
loop                 : 21
modifier             : 7 8 23 24 25 26
namespace            : 1 2
object_access        : 49 74
primitive            : 81 95
program              : 0
return               : 22
term                 : 66 67 68 69 70
type                 : 28 48 72
using                : 3 4
usings               : 1 3
while_loop           : 40

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . usings namespace class
    (2) program -> . namespace class
    (3) usings -> . using usings
    (4) usings -> . using
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5
    USING           shift and go to state 6

    program                        shift and go to state 1
    usings                         shift and go to state 2
    namespace                      shift and go to state 3
    using                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> usings . namespace class
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5

    namespace                      shift and go to state 7

state 3

    (2) program -> namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (77) modifier -> . PUBLIC
    (78) modifier -> . PRIVATE
    (79) modifier -> . PROTECTED
    (80) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 8
    modifier                       shift and go to state 9

state 4

    (3) usings -> using . usings
    (4) usings -> using .
    (3) usings -> . using usings
    (4) usings -> . using
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       reduce using rule 4 (usings -> using .)
    USING           shift and go to state 6

    using                          shift and go to state 4
    usings                         shift and go to state 14

state 5

    (6) namespace -> NAMESPACE . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 15


state 6

    (5) using -> USING . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 16


state 7

    (1) program -> usings namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (77) modifier -> . PUBLIC
    (78) modifier -> . PRIVATE
    (79) modifier -> . PROTECTED
    (80) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 17
    modifier                       shift and go to state 9

state 8

    (2) program -> namespace class .

    $end            reduce using rule 2 (program -> namespace class .)


state 9

    (7) class -> modifier . CLASS CLASSOBJECT block
    (8) class -> modifier . STATIC CLASS CLASSOBJECT block

    CLASS           shift and go to state 18
    STATIC          shift and go to state 19


state 10

    (77) modifier -> PUBLIC .

    CLASS           reduce using rule 77 (modifier -> PUBLIC .)
    STATIC          reduce using rule 77 (modifier -> PUBLIC .)
    VOID            reduce using rule 77 (modifier -> PUBLIC .)
    INT             reduce using rule 77 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 77 (modifier -> PUBLIC .)
    BOOL            reduce using rule 77 (modifier -> PUBLIC .)
    BYTE            reduce using rule 77 (modifier -> PUBLIC .)
    CHAR            reduce using rule 77 (modifier -> PUBLIC .)
    SBYTE           reduce using rule 77 (modifier -> PUBLIC .)
    DECIMAL         reduce using rule 77 (modifier -> PUBLIC .)
    DOUBLE          reduce using rule 77 (modifier -> PUBLIC .)
    LONG            reduce using rule 77 (modifier -> PUBLIC .)
    SHORT           reduce using rule 77 (modifier -> PUBLIC .)
    UINT            reduce using rule 77 (modifier -> PUBLIC .)
    CLASSOBJECT     reduce using rule 77 (modifier -> PUBLIC .)


state 11

    (78) modifier -> PRIVATE .

    CLASS           reduce using rule 78 (modifier -> PRIVATE .)
    STATIC          reduce using rule 78 (modifier -> PRIVATE .)
    VOID            reduce using rule 78 (modifier -> PRIVATE .)
    INT             reduce using rule 78 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 78 (modifier -> PRIVATE .)
    BOOL            reduce using rule 78 (modifier -> PRIVATE .)
    BYTE            reduce using rule 78 (modifier -> PRIVATE .)
    CHAR            reduce using rule 78 (modifier -> PRIVATE .)
    SBYTE           reduce using rule 78 (modifier -> PRIVATE .)
    DECIMAL         reduce using rule 78 (modifier -> PRIVATE .)
    DOUBLE          reduce using rule 78 (modifier -> PRIVATE .)
    LONG            reduce using rule 78 (modifier -> PRIVATE .)
    SHORT           reduce using rule 78 (modifier -> PRIVATE .)
    UINT            reduce using rule 78 (modifier -> PRIVATE .)
    CLASSOBJECT     reduce using rule 78 (modifier -> PRIVATE .)


state 12

    (79) modifier -> PROTECTED .

    CLASS           reduce using rule 79 (modifier -> PROTECTED .)
    STATIC          reduce using rule 79 (modifier -> PROTECTED .)
    VOID            reduce using rule 79 (modifier -> PROTECTED .)
    INT             reduce using rule 79 (modifier -> PROTECTED .)
    FLOAT           reduce using rule 79 (modifier -> PROTECTED .)
    BOOL            reduce using rule 79 (modifier -> PROTECTED .)
    BYTE            reduce using rule 79 (modifier -> PROTECTED .)
    CHAR            reduce using rule 79 (modifier -> PROTECTED .)
    SBYTE           reduce using rule 79 (modifier -> PROTECTED .)
    DECIMAL         reduce using rule 79 (modifier -> PROTECTED .)
    DOUBLE          reduce using rule 79 (modifier -> PROTECTED .)
    LONG            reduce using rule 79 (modifier -> PROTECTED .)
    SHORT           reduce using rule 79 (modifier -> PROTECTED .)
    UINT            reduce using rule 79 (modifier -> PROTECTED .)
    CLASSOBJECT     reduce using rule 79 (modifier -> PROTECTED .)


state 13

    (80) modifier -> INTERNAL .

    CLASS           reduce using rule 80 (modifier -> INTERNAL .)
    STATIC          reduce using rule 80 (modifier -> INTERNAL .)
    VOID            reduce using rule 80 (modifier -> INTERNAL .)
    INT             reduce using rule 80 (modifier -> INTERNAL .)
    FLOAT           reduce using rule 80 (modifier -> INTERNAL .)
    BOOL            reduce using rule 80 (modifier -> INTERNAL .)
    BYTE            reduce using rule 80 (modifier -> INTERNAL .)
    CHAR            reduce using rule 80 (modifier -> INTERNAL .)
    SBYTE           reduce using rule 80 (modifier -> INTERNAL .)
    DECIMAL         reduce using rule 80 (modifier -> INTERNAL .)
    DOUBLE          reduce using rule 80 (modifier -> INTERNAL .)
    LONG            reduce using rule 80 (modifier -> INTERNAL .)
    SHORT           reduce using rule 80 (modifier -> INTERNAL .)
    UINT            reduce using rule 80 (modifier -> INTERNAL .)
    CLASSOBJECT     reduce using rule 80 (modifier -> INTERNAL .)


state 14

    (3) usings -> using usings .

    NAMESPACE       reduce using rule 3 (usings -> using usings .)


state 15

    (6) namespace -> NAMESPACE CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 20


state 16

    (5) using -> USING CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 21


state 17

    (1) program -> usings namespace class .

    $end            reduce using rule 1 (program -> usings namespace class .)


state 18

    (7) class -> modifier CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 22


state 19

    (8) class -> modifier STATIC . CLASS CLASSOBJECT block

    CLASS           shift and go to state 23


state 20

    (6) namespace -> NAMESPACE CLASSOBJECT SEMICOLON .

    PUBLIC          reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PRIVATE         reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PROTECTED       reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    INTERNAL        reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)


state 21

    (5) using -> USING CLASSOBJECT SEMICOLON .

    USING           reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)
    NAMESPACE       reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)


state 22

    (7) class -> modifier CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 24

state 23

    (8) class -> modifier STATIC CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 26


state 24

    (7) class -> modifier CLASS CLASSOBJECT block .

    $end            reduce using rule 7 (class -> modifier CLASS CLASSOBJECT block .)


state 25

    (13) block -> LBRACKET . body RBRACKET
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . function
    (17) lines -> . assignment
    (18) lines -> . expression
    (19) lines -> . declaration
    (20) lines -> . if
    (21) lines -> . loop
    (22) lines -> . return
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (59) assignment -> . ID EQUALS expression
    (60) assignment -> . data_type ID EQUALS expression
    (61) assignment -> . CLASSOBJECT ID
    (66) expression -> . expression PLUS term
    (67) expression -> . expression MINUS term
    (68) expression -> . term
    (65) declaration -> . data_type ID
    (33) if -> . IF LPAREN logical_expression RPAREN block
    (34) if -> . IF LPAREN logical_expression RPAREN block elseif
    (35) if -> . IF LPAREN logical_expression RPAREN block else
    (40) loop -> . while_loop
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (77) modifier -> . PUBLIC
    (78) modifier -> . PRIVATE
    (79) modifier -> . PROTECTED
    (80) modifier -> . INTERNAL
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (41) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    ID              shift and go to state 38
    CLASSOBJECT     shift and go to state 40
    IF              shift and go to state 42
    RETURN          shift and go to state 44
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    WHILE           shift and go to state 49
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    LPAREN          shift and go to state 39
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67

    body                           shift and go to state 27
    lines                          shift and go to state 28
    function                       shift and go to state 29
    assignment                     shift and go to state 30
    expression                     shift and go to state 31
    declaration                    shift and go to state 32
    if                             shift and go to state 33
    loop                           shift and go to state 34
    return                         shift and go to state 35
    modifier                       shift and go to state 36
    data_type                      shift and go to state 37
    term                           shift and go to state 41
    while_loop                     shift and go to state 43
    type                           shift and go to state 45
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    factor                         shift and go to state 48
    array                          shift and go to state 61
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 26

    (8) class -> modifier STATIC CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 68

state 27

    (13) block -> LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 69


state 28

    (14) body -> lines . SEMICOLON
    (15) body -> lines . SEMICOLON body

    SEMICOLON       shift and go to state 70


state 29

    (16) body -> function .

    RBRACKET        reduce using rule 16 (body -> function .)


state 30

    (17) lines -> assignment .

    SEMICOLON       reduce using rule 17 (lines -> assignment .)


state 31

    (18) lines -> expression .
    (66) expression -> expression . PLUS term
    (67) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 18 (lines -> expression .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 32

    (19) lines -> declaration .

    SEMICOLON       reduce using rule 19 (lines -> declaration .)


state 33

    (20) lines -> if .

    SEMICOLON       reduce using rule 20 (lines -> if .)


state 34

    (21) lines -> loop .

    SEMICOLON       reduce using rule 21 (lines -> loop .)


state 35

    (22) lines -> return .

    SEMICOLON       reduce using rule 22 (lines -> return .)


state 36

    (23) function -> modifier . data_type ID LPAREN declarations RPAREN block
    (24) function -> modifier . VOID ID LPAREN declarations RPAREN block
    (25) function -> modifier . STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> modifier . STATIC VOID ID LPAREN declarations RPAREN block
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 74
    STATIC          shift and go to state 75
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    data_type                      shift and go to state 73
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 37

    (60) assignment -> data_type . ID EQUALS expression
    (65) declaration -> data_type . ID

    ID              shift and go to state 77


state 38

    (59) assignment -> ID . EQUALS expression
    (75) factor -> ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> ID . LSQBRACKET ID RSQBRACKET

    EQUALS          shift and go to state 78
    TIMES           reduce using rule 75 (factor -> ID .)
    DIVIDE          reduce using rule 75 (factor -> ID .)
    PLUS            reduce using rule 75 (factor -> ID .)
    MINUS           reduce using rule 75 (factor -> ID .)
    SEMICOLON       reduce using rule 75 (factor -> ID .)
    DOT             shift and go to state 79
    LSQBRACKET      shift and go to state 80


state 39

    (73) factor -> LPAREN . expression RPAREN
    (66) expression -> . expression PLUS term
    (67) expression -> . expression MINUS term
    (68) expression -> . term
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    expression                     shift and go to state 81
    term                           shift and go to state 41
    factor                         shift and go to state 48
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 40

    (61) assignment -> CLASSOBJECT . ID
    (96) array -> CLASSOBJECT . LSQBRACKET RSQBRACKET
    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID

    ID              shift and go to state 84
    LSQBRACKET      shift and go to state 85
    DOT             shift and go to state 86


state 41

    (68) expression -> term .
    (69) term -> term . TIMES factor
    (70) term -> term . DIVIDE factor

    PLUS            reduce using rule 68 (expression -> term .)
    MINUS           reduce using rule 68 (expression -> term .)
    SEMICOLON       reduce using rule 68 (expression -> term .)
    RPAREN          reduce using rule 68 (expression -> term .)
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 88


state 42

    (33) if -> IF . LPAREN logical_expression RPAREN block
    (34) if -> IF . LPAREN logical_expression RPAREN block elseif
    (35) if -> IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 89


state 43

    (40) loop -> while_loop .

    SEMICOLON       reduce using rule 40 (loop -> while_loop .)


state 44

    (27) return -> RETURN . ID
    (28) return -> RETURN . type
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE

    ID              shift and go to state 90
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67

    type                           shift and go to state 91

state 45

    (72) factor -> type .

    TIMES           reduce using rule 72 (factor -> type .)
    DIVIDE          reduce using rule 72 (factor -> type .)
    PLUS            reduce using rule 72 (factor -> type .)
    MINUS           reduce using rule 72 (factor -> type .)
    SEMICOLON       reduce using rule 72 (factor -> type .)
    RPAREN          reduce using rule 72 (factor -> type .)


state 46

    (81) data_type -> primitive .
    (95) array -> primitive . LSQBRACKET RSQBRACKET

    ID              reduce using rule 81 (data_type -> primitive .)
    LSQBRACKET      shift and go to state 92


state 47

    (82) data_type -> data_structure .

    ID              reduce using rule 82 (data_type -> data_structure .)


state 48

    (71) term -> factor .

    TIMES           reduce using rule 71 (term -> factor .)
    DIVIDE          reduce using rule 71 (term -> factor .)
    PLUS            reduce using rule 71 (term -> factor .)
    MINUS           reduce using rule 71 (term -> factor .)
    SEMICOLON       reduce using rule 71 (term -> factor .)
    RPAREN          reduce using rule 71 (term -> factor .)


state 49

    (41) while_loop -> WHILE . LPAREN logical_expression RPAREN block

    LPAREN          shift and go to state 93


state 50

    (83) primitive -> INT .

    LSQBRACKET      reduce using rule 83 (primitive -> INT .)
    ID              reduce using rule 83 (primitive -> INT .)


state 51

    (84) primitive -> FLOAT .

    LSQBRACKET      reduce using rule 84 (primitive -> FLOAT .)
    ID              reduce using rule 84 (primitive -> FLOAT .)


state 52

    (85) primitive -> BOOL .

    LSQBRACKET      reduce using rule 85 (primitive -> BOOL .)
    ID              reduce using rule 85 (primitive -> BOOL .)


state 53

    (86) primitive -> BYTE .

    LSQBRACKET      reduce using rule 86 (primitive -> BYTE .)
    ID              reduce using rule 86 (primitive -> BYTE .)


state 54

    (87) primitive -> CHAR .

    LSQBRACKET      reduce using rule 87 (primitive -> CHAR .)
    ID              reduce using rule 87 (primitive -> CHAR .)


state 55

    (88) primitive -> SBYTE .

    LSQBRACKET      reduce using rule 88 (primitive -> SBYTE .)
    ID              reduce using rule 88 (primitive -> SBYTE .)


state 56

    (89) primitive -> DECIMAL .

    LSQBRACKET      reduce using rule 89 (primitive -> DECIMAL .)
    ID              reduce using rule 89 (primitive -> DECIMAL .)


state 57

    (90) primitive -> DOUBLE .

    LSQBRACKET      reduce using rule 90 (primitive -> DOUBLE .)
    ID              reduce using rule 90 (primitive -> DOUBLE .)


state 58

    (91) primitive -> LONG .

    LSQBRACKET      reduce using rule 91 (primitive -> LONG .)
    ID              reduce using rule 91 (primitive -> LONG .)


state 59

    (92) primitive -> SHORT .

    LSQBRACKET      reduce using rule 92 (primitive -> SHORT .)
    ID              reduce using rule 92 (primitive -> SHORT .)


state 60

    (93) primitive -> UINT .

    LSQBRACKET      reduce using rule 93 (primitive -> UINT .)
    ID              reduce using rule 93 (primitive -> UINT .)


state 61

    (94) data_structure -> array .

    ID              reduce using rule 94 (data_structure -> array .)


state 62

    (74) factor -> object_access .

    TIMES           reduce using rule 74 (factor -> object_access .)
    DIVIDE          reduce using rule 74 (factor -> object_access .)
    PLUS            reduce using rule 74 (factor -> object_access .)
    MINUS           reduce using rule 74 (factor -> object_access .)
    SEMICOLON       reduce using rule 74 (factor -> object_access .)
    RPAREN          reduce using rule 74 (factor -> object_access .)


state 63

    (76) factor -> indexing .

    TIMES           reduce using rule 76 (factor -> indexing .)
    DIVIDE          reduce using rule 76 (factor -> indexing .)
    PLUS            reduce using rule 76 (factor -> indexing .)
    MINUS           reduce using rule 76 (factor -> indexing .)
    SEMICOLON       reduce using rule 76 (factor -> indexing .)
    RPAREN          reduce using rule 76 (factor -> indexing .)


state 64

    (29) type -> FLOAT_TYPE .

    TIMES           reduce using rule 29 (type -> FLOAT_TYPE .)
    DIVIDE          reduce using rule 29 (type -> FLOAT_TYPE .)
    PLUS            reduce using rule 29 (type -> FLOAT_TYPE .)
    MINUS           reduce using rule 29 (type -> FLOAT_TYPE .)
    SEMICOLON       reduce using rule 29 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 29 (type -> FLOAT_TYPE .)
    OR              reduce using rule 29 (type -> FLOAT_TYPE .)
    AND             reduce using rule 29 (type -> FLOAT_TYPE .)
    NOT             reduce using rule 29 (type -> FLOAT_TYPE .)
    GREATER_THAN    reduce using rule 29 (type -> FLOAT_TYPE .)
    LESS_THAN       reduce using rule 29 (type -> FLOAT_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 29 (type -> FLOAT_TYPE .)
    LESS_EQUALS_THAN reduce using rule 29 (type -> FLOAT_TYPE .)
    EQUALITY        reduce using rule 29 (type -> FLOAT_TYPE .)


state 65

    (30) type -> DOUBLE_TYPE .

    TIMES           reduce using rule 30 (type -> DOUBLE_TYPE .)
    DIVIDE          reduce using rule 30 (type -> DOUBLE_TYPE .)
    PLUS            reduce using rule 30 (type -> DOUBLE_TYPE .)
    MINUS           reduce using rule 30 (type -> DOUBLE_TYPE .)
    SEMICOLON       reduce using rule 30 (type -> DOUBLE_TYPE .)
    RPAREN          reduce using rule 30 (type -> DOUBLE_TYPE .)
    OR              reduce using rule 30 (type -> DOUBLE_TYPE .)
    AND             reduce using rule 30 (type -> DOUBLE_TYPE .)
    NOT             reduce using rule 30 (type -> DOUBLE_TYPE .)
    GREATER_THAN    reduce using rule 30 (type -> DOUBLE_TYPE .)
    LESS_THAN       reduce using rule 30 (type -> DOUBLE_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 30 (type -> DOUBLE_TYPE .)
    LESS_EQUALS_THAN reduce using rule 30 (type -> DOUBLE_TYPE .)
    EQUALITY        reduce using rule 30 (type -> DOUBLE_TYPE .)


state 66

    (31) type -> DECIMAL_TYPE .

    TIMES           reduce using rule 31 (type -> DECIMAL_TYPE .)
    DIVIDE          reduce using rule 31 (type -> DECIMAL_TYPE .)
    PLUS            reduce using rule 31 (type -> DECIMAL_TYPE .)
    MINUS           reduce using rule 31 (type -> DECIMAL_TYPE .)
    SEMICOLON       reduce using rule 31 (type -> DECIMAL_TYPE .)
    RPAREN          reduce using rule 31 (type -> DECIMAL_TYPE .)
    OR              reduce using rule 31 (type -> DECIMAL_TYPE .)
    AND             reduce using rule 31 (type -> DECIMAL_TYPE .)
    NOT             reduce using rule 31 (type -> DECIMAL_TYPE .)
    GREATER_THAN    reduce using rule 31 (type -> DECIMAL_TYPE .)
    LESS_THAN       reduce using rule 31 (type -> DECIMAL_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 31 (type -> DECIMAL_TYPE .)
    LESS_EQUALS_THAN reduce using rule 31 (type -> DECIMAL_TYPE .)
    EQUALITY        reduce using rule 31 (type -> DECIMAL_TYPE .)


state 67

    (32) type -> INTEGER_TYPE .

    TIMES           reduce using rule 32 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 32 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 32 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 32 (type -> INTEGER_TYPE .)
    SEMICOLON       reduce using rule 32 (type -> INTEGER_TYPE .)
    RPAREN          reduce using rule 32 (type -> INTEGER_TYPE .)
    OR              reduce using rule 32 (type -> INTEGER_TYPE .)
    AND             reduce using rule 32 (type -> INTEGER_TYPE .)
    NOT             reduce using rule 32 (type -> INTEGER_TYPE .)
    GREATER_THAN    reduce using rule 32 (type -> INTEGER_TYPE .)
    LESS_THAN       reduce using rule 32 (type -> INTEGER_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 32 (type -> INTEGER_TYPE .)
    LESS_EQUALS_THAN reduce using rule 32 (type -> INTEGER_TYPE .)
    EQUALITY        reduce using rule 32 (type -> INTEGER_TYPE .)


state 68

    (8) class -> modifier STATIC CLASS CLASSOBJECT block .

    $end            reduce using rule 8 (class -> modifier STATIC CLASS CLASSOBJECT block .)


state 69

    (13) block -> LBRACKET body RBRACKET .

    $end            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    ELSE            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    SEMICOLON       reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 13 (block -> LBRACKET body RBRACKET .)


state 70

    (14) body -> lines SEMICOLON .
    (15) body -> lines SEMICOLON . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . function
    (17) lines -> . assignment
    (18) lines -> . expression
    (19) lines -> . declaration
    (20) lines -> . if
    (21) lines -> . loop
    (22) lines -> . return
    (23) function -> . modifier data_type ID LPAREN declarations RPAREN block
    (24) function -> . modifier VOID ID LPAREN declarations RPAREN block
    (25) function -> . modifier STATIC data_type ID LPAREN declarations RPAREN block
    (26) function -> . modifier STATIC VOID ID LPAREN declarations RPAREN block
    (59) assignment -> . ID EQUALS expression
    (60) assignment -> . data_type ID EQUALS expression
    (61) assignment -> . CLASSOBJECT ID
    (66) expression -> . expression PLUS term
    (67) expression -> . expression MINUS term
    (68) expression -> . term
    (65) declaration -> . data_type ID
    (33) if -> . IF LPAREN logical_expression RPAREN block
    (34) if -> . IF LPAREN logical_expression RPAREN block elseif
    (35) if -> . IF LPAREN logical_expression RPAREN block else
    (40) loop -> . while_loop
    (27) return -> . RETURN ID
    (28) return -> . RETURN type
    (77) modifier -> . PUBLIC
    (78) modifier -> . PRIVATE
    (79) modifier -> . PROTECTED
    (80) modifier -> . INTERNAL
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (41) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    RBRACKET        reduce using rule 14 (body -> lines SEMICOLON .)
    ID              shift and go to state 38
    CLASSOBJECT     shift and go to state 40
    IF              shift and go to state 42
    RETURN          shift and go to state 44
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    WHILE           shift and go to state 49
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    LPAREN          shift and go to state 39
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67

    lines                          shift and go to state 28
    body                           shift and go to state 94
    function                       shift and go to state 29
    assignment                     shift and go to state 30
    expression                     shift and go to state 31
    declaration                    shift and go to state 32
    if                             shift and go to state 33
    loop                           shift and go to state 34
    return                         shift and go to state 35
    modifier                       shift and go to state 36
    data_type                      shift and go to state 37
    term                           shift and go to state 41
    while_loop                     shift and go to state 43
    type                           shift and go to state 45
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    factor                         shift and go to state 48
    array                          shift and go to state 61
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 71

    (66) expression -> expression PLUS . term
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    term                           shift and go to state 95
    factor                         shift and go to state 48
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 72

    (67) expression -> expression MINUS . term
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    term                           shift and go to state 96
    factor                         shift and go to state 48
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 73

    (23) function -> modifier data_type . ID LPAREN declarations RPAREN block

    ID              shift and go to state 97


state 74

    (24) function -> modifier VOID . ID LPAREN declarations RPAREN block

    ID              shift and go to state 98


state 75

    (25) function -> modifier STATIC . data_type ID LPAREN declarations RPAREN block
    (26) function -> modifier STATIC . VOID ID LPAREN declarations RPAREN block
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 100
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    data_type                      shift and go to state 99
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 76

    (96) array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    LSQBRACKET      shift and go to state 85


state 77

    (60) assignment -> data_type ID . EQUALS expression
    (65) declaration -> data_type ID .

    EQUALS          shift and go to state 101
    SEMICOLON       reduce using rule 65 (declaration -> data_type ID .)


state 78

    (59) assignment -> ID EQUALS . expression
    (66) expression -> . expression PLUS term
    (67) expression -> . expression MINUS term
    (68) expression -> . term
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    expression                     shift and go to state 102
    term                           shift and go to state 41
    factor                         shift and go to state 48
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 79

    (9) object_access -> ID DOT . ID
    (11) object_access -> ID DOT . CLASSOBJECT

    ID              shift and go to state 103
    CLASSOBJECT     shift and go to state 104


state 80

    (97) indexing -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (98) indexing -> ID LSQBRACKET . ID RSQBRACKET

    INTEGER_TYPE    shift and go to state 106
    ID              shift and go to state 105


state 81

    (73) factor -> LPAREN expression . RPAREN
    (66) expression -> expression . PLUS term
    (67) expression -> expression . MINUS term

    RPAREN          shift and go to state 107
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 82

    (75) factor -> ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> ID . LSQBRACKET ID RSQBRACKET

    TIMES           reduce using rule 75 (factor -> ID .)
    DIVIDE          reduce using rule 75 (factor -> ID .)
    RPAREN          reduce using rule 75 (factor -> ID .)
    PLUS            reduce using rule 75 (factor -> ID .)
    MINUS           reduce using rule 75 (factor -> ID .)
    SEMICOLON       reduce using rule 75 (factor -> ID .)
    DOT             shift and go to state 79
    LSQBRACKET      shift and go to state 80


state 83

    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID

    DOT             shift and go to state 86


state 84

    (61) assignment -> CLASSOBJECT ID .

    SEMICOLON       reduce using rule 61 (assignment -> CLASSOBJECT ID .)


state 85

    (96) array -> CLASSOBJECT LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 108


state 86

    (10) object_access -> CLASSOBJECT DOT . CLASSOBJECT
    (12) object_access -> CLASSOBJECT DOT . ID

    CLASSOBJECT     shift and go to state 109
    ID              shift and go to state 110


state 87

    (69) term -> term TIMES . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    factor                         shift and go to state 111
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 88

    (70) term -> term DIVIDE . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    factor                         shift and go to state 112
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 89

    (33) if -> IF LPAREN . logical_expression RPAREN block
    (34) if -> IF LPAREN . logical_expression RPAREN block elseif
    (35) if -> IF LPAREN . logical_expression RPAREN block else
    (42) logical_expression -> . logical_expression logical_operator logical_factor
    (43) logical_expression -> . logical_factor
    (44) logical_factor -> . TRUE
    (45) logical_factor -> . FALSE
    (46) logical_factor -> . ID
    (47) logical_factor -> . indexing
    (48) logical_factor -> . type
    (49) logical_factor -> . object_access
    (50) logical_factor -> . LPAREN logical_expression RPAREN
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118
    LPAREN          shift and go to state 113
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    logical_expression             shift and go to state 114
    logical_factor                 shift and go to state 115
    indexing                       shift and go to state 119
    type                           shift and go to state 120
    object_access                  shift and go to state 121

state 90

    (27) return -> RETURN ID .

    SEMICOLON       reduce using rule 27 (return -> RETURN ID .)


state 91

    (28) return -> RETURN type .

    SEMICOLON       reduce using rule 28 (return -> RETURN type .)


state 92

    (95) array -> primitive LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 122


state 93

    (41) while_loop -> WHILE LPAREN . logical_expression RPAREN block
    (42) logical_expression -> . logical_expression logical_operator logical_factor
    (43) logical_expression -> . logical_factor
    (44) logical_factor -> . TRUE
    (45) logical_factor -> . FALSE
    (46) logical_factor -> . ID
    (47) logical_factor -> . indexing
    (48) logical_factor -> . type
    (49) logical_factor -> . object_access
    (50) logical_factor -> . LPAREN logical_expression RPAREN
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118
    LPAREN          shift and go to state 113
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    logical_expression             shift and go to state 123
    logical_factor                 shift and go to state 115
    indexing                       shift and go to state 119
    type                           shift and go to state 120
    object_access                  shift and go to state 121

state 94

    (15) body -> lines SEMICOLON body .

    RBRACKET        reduce using rule 15 (body -> lines SEMICOLON body .)


state 95

    (66) expression -> expression PLUS term .
    (69) term -> term . TIMES factor
    (70) term -> term . DIVIDE factor

    PLUS            reduce using rule 66 (expression -> expression PLUS term .)
    MINUS           reduce using rule 66 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 66 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 66 (expression -> expression PLUS term .)
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 88


state 96

    (67) expression -> expression MINUS term .
    (69) term -> term . TIMES factor
    (70) term -> term . DIVIDE factor

    PLUS            reduce using rule 67 (expression -> expression MINUS term .)
    MINUS           reduce using rule 67 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 67 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 67 (expression -> expression MINUS term .)
    TIMES           shift and go to state 87
    DIVIDE          shift and go to state 88


state 97

    (23) function -> modifier data_type ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 124


state 98

    (24) function -> modifier VOID ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 125


state 99

    (25) function -> modifier STATIC data_type . ID LPAREN declarations RPAREN block

    ID              shift and go to state 126


state 100

    (26) function -> modifier STATIC VOID . ID LPAREN declarations RPAREN block

    ID              shift and go to state 127


state 101

    (60) assignment -> data_type ID EQUALS . expression
    (66) expression -> . expression PLUS term
    (67) expression -> . expression MINUS term
    (68) expression -> . term
    (69) term -> . term TIMES factor
    (70) term -> . term DIVIDE factor
    (71) term -> . factor
    (72) factor -> . type
    (73) factor -> . LPAREN expression RPAREN
    (74) factor -> . object_access
    (75) factor -> . ID
    (76) factor -> . indexing
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET

    LPAREN          shift and go to state 39
    ID              shift and go to state 82
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    expression                     shift and go to state 128
    term                           shift and go to state 41
    factor                         shift and go to state 48
    type                           shift and go to state 45
    object_access                  shift and go to state 62
    indexing                       shift and go to state 63

state 102

    (59) assignment -> ID EQUALS expression .
    (66) expression -> expression . PLUS term
    (67) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 59 (assignment -> ID EQUALS expression .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 103

    (9) object_access -> ID DOT ID .

    TIMES           reduce using rule 9 (object_access -> ID DOT ID .)
    DIVIDE          reduce using rule 9 (object_access -> ID DOT ID .)
    PLUS            reduce using rule 9 (object_access -> ID DOT ID .)
    MINUS           reduce using rule 9 (object_access -> ID DOT ID .)
    SEMICOLON       reduce using rule 9 (object_access -> ID DOT ID .)
    RPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    OR              reduce using rule 9 (object_access -> ID DOT ID .)
    AND             reduce using rule 9 (object_access -> ID DOT ID .)
    NOT             reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_THAN    reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_THAN       reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    EQUALITY        reduce using rule 9 (object_access -> ID DOT ID .)


state 104

    (11) object_access -> ID DOT CLASSOBJECT .

    TIMES           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    PLUS            reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    MINUS           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    RPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    OR              reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    AND             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    NOT             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)


state 105

    (98) indexing -> ID LSQBRACKET ID . RSQBRACKET

    RSQBRACKET      shift and go to state 129


state 106

    (97) indexing -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET

    RSQBRACKET      shift and go to state 130


state 107

    (73) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 73 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 73 (factor -> LPAREN expression RPAREN .)


state 108

    (96) array -> CLASSOBJECT LSQBRACKET RSQBRACKET .

    ID              reduce using rule 96 (array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)


state 109

    (10) object_access -> CLASSOBJECT DOT CLASSOBJECT .

    TIMES           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    PLUS            reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    MINUS           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    RPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    OR              reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    AND             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    NOT             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)


state 110

    (12) object_access -> CLASSOBJECT DOT ID .

    TIMES           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    DIVIDE          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    PLUS            reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    MINUS           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    SEMICOLON       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    RPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    OR              reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    AND             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    NOT             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_THAN    reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_THAN       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    EQUALITY        reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)


state 111

    (69) term -> term TIMES factor .

    TIMES           reduce using rule 69 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 69 (term -> term TIMES factor .)
    PLUS            reduce using rule 69 (term -> term TIMES factor .)
    MINUS           reduce using rule 69 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 69 (term -> term TIMES factor .)
    RPAREN          reduce using rule 69 (term -> term TIMES factor .)


state 112

    (70) term -> term DIVIDE factor .

    TIMES           reduce using rule 70 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 70 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 70 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 70 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 70 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 70 (term -> term DIVIDE factor .)


state 113

    (50) logical_factor -> LPAREN . logical_expression RPAREN
    (42) logical_expression -> . logical_expression logical_operator logical_factor
    (43) logical_expression -> . logical_factor
    (44) logical_factor -> . TRUE
    (45) logical_factor -> . FALSE
    (46) logical_factor -> . ID
    (47) logical_factor -> . indexing
    (48) logical_factor -> . type
    (49) logical_factor -> . object_access
    (50) logical_factor -> . LPAREN logical_expression RPAREN
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118
    LPAREN          shift and go to state 113
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    logical_expression             shift and go to state 131
    logical_factor                 shift and go to state 115
    indexing                       shift and go to state 119
    type                           shift and go to state 120
    object_access                  shift and go to state 121

state 114

    (33) if -> IF LPAREN logical_expression . RPAREN block
    (34) if -> IF LPAREN logical_expression . RPAREN block elseif
    (35) if -> IF LPAREN logical_expression . RPAREN block else
    (42) logical_expression -> logical_expression . logical_operator logical_factor
    (51) logical_operator -> . OR
    (52) logical_operator -> . AND
    (53) logical_operator -> . NOT
    (54) logical_operator -> . GREATER_THAN
    (55) logical_operator -> . LESS_THAN
    (56) logical_operator -> . GREATER_EQUALS_THAN
    (57) logical_operator -> . LESS_EQUALS_THAN
    (58) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 132
    OR              shift and go to state 134
    AND             shift and go to state 135
    NOT             shift and go to state 136
    GREATER_THAN    shift and go to state 137
    LESS_THAN       shift and go to state 138
    GREATER_EQUALS_THAN shift and go to state 139
    LESS_EQUALS_THAN shift and go to state 140
    EQUALITY        shift and go to state 141

    logical_operator               shift and go to state 133

state 115

    (43) logical_expression -> logical_factor .

    RPAREN          reduce using rule 43 (logical_expression -> logical_factor .)
    OR              reduce using rule 43 (logical_expression -> logical_factor .)
    AND             reduce using rule 43 (logical_expression -> logical_factor .)
    NOT             reduce using rule 43 (logical_expression -> logical_factor .)
    GREATER_THAN    reduce using rule 43 (logical_expression -> logical_factor .)
    LESS_THAN       reduce using rule 43 (logical_expression -> logical_factor .)
    GREATER_EQUALS_THAN reduce using rule 43 (logical_expression -> logical_factor .)
    LESS_EQUALS_THAN reduce using rule 43 (logical_expression -> logical_factor .)
    EQUALITY        reduce using rule 43 (logical_expression -> logical_factor .)


state 116

    (44) logical_factor -> TRUE .

    RPAREN          reduce using rule 44 (logical_factor -> TRUE .)
    OR              reduce using rule 44 (logical_factor -> TRUE .)
    AND             reduce using rule 44 (logical_factor -> TRUE .)
    NOT             reduce using rule 44 (logical_factor -> TRUE .)
    GREATER_THAN    reduce using rule 44 (logical_factor -> TRUE .)
    LESS_THAN       reduce using rule 44 (logical_factor -> TRUE .)
    GREATER_EQUALS_THAN reduce using rule 44 (logical_factor -> TRUE .)
    LESS_EQUALS_THAN reduce using rule 44 (logical_factor -> TRUE .)
    EQUALITY        reduce using rule 44 (logical_factor -> TRUE .)


state 117

    (45) logical_factor -> FALSE .

    RPAREN          reduce using rule 45 (logical_factor -> FALSE .)
    OR              reduce using rule 45 (logical_factor -> FALSE .)
    AND             reduce using rule 45 (logical_factor -> FALSE .)
    NOT             reduce using rule 45 (logical_factor -> FALSE .)
    GREATER_THAN    reduce using rule 45 (logical_factor -> FALSE .)
    LESS_THAN       reduce using rule 45 (logical_factor -> FALSE .)
    GREATER_EQUALS_THAN reduce using rule 45 (logical_factor -> FALSE .)
    LESS_EQUALS_THAN reduce using rule 45 (logical_factor -> FALSE .)
    EQUALITY        reduce using rule 45 (logical_factor -> FALSE .)


state 118

    (46) logical_factor -> ID .
    (97) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT

    RPAREN          reduce using rule 46 (logical_factor -> ID .)
    OR              reduce using rule 46 (logical_factor -> ID .)
    AND             reduce using rule 46 (logical_factor -> ID .)
    NOT             reduce using rule 46 (logical_factor -> ID .)
    GREATER_THAN    reduce using rule 46 (logical_factor -> ID .)
    LESS_THAN       reduce using rule 46 (logical_factor -> ID .)
    GREATER_EQUALS_THAN reduce using rule 46 (logical_factor -> ID .)
    LESS_EQUALS_THAN reduce using rule 46 (logical_factor -> ID .)
    EQUALITY        reduce using rule 46 (logical_factor -> ID .)
    LSQBRACKET      shift and go to state 80
    DOT             shift and go to state 79


state 119

    (47) logical_factor -> indexing .

    RPAREN          reduce using rule 47 (logical_factor -> indexing .)
    OR              reduce using rule 47 (logical_factor -> indexing .)
    AND             reduce using rule 47 (logical_factor -> indexing .)
    NOT             reduce using rule 47 (logical_factor -> indexing .)
    GREATER_THAN    reduce using rule 47 (logical_factor -> indexing .)
    LESS_THAN       reduce using rule 47 (logical_factor -> indexing .)
    GREATER_EQUALS_THAN reduce using rule 47 (logical_factor -> indexing .)
    LESS_EQUALS_THAN reduce using rule 47 (logical_factor -> indexing .)
    EQUALITY        reduce using rule 47 (logical_factor -> indexing .)


state 120

    (48) logical_factor -> type .

    RPAREN          reduce using rule 48 (logical_factor -> type .)
    OR              reduce using rule 48 (logical_factor -> type .)
    AND             reduce using rule 48 (logical_factor -> type .)
    NOT             reduce using rule 48 (logical_factor -> type .)
    GREATER_THAN    reduce using rule 48 (logical_factor -> type .)
    LESS_THAN       reduce using rule 48 (logical_factor -> type .)
    GREATER_EQUALS_THAN reduce using rule 48 (logical_factor -> type .)
    LESS_EQUALS_THAN reduce using rule 48 (logical_factor -> type .)
    EQUALITY        reduce using rule 48 (logical_factor -> type .)


state 121

    (49) logical_factor -> object_access .

    RPAREN          reduce using rule 49 (logical_factor -> object_access .)
    OR              reduce using rule 49 (logical_factor -> object_access .)
    AND             reduce using rule 49 (logical_factor -> object_access .)
    NOT             reduce using rule 49 (logical_factor -> object_access .)
    GREATER_THAN    reduce using rule 49 (logical_factor -> object_access .)
    LESS_THAN       reduce using rule 49 (logical_factor -> object_access .)
    GREATER_EQUALS_THAN reduce using rule 49 (logical_factor -> object_access .)
    LESS_EQUALS_THAN reduce using rule 49 (logical_factor -> object_access .)
    EQUALITY        reduce using rule 49 (logical_factor -> object_access .)


state 122

    (95) array -> primitive LSQBRACKET RSQBRACKET .

    ID              reduce using rule 95 (array -> primitive LSQBRACKET RSQBRACKET .)


state 123

    (41) while_loop -> WHILE LPAREN logical_expression . RPAREN block
    (42) logical_expression -> logical_expression . logical_operator logical_factor
    (51) logical_operator -> . OR
    (52) logical_operator -> . AND
    (53) logical_operator -> . NOT
    (54) logical_operator -> . GREATER_THAN
    (55) logical_operator -> . LESS_THAN
    (56) logical_operator -> . GREATER_EQUALS_THAN
    (57) logical_operator -> . LESS_EQUALS_THAN
    (58) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 142
    OR              shift and go to state 134
    AND             shift and go to state 135
    NOT             shift and go to state 136
    GREATER_THAN    shift and go to state 137
    LESS_THAN       shift and go to state 138
    GREATER_EQUALS_THAN shift and go to state 139
    LESS_EQUALS_THAN shift and go to state 140
    EQUALITY        shift and go to state 141

    logical_operator               shift and go to state 133

state 124

    (23) function -> modifier data_type ID LPAREN . declarations RPAREN block
    (62) declarations -> . declaration
    (63) declarations -> . declaration COMMA
    (64) declarations -> . declaration COMMA declarations
    (65) declaration -> . data_type ID
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    data_type                      shift and go to state 143
    declarations                   shift and go to state 144
    declaration                    shift and go to state 145
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 125

    (24) function -> modifier VOID ID LPAREN . declarations RPAREN block
    (62) declarations -> . declaration
    (63) declarations -> . declaration COMMA
    (64) declarations -> . declaration COMMA declarations
    (65) declaration -> . data_type ID
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    declarations                   shift and go to state 146
    declaration                    shift and go to state 145
    data_type                      shift and go to state 143
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 126

    (25) function -> modifier STATIC data_type ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 147


state 127

    (26) function -> modifier STATIC VOID ID . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 148


state 128

    (60) assignment -> data_type ID EQUALS expression .
    (66) expression -> expression . PLUS term
    (67) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 60 (assignment -> data_type ID EQUALS expression .)
    PLUS            shift and go to state 71
    MINUS           shift and go to state 72


state 129

    (98) indexing -> ID LSQBRACKET ID RSQBRACKET .

    TIMES           reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    DIVIDE          reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    PLUS            reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    MINUS           reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    SEMICOLON       reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    RPAREN          reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    OR              reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    AND             reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    NOT             reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_THAN    reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_THAN       reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    EQUALITY        reduce using rule 98 (indexing -> ID LSQBRACKET ID RSQBRACKET .)


state 130

    (97) indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .

    TIMES           reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    DIVIDE          reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    PLUS            reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    MINUS           reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    SEMICOLON       reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    RPAREN          reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    OR              reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    AND             reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    NOT             reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_THAN    reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_THAN       reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    EQUALITY        reduce using rule 97 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)


state 131

    (50) logical_factor -> LPAREN logical_expression . RPAREN
    (42) logical_expression -> logical_expression . logical_operator logical_factor
    (51) logical_operator -> . OR
    (52) logical_operator -> . AND
    (53) logical_operator -> . NOT
    (54) logical_operator -> . GREATER_THAN
    (55) logical_operator -> . LESS_THAN
    (56) logical_operator -> . GREATER_EQUALS_THAN
    (57) logical_operator -> . LESS_EQUALS_THAN
    (58) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 149
    OR              shift and go to state 134
    AND             shift and go to state 135
    NOT             shift and go to state 136
    GREATER_THAN    shift and go to state 137
    LESS_THAN       shift and go to state 138
    GREATER_EQUALS_THAN shift and go to state 139
    LESS_EQUALS_THAN shift and go to state 140
    EQUALITY        shift and go to state 141

    logical_operator               shift and go to state 133

state 132

    (33) if -> IF LPAREN logical_expression RPAREN . block
    (34) if -> IF LPAREN logical_expression RPAREN . block elseif
    (35) if -> IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 150

state 133

    (42) logical_expression -> logical_expression logical_operator . logical_factor
    (44) logical_factor -> . TRUE
    (45) logical_factor -> . FALSE
    (46) logical_factor -> . ID
    (47) logical_factor -> . indexing
    (48) logical_factor -> . type
    (49) logical_factor -> . object_access
    (50) logical_factor -> . LPAREN logical_expression RPAREN
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118
    LPAREN          shift and go to state 113
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    logical_factor                 shift and go to state 151
    indexing                       shift and go to state 119
    type                           shift and go to state 120
    object_access                  shift and go to state 121

state 134

    (51) logical_operator -> OR .

    TRUE            reduce using rule 51 (logical_operator -> OR .)
    FALSE           reduce using rule 51 (logical_operator -> OR .)
    ID              reduce using rule 51 (logical_operator -> OR .)
    LPAREN          reduce using rule 51 (logical_operator -> OR .)
    FLOAT_TYPE      reduce using rule 51 (logical_operator -> OR .)
    DOUBLE_TYPE     reduce using rule 51 (logical_operator -> OR .)
    DECIMAL_TYPE    reduce using rule 51 (logical_operator -> OR .)
    INTEGER_TYPE    reduce using rule 51 (logical_operator -> OR .)
    CLASSOBJECT     reduce using rule 51 (logical_operator -> OR .)


state 135

    (52) logical_operator -> AND .

    TRUE            reduce using rule 52 (logical_operator -> AND .)
    FALSE           reduce using rule 52 (logical_operator -> AND .)
    ID              reduce using rule 52 (logical_operator -> AND .)
    LPAREN          reduce using rule 52 (logical_operator -> AND .)
    FLOAT_TYPE      reduce using rule 52 (logical_operator -> AND .)
    DOUBLE_TYPE     reduce using rule 52 (logical_operator -> AND .)
    DECIMAL_TYPE    reduce using rule 52 (logical_operator -> AND .)
    INTEGER_TYPE    reduce using rule 52 (logical_operator -> AND .)
    CLASSOBJECT     reduce using rule 52 (logical_operator -> AND .)


state 136

    (53) logical_operator -> NOT .

    TRUE            reduce using rule 53 (logical_operator -> NOT .)
    FALSE           reduce using rule 53 (logical_operator -> NOT .)
    ID              reduce using rule 53 (logical_operator -> NOT .)
    LPAREN          reduce using rule 53 (logical_operator -> NOT .)
    FLOAT_TYPE      reduce using rule 53 (logical_operator -> NOT .)
    DOUBLE_TYPE     reduce using rule 53 (logical_operator -> NOT .)
    DECIMAL_TYPE    reduce using rule 53 (logical_operator -> NOT .)
    INTEGER_TYPE    reduce using rule 53 (logical_operator -> NOT .)
    CLASSOBJECT     reduce using rule 53 (logical_operator -> NOT .)


state 137

    (54) logical_operator -> GREATER_THAN .

    TRUE            reduce using rule 54 (logical_operator -> GREATER_THAN .)
    FALSE           reduce using rule 54 (logical_operator -> GREATER_THAN .)
    ID              reduce using rule 54 (logical_operator -> GREATER_THAN .)
    LPAREN          reduce using rule 54 (logical_operator -> GREATER_THAN .)
    FLOAT_TYPE      reduce using rule 54 (logical_operator -> GREATER_THAN .)
    DOUBLE_TYPE     reduce using rule 54 (logical_operator -> GREATER_THAN .)
    DECIMAL_TYPE    reduce using rule 54 (logical_operator -> GREATER_THAN .)
    INTEGER_TYPE    reduce using rule 54 (logical_operator -> GREATER_THAN .)
    CLASSOBJECT     reduce using rule 54 (logical_operator -> GREATER_THAN .)


state 138

    (55) logical_operator -> LESS_THAN .

    TRUE            reduce using rule 55 (logical_operator -> LESS_THAN .)
    FALSE           reduce using rule 55 (logical_operator -> LESS_THAN .)
    ID              reduce using rule 55 (logical_operator -> LESS_THAN .)
    LPAREN          reduce using rule 55 (logical_operator -> LESS_THAN .)
    FLOAT_TYPE      reduce using rule 55 (logical_operator -> LESS_THAN .)
    DOUBLE_TYPE     reduce using rule 55 (logical_operator -> LESS_THAN .)
    DECIMAL_TYPE    reduce using rule 55 (logical_operator -> LESS_THAN .)
    INTEGER_TYPE    reduce using rule 55 (logical_operator -> LESS_THAN .)
    CLASSOBJECT     reduce using rule 55 (logical_operator -> LESS_THAN .)


state 139

    (56) logical_operator -> GREATER_EQUALS_THAN .

    TRUE            reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    FALSE           reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    ID              reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    LPAREN          reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 56 (logical_operator -> GREATER_EQUALS_THAN .)


state 140

    (57) logical_operator -> LESS_EQUALS_THAN .

    TRUE            reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    FALSE           reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    ID              reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    LPAREN          reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 57 (logical_operator -> LESS_EQUALS_THAN .)


state 141

    (58) logical_operator -> EQUALITY .

    TRUE            reduce using rule 58 (logical_operator -> EQUALITY .)
    FALSE           reduce using rule 58 (logical_operator -> EQUALITY .)
    ID              reduce using rule 58 (logical_operator -> EQUALITY .)
    LPAREN          reduce using rule 58 (logical_operator -> EQUALITY .)
    FLOAT_TYPE      reduce using rule 58 (logical_operator -> EQUALITY .)
    DOUBLE_TYPE     reduce using rule 58 (logical_operator -> EQUALITY .)
    DECIMAL_TYPE    reduce using rule 58 (logical_operator -> EQUALITY .)
    INTEGER_TYPE    reduce using rule 58 (logical_operator -> EQUALITY .)
    CLASSOBJECT     reduce using rule 58 (logical_operator -> EQUALITY .)


state 142

    (41) while_loop -> WHILE LPAREN logical_expression RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 152

state 143

    (65) declaration -> data_type . ID

    ID              shift and go to state 153


state 144

    (23) function -> modifier data_type ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 154


state 145

    (62) declarations -> declaration .
    (63) declarations -> declaration . COMMA
    (64) declarations -> declaration . COMMA declarations

    RPAREN          reduce using rule 62 (declarations -> declaration .)
    COMMA           shift and go to state 155


state 146

    (24) function -> modifier VOID ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 156


state 147

    (25) function -> modifier STATIC data_type ID LPAREN . declarations RPAREN block
    (62) declarations -> . declaration
    (63) declarations -> . declaration COMMA
    (64) declarations -> . declaration COMMA declarations
    (65) declaration -> . data_type ID
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    data_type                      shift and go to state 143
    declarations                   shift and go to state 157
    declaration                    shift and go to state 145
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 148

    (26) function -> modifier STATIC VOID ID LPAREN . declarations RPAREN block
    (62) declarations -> . declaration
    (63) declarations -> . declaration COMMA
    (64) declarations -> . declaration COMMA declarations
    (65) declaration -> . data_type ID
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    declarations                   shift and go to state 158
    declaration                    shift and go to state 145
    data_type                      shift and go to state 143
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 149

    (50) logical_factor -> LPAREN logical_expression RPAREN .

    RPAREN          reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    OR              reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    AND             reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    NOT             reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_THAN    reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_THAN       reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_EQUALS_THAN reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_EQUALS_THAN reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)
    EQUALITY        reduce using rule 50 (logical_factor -> LPAREN logical_expression RPAREN .)


state 150

    (33) if -> IF LPAREN logical_expression RPAREN block .
    (34) if -> IF LPAREN logical_expression RPAREN block . elseif
    (35) if -> IF LPAREN logical_expression RPAREN block . else
    (36) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (37) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (38) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (39) else -> . ELSE block

    SEMICOLON       reduce using rule 33 (if -> IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 161

    elseif                         shift and go to state 159
    else                           shift and go to state 160

state 151

    (42) logical_expression -> logical_expression logical_operator logical_factor .

    RPAREN          reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    OR              reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    AND             reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    NOT             reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    GREATER_THAN    reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    LESS_THAN       reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    GREATER_EQUALS_THAN reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    LESS_EQUALS_THAN reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)
    EQUALITY        reduce using rule 42 (logical_expression -> logical_expression logical_operator logical_factor .)


state 152

    (41) while_loop -> WHILE LPAREN logical_expression RPAREN block .

    SEMICOLON       reduce using rule 41 (while_loop -> WHILE LPAREN logical_expression RPAREN block .)


state 153

    (65) declaration -> data_type ID .

    COMMA           reduce using rule 65 (declaration -> data_type ID .)
    RPAREN          reduce using rule 65 (declaration -> data_type ID .)


state 154

    (23) function -> modifier data_type ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 162

state 155

    (63) declarations -> declaration COMMA .
    (64) declarations -> declaration COMMA . declarations
    (62) declarations -> . declaration
    (63) declarations -> . declaration COMMA
    (64) declarations -> . declaration COMMA declarations
    (65) declaration -> . data_type ID
    (81) data_type -> . primitive
    (82) data_type -> . data_structure
    (83) primitive -> . INT
    (84) primitive -> . FLOAT
    (85) primitive -> . BOOL
    (86) primitive -> . BYTE
    (87) primitive -> . CHAR
    (88) primitive -> . SBYTE
    (89) primitive -> . DECIMAL
    (90) primitive -> . DOUBLE
    (91) primitive -> . LONG
    (92) primitive -> . SHORT
    (93) primitive -> . UINT
    (94) data_structure -> . array
    (95) array -> . primitive LSQBRACKET RSQBRACKET
    (96) array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    RPAREN          reduce using rule 63 (declarations -> declaration COMMA .)
    INT             shift and go to state 50
    FLOAT           shift and go to state 51
    BOOL            shift and go to state 52
    BYTE            shift and go to state 53
    CHAR            shift and go to state 54
    SBYTE           shift and go to state 55
    DECIMAL         shift and go to state 56
    DOUBLE          shift and go to state 57
    LONG            shift and go to state 58
    SHORT           shift and go to state 59
    UINT            shift and go to state 60
    CLASSOBJECT     shift and go to state 76

    declaration                    shift and go to state 145
    declarations                   shift and go to state 163
    data_type                      shift and go to state 143
    primitive                      shift and go to state 46
    data_structure                 shift and go to state 47
    array                          shift and go to state 61

state 156

    (24) function -> modifier VOID ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 164

state 157

    (25) function -> modifier STATIC data_type ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 165


state 158

    (26) function -> modifier STATIC VOID ID LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 166


state 159

    (34) if -> IF LPAREN logical_expression RPAREN block elseif .

    SEMICOLON       reduce using rule 34 (if -> IF LPAREN logical_expression RPAREN block elseif .)


state 160

    (35) if -> IF LPAREN logical_expression RPAREN block else .

    SEMICOLON       reduce using rule 35 (if -> IF LPAREN logical_expression RPAREN block else .)


state 161

    (36) elseif -> ELSE . IF LPAREN logical_expression RPAREN block
    (37) elseif -> ELSE . IF LPAREN logical_expression RPAREN block elseif
    (38) elseif -> ELSE . IF LPAREN logical_expression RPAREN block else
    (39) else -> ELSE . block
    (13) block -> . LBRACKET body RBRACKET

    IF              shift and go to state 167
    LBRACKET        shift and go to state 25

    block                          shift and go to state 168

state 162

    (23) function -> modifier data_type ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 23 (function -> modifier data_type ID LPAREN declarations RPAREN block .)


state 163

    (64) declarations -> declaration COMMA declarations .

    RPAREN          reduce using rule 64 (declarations -> declaration COMMA declarations .)


state 164

    (24) function -> modifier VOID ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 24 (function -> modifier VOID ID LPAREN declarations RPAREN block .)


state 165

    (25) function -> modifier STATIC data_type ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 169

state 166

    (26) function -> modifier STATIC VOID ID LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 170

state 167

    (36) elseif -> ELSE IF . LPAREN logical_expression RPAREN block
    (37) elseif -> ELSE IF . LPAREN logical_expression RPAREN block elseif
    (38) elseif -> ELSE IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 171


state 168

    (39) else -> ELSE block .

    SEMICOLON       reduce using rule 39 (else -> ELSE block .)


state 169

    (25) function -> modifier STATIC data_type ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 25 (function -> modifier STATIC data_type ID LPAREN declarations RPAREN block .)


state 170

    (26) function -> modifier STATIC VOID ID LPAREN declarations RPAREN block .

    RBRACKET        reduce using rule 26 (function -> modifier STATIC VOID ID LPAREN declarations RPAREN block .)


state 171

    (36) elseif -> ELSE IF LPAREN . logical_expression RPAREN block
    (37) elseif -> ELSE IF LPAREN . logical_expression RPAREN block elseif
    (38) elseif -> ELSE IF LPAREN . logical_expression RPAREN block else
    (42) logical_expression -> . logical_expression logical_operator logical_factor
    (43) logical_expression -> . logical_factor
    (44) logical_factor -> . TRUE
    (45) logical_factor -> . FALSE
    (46) logical_factor -> . ID
    (47) logical_factor -> . indexing
    (48) logical_factor -> . type
    (49) logical_factor -> . object_access
    (50) logical_factor -> . LPAREN logical_expression RPAREN
    (97) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (98) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (29) type -> . FLOAT_TYPE
    (30) type -> . DOUBLE_TYPE
    (31) type -> . DECIMAL_TYPE
    (32) type -> . INTEGER_TYPE
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118
    LPAREN          shift and go to state 113
    FLOAT_TYPE      shift and go to state 64
    DOUBLE_TYPE     shift and go to state 65
    DECIMAL_TYPE    shift and go to state 66
    INTEGER_TYPE    shift and go to state 67
    CLASSOBJECT     shift and go to state 83

    logical_expression             shift and go to state 172
    logical_factor                 shift and go to state 115
    indexing                       shift and go to state 119
    type                           shift and go to state 120
    object_access                  shift and go to state 121

state 172

    (36) elseif -> ELSE IF LPAREN logical_expression . RPAREN block
    (37) elseif -> ELSE IF LPAREN logical_expression . RPAREN block elseif
    (38) elseif -> ELSE IF LPAREN logical_expression . RPAREN block else
    (42) logical_expression -> logical_expression . logical_operator logical_factor
    (51) logical_operator -> . OR
    (52) logical_operator -> . AND
    (53) logical_operator -> . NOT
    (54) logical_operator -> . GREATER_THAN
    (55) logical_operator -> . LESS_THAN
    (56) logical_operator -> . GREATER_EQUALS_THAN
    (57) logical_operator -> . LESS_EQUALS_THAN
    (58) logical_operator -> . EQUALITY

    RPAREN          shift and go to state 173
    OR              shift and go to state 134
    AND             shift and go to state 135
    NOT             shift and go to state 136
    GREATER_THAN    shift and go to state 137
    LESS_THAN       shift and go to state 138
    GREATER_EQUALS_THAN shift and go to state 139
    LESS_EQUALS_THAN shift and go to state 140
    EQUALITY        shift and go to state 141

    logical_operator               shift and go to state 133

state 173

    (36) elseif -> ELSE IF LPAREN logical_expression RPAREN . block
    (37) elseif -> ELSE IF LPAREN logical_expression RPAREN . block elseif
    (38) elseif -> ELSE IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 174

state 174

    (36) elseif -> ELSE IF LPAREN logical_expression RPAREN block .
    (37) elseif -> ELSE IF LPAREN logical_expression RPAREN block . elseif
    (38) elseif -> ELSE IF LPAREN logical_expression RPAREN block . else
    (36) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (37) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (38) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (39) else -> . ELSE block

    SEMICOLON       reduce using rule 36 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 161

    elseif                         shift and go to state 175
    else                           shift and go to state 176

state 175

    (37) elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .

    SEMICOLON       reduce using rule 37 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)


state 176

    (38) elseif -> ELSE IF LPAREN logical_expression RPAREN block else .

    SEMICOLON       reduce using rule 38 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)

