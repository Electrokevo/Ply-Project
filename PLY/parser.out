Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    CHARACTER
    DIVIDE_EQUAL
    DO
    FILE
    IN
    MINUS_EQUAL
    MODULE
    MODULE_EQUAL
    NEW
    NINT
    NUINT
    PLUS_EQUAL
    THEN
    TIMES_EQUAL
    ULONG
    USHORT
    VAR

Grammar

Rule 0     S' -> program
Rule 1     program -> usings namespace class
Rule 2     program -> namespace class
Rule 3     usings -> using usings
Rule 4     usings -> using
Rule 5     using -> USING CLASSOBJECT SEMICOLON
Rule 6     namespace -> NAMESPACE CLASSOBJECT SEMICOLON
Rule 7     class -> modifier CLASS CLASSOBJECT block
Rule 8     class -> modifier STATIC CLASS CLASSOBJECT block
Rule 9     object_access -> ID DOT ID
Rule 10    object_access -> CLASSOBJECT DOT CLASSOBJECT
Rule 11    object_access -> ID DOT CLASSOBJECT
Rule 12    object_access -> CLASSOBJECT DOT ID
Rule 13    block -> LBRACKET body RBRACKET
Rule 14    body -> lines SEMICOLON
Rule 15    body -> lines SEMICOLON body
Rule 16    body -> if
Rule 17    body -> loop
Rule 18    body -> function
Rule 19    lines -> assignment
Rule 20    lines -> expression
Rule 21    lines -> declaration
Rule 22    lines -> return
Rule 23    names -> ID
Rule 24    names -> CLASSOBJECT
Rule 25    function -> modifier data_type names LPAREN declarations RPAREN block
Rule 26    function -> modifier VOID names LPAREN declarations RPAREN block
Rule 27    function -> modifier STATIC data_type names LPAREN declarations RPAREN block
Rule 28    function -> modifier STATIC VOID names LPAREN declarations RPAREN block
Rule 29    function -> function body
Rule 30    return -> RETURN ID
Rule 31    return -> RETURN type
Rule 32    return -> RETURN expression
Rule 33    function_call -> names LPAREN RPAREN
Rule 34    function_call -> names LPAREN arguments RPAREN
Rule 35    arguments -> expression
Rule 36    arguments -> expression COMMA arguments
Rule 37    arguments -> names
Rule 38    arguments -> names COMMA arguments
Rule 39    lambda_function -> LPAREN ID RPAREN ARROW expression
Rule 40    lambda_function -> LPAREN ID RPAREN ARROW block
Rule 41    expression -> object_access LPAREN expression RPAREN
Rule 42    expression -> object_access LPAREN RPAREN
Rule 43    if -> IF LPAREN logical_expression RPAREN block
Rule 44    if -> IF LPAREN logical_expression RPAREN block body
Rule 45    if -> IF LPAREN logical_expression RPAREN block elseif
Rule 46    if -> IF LPAREN logical_expression RPAREN block else
Rule 47    elseif -> ELSE IF LPAREN logical_expression RPAREN block
Rule 48    elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif
Rule 49    elseif -> ELSE IF LPAREN logical_expression RPAREN block else
Rule 50    else -> ELSE block
Rule 51    else -> ELSE block body
Rule 52    loop -> while_loop
Rule 53    loop -> loop_for
Rule 54    loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
Rule 55    loop_for -> loop_for body
Rule 56    while_loop -> WHILE LPAREN logical_expression RPAREN block
Rule 57    while_loop -> WHILE LPAREN logical_expression RPAREN block body
Rule 58    logical_expression -> logical_factor logical_operator logical_expression
Rule 59    logical_expression -> logical_expression logical_operator logical_expression
Rule 60    logical_expression -> logical_factor
Rule 61    logical_factor -> TRUE
Rule 62    logical_factor -> FALSE
Rule 63    logical_factor -> ID
Rule 64    logical_factor -> indexing
Rule 65    logical_factor -> type
Rule 66    logical_factor -> object_access
Rule 67    logical_factor -> LPAREN logical_expression RPAREN
Rule 68    logical_operator -> OR
Rule 69    logical_operator -> AND
Rule 70    logical_operator -> NOT
Rule 71    logical_operator -> GREATER_THAN
Rule 72    logical_operator -> LESS_THAN
Rule 73    logical_operator -> GREATER_EQUALS_THAN
Rule 74    logical_operator -> LESS_EQUALS_THAN
Rule 75    logical_operator -> EQUALITY
Rule 76    logical_operator -> DIFFERENT
Rule 77    data_structure -> data_structure_list
Rule 78    data_structure -> data_structure_array
Rule 79    data_structure_list -> LIST LESS_THAN data_type GREATER_THAN
Rule 80    data_structure_array -> primitive LSQBRACKET RSQBRACKET
Rule 81    data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET
Rule 82    assignment -> data_type ID EQUALS expression
Rule 83    assignment -> ID EQUALS expression
Rule 84    assignment -> indexing_asign EQUALS expression
Rule 85    assignment -> ID PLUSONE
Rule 86    assignment -> CLASSOBJECT ID
Rule 87    expression -> expression PLUS term
Rule 88    expression -> expression MINUS term
Rule 89    expression -> term
Rule 90    term -> term TIMES factor
Rule 91    term -> term DIVIDE factor
Rule 92    term -> factor
Rule 93    factor -> type
Rule 94    factor -> LPAREN expression RPAREN
Rule 95    factor -> LSQBRACKET arguments RSQBRACKET
Rule 96    factor -> object_access
Rule 97    factor -> ID
Rule 98    factor -> indexing
Rule 99    factor -> function_call
Rule 100   factor -> STRING
Rule 101   type -> FLOAT_TYPE
Rule 102   type -> DOUBLE_TYPE
Rule 103   type -> DECIMAL_TYPE
Rule 104   type -> INTEGER_TYPE
Rule 105   type -> MINUS type
Rule 106   declarations -> declaration
Rule 107   declarations -> declaration COMMA
Rule 108   declarations -> declaration COMMA declarations
Rule 109   declaration -> data_type ID
Rule 110   modifier -> PUBLIC
Rule 111   modifier -> PRIVATE
Rule 112   modifier -> PROTECTED
Rule 113   modifier -> INTERNAL
Rule 114   data_type -> primitive
Rule 115   data_type -> data_structure
Rule 116   primitive -> INT
Rule 117   primitive -> FLOAT
Rule 118   primitive -> BOOL
Rule 119   primitive -> BYTE
Rule 120   primitive -> CHAR
Rule 121   primitive -> SBYTE
Rule 122   primitive -> DECIMAL
Rule 123   primitive -> DOUBLE
Rule 124   primitive -> LONG
Rule 125   primitive -> SHORT
Rule 126   primitive -> UINT
Rule 127   indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET
Rule 128   indexing -> ID LSQBRACKET ID RSQBRACKET
Rule 129   indexing -> ID LSQBRACKET expression RSQBRACKET
Rule 130   indexing_asign -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET
Rule 131   indexing_asign -> ID LSQBRACKET ID RSQBRACKET
Rule 132   indexing_asign -> ID LSQBRACKET expression RSQBRACKET

Terminals, with rules where they appear

AND                  : 69
ARROW                : 39 40
BOOL                 : 118
BYTE                 : 119
CHAR                 : 120
CHARACTER            : 
CLASS                : 7 8
CLASSOBJECT          : 5 6 7 8 10 10 11 12 24 81 86
COMMA                : 36 38 107 108
DECIMAL              : 122
DECIMAL_TYPE         : 103
DIFFERENT            : 76
DIVIDE               : 91
DIVIDE_EQUAL         : 
DO                   : 
DOT                  : 9 10 11 12
DOUBLE               : 123
DOUBLE_TYPE          : 102
ELSE                 : 47 48 49 50 51
EQUALITY             : 75
EQUALS               : 82 83 84
FALSE                : 62
FILE                 : 
FLOAT                : 117
FLOAT_TYPE           : 101
FOR                  : 54
GREATER_EQUALS_THAN  : 73
GREATER_THAN         : 71 79
ID                   : 9 9 11 12 23 30 39 40 63 82 83 85 86 97 109 127 128 128 129 130 131 131 132
IF                   : 43 44 45 46 47 48 49
IN                   : 
INT                  : 116
INTEGER_TYPE         : 104 127 130
INTERNAL             : 113
LBRACKET             : 13
LESS_EQUALS_THAN     : 74
LESS_THAN            : 72 79
LIST                 : 79
LONG                 : 124
LPAREN               : 25 26 27 28 33 34 39 40 41 42 43 44 45 46 47 48 49 54 56 57 67 94
LSQBRACKET           : 80 81 95 127 128 129 130 131 132
MINUS                : 88 105
MINUS_EQUAL          : 
MODULE               : 
MODULE_EQUAL         : 
NAMESPACE            : 6
NEW                  : 
NINT                 : 
NOT                  : 70
NUINT                : 
OR                   : 68
PLUS                 : 87
PLUSONE              : 85
PLUS_EQUAL           : 
PRIVATE              : 111
PROTECTED            : 112
PUBLIC               : 110
RBRACKET             : 13
RETURN               : 30 31 32
RPAREN               : 25 26 27 28 33 34 39 40 41 42 43 44 45 46 47 48 49 54 56 57 67 94
RSQBRACKET           : 80 81 95 127 128 129 130 131 132
SBYTE                : 121
SEMICOLON            : 5 6 14 15 54 54
SHORT                : 125
STATIC               : 8 27 28
STRING               : 100
THEN                 : 
TIMES                : 90
TIMES_EQUAL          : 
TRUE                 : 61
UINT                 : 126
ULONG                : 
USHORT               : 
USING                : 5
VAR                  : 
VOID                 : 26 28
WHILE                : 56 57
error                : 

Nonterminals, with rules where they appear

arguments            : 34 36 38 95
assignment           : 19 54 54
block                : 7 8 25 26 27 28 40 43 44 45 46 47 48 49 50 51 54 56 57
body                 : 13 15 29 44 51 55 57
class                : 1 2
data_structure       : 115
data_structure_array : 78
data_structure_list  : 77
data_type            : 25 27 79 82 109
declaration          : 21 106 107 108
declarations         : 25 26 27 28 108
else                 : 46 49
elseif               : 45 48
expression           : 20 32 35 36 39 41 82 83 84 87 88 94 129 132
factor               : 90 91 92
function             : 18 29
function_call        : 99
if                   : 16
indexing             : 64 98
indexing_asign       : 84
lambda_function      : 
lines                : 14 15
logical_expression   : 43 44 45 46 47 48 49 54 56 57 58 59 59 67
logical_factor       : 58 60
logical_operator     : 58 59
loop                 : 17
loop_for             : 53 55
modifier             : 7 8 25 26 27 28
names                : 25 26 27 28 33 34 37 38
namespace            : 1 2
object_access        : 41 42 66 96
primitive            : 80 114
program              : 0
return               : 22
term                 : 87 88 89 90 91
type                 : 31 65 93 105
using                : 3 4
usings               : 1 3
while_loop           : 52

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . usings namespace class
    (2) program -> . namespace class
    (3) usings -> . using usings
    (4) usings -> . using
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5
    USING           shift and go to state 6

    program                        shift and go to state 1
    usings                         shift and go to state 2
    namespace                      shift and go to state 3
    using                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> usings . namespace class
    (6) namespace -> . NAMESPACE CLASSOBJECT SEMICOLON

    NAMESPACE       shift and go to state 5

    namespace                      shift and go to state 7

state 3

    (2) program -> namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 8
    modifier                       shift and go to state 9

state 4

    (3) usings -> using . usings
    (4) usings -> using .
    (3) usings -> . using usings
    (4) usings -> . using
    (5) using -> . USING CLASSOBJECT SEMICOLON

    NAMESPACE       reduce using rule 4 (usings -> using .)
    USING           shift and go to state 6

    using                          shift and go to state 4
    usings                         shift and go to state 14

state 5

    (6) namespace -> NAMESPACE . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 15


state 6

    (5) using -> USING . CLASSOBJECT SEMICOLON

    CLASSOBJECT     shift and go to state 16


state 7

    (1) program -> usings namespace . class
    (7) class -> . modifier CLASS CLASSOBJECT block
    (8) class -> . modifier STATIC CLASS CLASSOBJECT block
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL

    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13

    class                          shift and go to state 17
    modifier                       shift and go to state 9

state 8

    (2) program -> namespace class .

    $end            reduce using rule 2 (program -> namespace class .)


state 9

    (7) class -> modifier . CLASS CLASSOBJECT block
    (8) class -> modifier . STATIC CLASS CLASSOBJECT block

    CLASS           shift and go to state 18
    STATIC          shift and go to state 19


state 10

    (110) modifier -> PUBLIC .

    CLASS           reduce using rule 110 (modifier -> PUBLIC .)
    STATIC          reduce using rule 110 (modifier -> PUBLIC .)
    VOID            reduce using rule 110 (modifier -> PUBLIC .)
    INT             reduce using rule 110 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 110 (modifier -> PUBLIC .)
    BOOL            reduce using rule 110 (modifier -> PUBLIC .)
    BYTE            reduce using rule 110 (modifier -> PUBLIC .)
    CHAR            reduce using rule 110 (modifier -> PUBLIC .)
    SBYTE           reduce using rule 110 (modifier -> PUBLIC .)
    DECIMAL         reduce using rule 110 (modifier -> PUBLIC .)
    DOUBLE          reduce using rule 110 (modifier -> PUBLIC .)
    LONG            reduce using rule 110 (modifier -> PUBLIC .)
    SHORT           reduce using rule 110 (modifier -> PUBLIC .)
    UINT            reduce using rule 110 (modifier -> PUBLIC .)
    LIST            reduce using rule 110 (modifier -> PUBLIC .)
    CLASSOBJECT     reduce using rule 110 (modifier -> PUBLIC .)


state 11

    (111) modifier -> PRIVATE .

    CLASS           reduce using rule 111 (modifier -> PRIVATE .)
    STATIC          reduce using rule 111 (modifier -> PRIVATE .)
    VOID            reduce using rule 111 (modifier -> PRIVATE .)
    INT             reduce using rule 111 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 111 (modifier -> PRIVATE .)
    BOOL            reduce using rule 111 (modifier -> PRIVATE .)
    BYTE            reduce using rule 111 (modifier -> PRIVATE .)
    CHAR            reduce using rule 111 (modifier -> PRIVATE .)
    SBYTE           reduce using rule 111 (modifier -> PRIVATE .)
    DECIMAL         reduce using rule 111 (modifier -> PRIVATE .)
    DOUBLE          reduce using rule 111 (modifier -> PRIVATE .)
    LONG            reduce using rule 111 (modifier -> PRIVATE .)
    SHORT           reduce using rule 111 (modifier -> PRIVATE .)
    UINT            reduce using rule 111 (modifier -> PRIVATE .)
    LIST            reduce using rule 111 (modifier -> PRIVATE .)
    CLASSOBJECT     reduce using rule 111 (modifier -> PRIVATE .)


state 12

    (112) modifier -> PROTECTED .

    CLASS           reduce using rule 112 (modifier -> PROTECTED .)
    STATIC          reduce using rule 112 (modifier -> PROTECTED .)
    VOID            reduce using rule 112 (modifier -> PROTECTED .)
    INT             reduce using rule 112 (modifier -> PROTECTED .)
    FLOAT           reduce using rule 112 (modifier -> PROTECTED .)
    BOOL            reduce using rule 112 (modifier -> PROTECTED .)
    BYTE            reduce using rule 112 (modifier -> PROTECTED .)
    CHAR            reduce using rule 112 (modifier -> PROTECTED .)
    SBYTE           reduce using rule 112 (modifier -> PROTECTED .)
    DECIMAL         reduce using rule 112 (modifier -> PROTECTED .)
    DOUBLE          reduce using rule 112 (modifier -> PROTECTED .)
    LONG            reduce using rule 112 (modifier -> PROTECTED .)
    SHORT           reduce using rule 112 (modifier -> PROTECTED .)
    UINT            reduce using rule 112 (modifier -> PROTECTED .)
    LIST            reduce using rule 112 (modifier -> PROTECTED .)
    CLASSOBJECT     reduce using rule 112 (modifier -> PROTECTED .)


state 13

    (113) modifier -> INTERNAL .

    CLASS           reduce using rule 113 (modifier -> INTERNAL .)
    STATIC          reduce using rule 113 (modifier -> INTERNAL .)
    VOID            reduce using rule 113 (modifier -> INTERNAL .)
    INT             reduce using rule 113 (modifier -> INTERNAL .)
    FLOAT           reduce using rule 113 (modifier -> INTERNAL .)
    BOOL            reduce using rule 113 (modifier -> INTERNAL .)
    BYTE            reduce using rule 113 (modifier -> INTERNAL .)
    CHAR            reduce using rule 113 (modifier -> INTERNAL .)
    SBYTE           reduce using rule 113 (modifier -> INTERNAL .)
    DECIMAL         reduce using rule 113 (modifier -> INTERNAL .)
    DOUBLE          reduce using rule 113 (modifier -> INTERNAL .)
    LONG            reduce using rule 113 (modifier -> INTERNAL .)
    SHORT           reduce using rule 113 (modifier -> INTERNAL .)
    UINT            reduce using rule 113 (modifier -> INTERNAL .)
    LIST            reduce using rule 113 (modifier -> INTERNAL .)
    CLASSOBJECT     reduce using rule 113 (modifier -> INTERNAL .)


state 14

    (3) usings -> using usings .

    NAMESPACE       reduce using rule 3 (usings -> using usings .)


state 15

    (6) namespace -> NAMESPACE CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 20


state 16

    (5) using -> USING CLASSOBJECT . SEMICOLON

    SEMICOLON       shift and go to state 21


state 17

    (1) program -> usings namespace class .

    $end            reduce using rule 1 (program -> usings namespace class .)


state 18

    (7) class -> modifier CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 22


state 19

    (8) class -> modifier STATIC . CLASS CLASSOBJECT block

    CLASS           shift and go to state 23


state 20

    (6) namespace -> NAMESPACE CLASSOBJECT SEMICOLON .

    PUBLIC          reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PRIVATE         reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    PROTECTED       reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)
    INTERNAL        reduce using rule 6 (namespace -> NAMESPACE CLASSOBJECT SEMICOLON .)


state 21

    (5) using -> USING CLASSOBJECT SEMICOLON .

    USING           reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)
    NAMESPACE       reduce using rule 5 (using -> USING CLASSOBJECT SEMICOLON .)


state 22

    (7) class -> modifier CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 24

state 23

    (8) class -> modifier STATIC CLASS . CLASSOBJECT block

    CLASSOBJECT     shift and go to state 26


state 24

    (7) class -> modifier CLASS CLASSOBJECT block .

    $end            reduce using rule 7 (class -> modifier CLASS CLASSOBJECT block .)


state 25

    (13) block -> LBRACKET . body RBRACKET
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    body                           shift and go to state 27
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 26

    (8) class -> modifier STATIC CLASS CLASSOBJECT . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 78

state 27

    (13) block -> LBRACKET body . RBRACKET

    RBRACKET        shift and go to state 79


state 28

    (14) body -> lines . SEMICOLON
    (15) body -> lines . SEMICOLON body

    SEMICOLON       shift and go to state 80


state 29

    (16) body -> if .

    RBRACKET        reduce using rule 16 (body -> if .)
    IF              reduce using rule 16 (body -> if .)
    ID              reduce using rule 16 (body -> if .)
    CLASSOBJECT     reduce using rule 16 (body -> if .)
    RETURN          reduce using rule 16 (body -> if .)
    WHILE           reduce using rule 16 (body -> if .)
    FOR             reduce using rule 16 (body -> if .)
    PUBLIC          reduce using rule 16 (body -> if .)
    PRIVATE         reduce using rule 16 (body -> if .)
    PROTECTED       reduce using rule 16 (body -> if .)
    INTERNAL        reduce using rule 16 (body -> if .)
    INT             reduce using rule 16 (body -> if .)
    FLOAT           reduce using rule 16 (body -> if .)
    BOOL            reduce using rule 16 (body -> if .)
    BYTE            reduce using rule 16 (body -> if .)
    CHAR            reduce using rule 16 (body -> if .)
    SBYTE           reduce using rule 16 (body -> if .)
    DECIMAL         reduce using rule 16 (body -> if .)
    DOUBLE          reduce using rule 16 (body -> if .)
    LONG            reduce using rule 16 (body -> if .)
    SHORT           reduce using rule 16 (body -> if .)
    UINT            reduce using rule 16 (body -> if .)
    LPAREN          reduce using rule 16 (body -> if .)
    LSQBRACKET      reduce using rule 16 (body -> if .)
    STRING          reduce using rule 16 (body -> if .)
    LIST            reduce using rule 16 (body -> if .)
    FLOAT_TYPE      reduce using rule 16 (body -> if .)
    DOUBLE_TYPE     reduce using rule 16 (body -> if .)
    DECIMAL_TYPE    reduce using rule 16 (body -> if .)
    INTEGER_TYPE    reduce using rule 16 (body -> if .)
    MINUS           reduce using rule 16 (body -> if .)


state 30

    (17) body -> loop .

    RBRACKET        reduce using rule 17 (body -> loop .)
    IF              reduce using rule 17 (body -> loop .)
    ID              reduce using rule 17 (body -> loop .)
    CLASSOBJECT     reduce using rule 17 (body -> loop .)
    RETURN          reduce using rule 17 (body -> loop .)
    WHILE           reduce using rule 17 (body -> loop .)
    FOR             reduce using rule 17 (body -> loop .)
    PUBLIC          reduce using rule 17 (body -> loop .)
    PRIVATE         reduce using rule 17 (body -> loop .)
    PROTECTED       reduce using rule 17 (body -> loop .)
    INTERNAL        reduce using rule 17 (body -> loop .)
    INT             reduce using rule 17 (body -> loop .)
    FLOAT           reduce using rule 17 (body -> loop .)
    BOOL            reduce using rule 17 (body -> loop .)
    BYTE            reduce using rule 17 (body -> loop .)
    CHAR            reduce using rule 17 (body -> loop .)
    SBYTE           reduce using rule 17 (body -> loop .)
    DECIMAL         reduce using rule 17 (body -> loop .)
    DOUBLE          reduce using rule 17 (body -> loop .)
    LONG            reduce using rule 17 (body -> loop .)
    SHORT           reduce using rule 17 (body -> loop .)
    UINT            reduce using rule 17 (body -> loop .)
    LPAREN          reduce using rule 17 (body -> loop .)
    LSQBRACKET      reduce using rule 17 (body -> loop .)
    STRING          reduce using rule 17 (body -> loop .)
    LIST            reduce using rule 17 (body -> loop .)
    FLOAT_TYPE      reduce using rule 17 (body -> loop .)
    DOUBLE_TYPE     reduce using rule 17 (body -> loop .)
    DECIMAL_TYPE    reduce using rule 17 (body -> loop .)
    INTEGER_TYPE    reduce using rule 17 (body -> loop .)
    MINUS           reduce using rule 17 (body -> loop .)


state 31

    (18) body -> function .
    (29) function -> function . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CLASSOBJECT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for INTERNAL resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for BYTE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SBYTE resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for SHORT resolved as shift
  ! shift/reduce conflict for UINT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQBRACKET resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for DECIMAL_TYPE resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 18 (body -> function .)
    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

  ! IF              [ reduce using rule 18 (body -> function .) ]
  ! ID              [ reduce using rule 18 (body -> function .) ]
  ! CLASSOBJECT     [ reduce using rule 18 (body -> function .) ]
  ! RETURN          [ reduce using rule 18 (body -> function .) ]
  ! WHILE           [ reduce using rule 18 (body -> function .) ]
  ! FOR             [ reduce using rule 18 (body -> function .) ]
  ! PUBLIC          [ reduce using rule 18 (body -> function .) ]
  ! PRIVATE         [ reduce using rule 18 (body -> function .) ]
  ! PROTECTED       [ reduce using rule 18 (body -> function .) ]
  ! INTERNAL        [ reduce using rule 18 (body -> function .) ]
  ! INT             [ reduce using rule 18 (body -> function .) ]
  ! FLOAT           [ reduce using rule 18 (body -> function .) ]
  ! BOOL            [ reduce using rule 18 (body -> function .) ]
  ! BYTE            [ reduce using rule 18 (body -> function .) ]
  ! CHAR            [ reduce using rule 18 (body -> function .) ]
  ! SBYTE           [ reduce using rule 18 (body -> function .) ]
  ! DECIMAL         [ reduce using rule 18 (body -> function .) ]
  ! DOUBLE          [ reduce using rule 18 (body -> function .) ]
  ! LONG            [ reduce using rule 18 (body -> function .) ]
  ! SHORT           [ reduce using rule 18 (body -> function .) ]
  ! UINT            [ reduce using rule 18 (body -> function .) ]
  ! LPAREN          [ reduce using rule 18 (body -> function .) ]
  ! LSQBRACKET      [ reduce using rule 18 (body -> function .) ]
  ! STRING          [ reduce using rule 18 (body -> function .) ]
  ! LIST            [ reduce using rule 18 (body -> function .) ]
  ! FLOAT_TYPE      [ reduce using rule 18 (body -> function .) ]
  ! DOUBLE_TYPE     [ reduce using rule 18 (body -> function .) ]
  ! DECIMAL_TYPE    [ reduce using rule 18 (body -> function .) ]
  ! INTEGER_TYPE    [ reduce using rule 18 (body -> function .) ]
  ! MINUS           [ reduce using rule 18 (body -> function .) ]

    function                       shift and go to state 31
    body                           shift and go to state 81
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 32

    (19) lines -> assignment .

    SEMICOLON       reduce using rule 19 (lines -> assignment .)


state 33

    (20) lines -> expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 20 (lines -> expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 34

    (21) lines -> declaration .

    SEMICOLON       reduce using rule 21 (lines -> declaration .)


state 35

    (22) lines -> return .

    SEMICOLON       reduce using rule 22 (lines -> return .)


state 36

    (43) if -> IF . LPAREN logical_expression RPAREN block
    (44) if -> IF . LPAREN logical_expression RPAREN block body
    (45) if -> IF . LPAREN logical_expression RPAREN block elseif
    (46) if -> IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 84


state 37

    (94) factor -> LPAREN . expression RPAREN
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    expression                     shift and go to state 85
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 38

    (52) loop -> while_loop .

    RBRACKET        reduce using rule 52 (loop -> while_loop .)
    IF              reduce using rule 52 (loop -> while_loop .)
    ID              reduce using rule 52 (loop -> while_loop .)
    CLASSOBJECT     reduce using rule 52 (loop -> while_loop .)
    RETURN          reduce using rule 52 (loop -> while_loop .)
    WHILE           reduce using rule 52 (loop -> while_loop .)
    FOR             reduce using rule 52 (loop -> while_loop .)
    PUBLIC          reduce using rule 52 (loop -> while_loop .)
    PRIVATE         reduce using rule 52 (loop -> while_loop .)
    PROTECTED       reduce using rule 52 (loop -> while_loop .)
    INTERNAL        reduce using rule 52 (loop -> while_loop .)
    INT             reduce using rule 52 (loop -> while_loop .)
    FLOAT           reduce using rule 52 (loop -> while_loop .)
    BOOL            reduce using rule 52 (loop -> while_loop .)
    BYTE            reduce using rule 52 (loop -> while_loop .)
    CHAR            reduce using rule 52 (loop -> while_loop .)
    SBYTE           reduce using rule 52 (loop -> while_loop .)
    DECIMAL         reduce using rule 52 (loop -> while_loop .)
    DOUBLE          reduce using rule 52 (loop -> while_loop .)
    LONG            reduce using rule 52 (loop -> while_loop .)
    SHORT           reduce using rule 52 (loop -> while_loop .)
    UINT            reduce using rule 52 (loop -> while_loop .)
    LPAREN          reduce using rule 52 (loop -> while_loop .)
    LSQBRACKET      reduce using rule 52 (loop -> while_loop .)
    STRING          reduce using rule 52 (loop -> while_loop .)
    LIST            reduce using rule 52 (loop -> while_loop .)
    FLOAT_TYPE      reduce using rule 52 (loop -> while_loop .)
    DOUBLE_TYPE     reduce using rule 52 (loop -> while_loop .)
    DECIMAL_TYPE    reduce using rule 52 (loop -> while_loop .)
    INTEGER_TYPE    reduce using rule 52 (loop -> while_loop .)
    MINUS           reduce using rule 52 (loop -> while_loop .)


state 39

    (53) loop -> loop_for .
    (55) loop_for -> loop_for . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CLASSOBJECT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for INTERNAL resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for BYTE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SBYTE resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for SHORT resolved as shift
  ! shift/reduce conflict for UINT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQBRACKET resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for DECIMAL_TYPE resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 53 (loop -> loop_for .)
    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

  ! IF              [ reduce using rule 53 (loop -> loop_for .) ]
  ! ID              [ reduce using rule 53 (loop -> loop_for .) ]
  ! CLASSOBJECT     [ reduce using rule 53 (loop -> loop_for .) ]
  ! RETURN          [ reduce using rule 53 (loop -> loop_for .) ]
  ! WHILE           [ reduce using rule 53 (loop -> loop_for .) ]
  ! FOR             [ reduce using rule 53 (loop -> loop_for .) ]
  ! PUBLIC          [ reduce using rule 53 (loop -> loop_for .) ]
  ! PRIVATE         [ reduce using rule 53 (loop -> loop_for .) ]
  ! PROTECTED       [ reduce using rule 53 (loop -> loop_for .) ]
  ! INTERNAL        [ reduce using rule 53 (loop -> loop_for .) ]
  ! INT             [ reduce using rule 53 (loop -> loop_for .) ]
  ! FLOAT           [ reduce using rule 53 (loop -> loop_for .) ]
  ! BOOL            [ reduce using rule 53 (loop -> loop_for .) ]
  ! BYTE            [ reduce using rule 53 (loop -> loop_for .) ]
  ! CHAR            [ reduce using rule 53 (loop -> loop_for .) ]
  ! SBYTE           [ reduce using rule 53 (loop -> loop_for .) ]
  ! DECIMAL         [ reduce using rule 53 (loop -> loop_for .) ]
  ! DOUBLE          [ reduce using rule 53 (loop -> loop_for .) ]
  ! LONG            [ reduce using rule 53 (loop -> loop_for .) ]
  ! SHORT           [ reduce using rule 53 (loop -> loop_for .) ]
  ! UINT            [ reduce using rule 53 (loop -> loop_for .) ]
  ! LPAREN          [ reduce using rule 53 (loop -> loop_for .) ]
  ! LSQBRACKET      [ reduce using rule 53 (loop -> loop_for .) ]
  ! STRING          [ reduce using rule 53 (loop -> loop_for .) ]
  ! LIST            [ reduce using rule 53 (loop -> loop_for .) ]
  ! FLOAT_TYPE      [ reduce using rule 53 (loop -> loop_for .) ]
  ! DOUBLE_TYPE     [ reduce using rule 53 (loop -> loop_for .) ]
  ! DECIMAL_TYPE    [ reduce using rule 53 (loop -> loop_for .) ]
  ! INTEGER_TYPE    [ reduce using rule 53 (loop -> loop_for .) ]
  ! MINUS           [ reduce using rule 53 (loop -> loop_for .) ]

    loop_for                       shift and go to state 39
    body                           shift and go to state 88
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 40

    (25) function -> modifier . data_type names LPAREN declarations RPAREN block
    (26) function -> modifier . VOID names LPAREN declarations RPAREN block
    (27) function -> modifier . STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> modifier . STATIC VOID names LPAREN declarations RPAREN block
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 90
    STATIC          shift and go to state 91
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    data_type                      shift and go to state 89
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 41

    (82) assignment -> data_type . ID EQUALS expression
    (109) declaration -> data_type . ID

    ID              shift and go to state 93


state 42

    (33) function_call -> names . LPAREN RPAREN
    (34) function_call -> names . LPAREN arguments RPAREN

    LPAREN          shift and go to state 94


state 43

    (83) assignment -> ID . EQUALS expression
    (85) assignment -> ID . PLUSONE
    (130) indexing_asign -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> ID . LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> ID . LSQBRACKET expression RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

    EQUALS          shift and go to state 95
    PLUSONE         shift and go to state 96
    LSQBRACKET      shift and go to state 97
    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    SEMICOLON       reduce using rule 97 (factor -> ID .)
    LPAREN          reduce using rule 23 (names -> ID .)


state 44

    (84) assignment -> indexing_asign . EQUALS expression

    EQUALS          shift and go to state 99


state 45

    (86) assignment -> CLASSOBJECT . ID
    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID
    (81) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET
    (24) names -> CLASSOBJECT .

    ID              shift and go to state 100
    DOT             shift and go to state 101
    LSQBRACKET      shift and go to state 102
    LPAREN          reduce using rule 24 (names -> CLASSOBJECT .)


state 46

    (41) expression -> object_access . LPAREN expression RPAREN
    (42) expression -> object_access . LPAREN RPAREN
    (96) factor -> object_access .

    LPAREN          shift and go to state 103
    TIMES           reduce using rule 96 (factor -> object_access .)
    DIVIDE          reduce using rule 96 (factor -> object_access .)
    PLUS            reduce using rule 96 (factor -> object_access .)
    MINUS           reduce using rule 96 (factor -> object_access .)
    SEMICOLON       reduce using rule 96 (factor -> object_access .)
    RPAREN          reduce using rule 96 (factor -> object_access .)
    COMMA           reduce using rule 96 (factor -> object_access .)
    RSQBRACKET      reduce using rule 96 (factor -> object_access .)


state 47

    (89) expression -> term .
    (90) term -> term . TIMES factor
    (91) term -> term . DIVIDE factor

    PLUS            reduce using rule 89 (expression -> term .)
    MINUS           reduce using rule 89 (expression -> term .)
    SEMICOLON       reduce using rule 89 (expression -> term .)
    RPAREN          reduce using rule 89 (expression -> term .)
    COMMA           reduce using rule 89 (expression -> term .)
    RSQBRACKET      reduce using rule 89 (expression -> term .)
    TIMES           shift and go to state 104
    DIVIDE          shift and go to state 105


state 48

    (105) type -> MINUS . type
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type

    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    type                           shift and go to state 106

state 49

    (30) return -> RETURN . ID
    (31) return -> RETURN . type
    (32) return -> RETURN . expression
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 107
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73

    type                           shift and go to state 108
    expression                     shift and go to state 109
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 50

    (93) factor -> type .

    TIMES           reduce using rule 93 (factor -> type .)
    DIVIDE          reduce using rule 93 (factor -> type .)
    PLUS            reduce using rule 93 (factor -> type .)
    MINUS           reduce using rule 93 (factor -> type .)
    SEMICOLON       reduce using rule 93 (factor -> type .)
    RPAREN          reduce using rule 93 (factor -> type .)
    COMMA           reduce using rule 93 (factor -> type .)
    RSQBRACKET      reduce using rule 93 (factor -> type .)


state 51

    (56) while_loop -> WHILE . LPAREN logical_expression RPAREN block
    (57) while_loop -> WHILE . LPAREN logical_expression RPAREN block body

    LPAREN          shift and go to state 110


state 52

    (54) loop_for -> FOR . LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block

    LPAREN          shift and go to state 111


state 53

    (114) data_type -> primitive .
    (80) data_structure_array -> primitive . LSQBRACKET RSQBRACKET

    ID              reduce using rule 114 (data_type -> primitive .)
    CLASSOBJECT     reduce using rule 114 (data_type -> primitive .)
    GREATER_THAN    reduce using rule 114 (data_type -> primitive .)
    LSQBRACKET      shift and go to state 112


state 54

    (115) data_type -> data_structure .

    ID              reduce using rule 115 (data_type -> data_structure .)
    CLASSOBJECT     reduce using rule 115 (data_type -> data_structure .)
    GREATER_THAN    reduce using rule 115 (data_type -> data_structure .)


state 55

    (95) factor -> LSQBRACKET . arguments RSQBRACKET
    (35) arguments -> . expression
    (36) arguments -> . expression COMMA arguments
    (37) arguments -> . names
    (38) arguments -> . names COMMA arguments
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (23) names -> . ID
    (24) names -> . CLASSOBJECT
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN

    ID              shift and go to state 116
    CLASSOBJECT     shift and go to state 117
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    arguments                      shift and go to state 113
    expression                     shift and go to state 114
    names                          shift and go to state 115
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 56

    (104) type -> INTEGER_TYPE .

    TIMES           reduce using rule 104 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 104 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 104 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 104 (type -> INTEGER_TYPE .)
    SEMICOLON       reduce using rule 104 (type -> INTEGER_TYPE .)
    RPAREN          reduce using rule 104 (type -> INTEGER_TYPE .)
    COMMA           reduce using rule 104 (type -> INTEGER_TYPE .)
    RSQBRACKET      reduce using rule 104 (type -> INTEGER_TYPE .)
    OR              reduce using rule 104 (type -> INTEGER_TYPE .)
    AND             reduce using rule 104 (type -> INTEGER_TYPE .)
    NOT             reduce using rule 104 (type -> INTEGER_TYPE .)
    GREATER_THAN    reduce using rule 104 (type -> INTEGER_TYPE .)
    LESS_THAN       reduce using rule 104 (type -> INTEGER_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 104 (type -> INTEGER_TYPE .)
    LESS_EQUALS_THAN reduce using rule 104 (type -> INTEGER_TYPE .)
    EQUALITY        reduce using rule 104 (type -> INTEGER_TYPE .)
    DIFFERENT       reduce using rule 104 (type -> INTEGER_TYPE .)


state 57

    (92) term -> factor .

    TIMES           reduce using rule 92 (term -> factor .)
    DIVIDE          reduce using rule 92 (term -> factor .)
    PLUS            reduce using rule 92 (term -> factor .)
    MINUS           reduce using rule 92 (term -> factor .)
    SEMICOLON       reduce using rule 92 (term -> factor .)
    RPAREN          reduce using rule 92 (term -> factor .)
    COMMA           reduce using rule 92 (term -> factor .)
    RSQBRACKET      reduce using rule 92 (term -> factor .)


state 58

    (116) primitive -> INT .

    LSQBRACKET      reduce using rule 116 (primitive -> INT .)
    ID              reduce using rule 116 (primitive -> INT .)
    CLASSOBJECT     reduce using rule 116 (primitive -> INT .)
    GREATER_THAN    reduce using rule 116 (primitive -> INT .)


state 59

    (117) primitive -> FLOAT .

    LSQBRACKET      reduce using rule 117 (primitive -> FLOAT .)
    ID              reduce using rule 117 (primitive -> FLOAT .)
    CLASSOBJECT     reduce using rule 117 (primitive -> FLOAT .)
    GREATER_THAN    reduce using rule 117 (primitive -> FLOAT .)


state 60

    (118) primitive -> BOOL .

    LSQBRACKET      reduce using rule 118 (primitive -> BOOL .)
    ID              reduce using rule 118 (primitive -> BOOL .)
    CLASSOBJECT     reduce using rule 118 (primitive -> BOOL .)
    GREATER_THAN    reduce using rule 118 (primitive -> BOOL .)


state 61

    (119) primitive -> BYTE .

    LSQBRACKET      reduce using rule 119 (primitive -> BYTE .)
    ID              reduce using rule 119 (primitive -> BYTE .)
    CLASSOBJECT     reduce using rule 119 (primitive -> BYTE .)
    GREATER_THAN    reduce using rule 119 (primitive -> BYTE .)


state 62

    (120) primitive -> CHAR .

    LSQBRACKET      reduce using rule 120 (primitive -> CHAR .)
    ID              reduce using rule 120 (primitive -> CHAR .)
    CLASSOBJECT     reduce using rule 120 (primitive -> CHAR .)
    GREATER_THAN    reduce using rule 120 (primitive -> CHAR .)


state 63

    (121) primitive -> SBYTE .

    LSQBRACKET      reduce using rule 121 (primitive -> SBYTE .)
    ID              reduce using rule 121 (primitive -> SBYTE .)
    CLASSOBJECT     reduce using rule 121 (primitive -> SBYTE .)
    GREATER_THAN    reduce using rule 121 (primitive -> SBYTE .)


state 64

    (122) primitive -> DECIMAL .

    LSQBRACKET      reduce using rule 122 (primitive -> DECIMAL .)
    ID              reduce using rule 122 (primitive -> DECIMAL .)
    CLASSOBJECT     reduce using rule 122 (primitive -> DECIMAL .)
    GREATER_THAN    reduce using rule 122 (primitive -> DECIMAL .)


state 65

    (123) primitive -> DOUBLE .

    LSQBRACKET      reduce using rule 123 (primitive -> DOUBLE .)
    ID              reduce using rule 123 (primitive -> DOUBLE .)
    CLASSOBJECT     reduce using rule 123 (primitive -> DOUBLE .)
    GREATER_THAN    reduce using rule 123 (primitive -> DOUBLE .)


state 66

    (124) primitive -> LONG .

    LSQBRACKET      reduce using rule 124 (primitive -> LONG .)
    ID              reduce using rule 124 (primitive -> LONG .)
    CLASSOBJECT     reduce using rule 124 (primitive -> LONG .)
    GREATER_THAN    reduce using rule 124 (primitive -> LONG .)


state 67

    (125) primitive -> SHORT .

    LSQBRACKET      reduce using rule 125 (primitive -> SHORT .)
    ID              reduce using rule 125 (primitive -> SHORT .)
    CLASSOBJECT     reduce using rule 125 (primitive -> SHORT .)
    GREATER_THAN    reduce using rule 125 (primitive -> SHORT .)


state 68

    (126) primitive -> UINT .

    LSQBRACKET      reduce using rule 126 (primitive -> UINT .)
    ID              reduce using rule 126 (primitive -> UINT .)
    CLASSOBJECT     reduce using rule 126 (primitive -> UINT .)
    GREATER_THAN    reduce using rule 126 (primitive -> UINT .)


state 69

    (77) data_structure -> data_structure_list .

    ID              reduce using rule 77 (data_structure -> data_structure_list .)
    CLASSOBJECT     reduce using rule 77 (data_structure -> data_structure_list .)
    GREATER_THAN    reduce using rule 77 (data_structure -> data_structure_list .)


state 70

    (78) data_structure -> data_structure_array .

    ID              reduce using rule 78 (data_structure -> data_structure_array .)
    CLASSOBJECT     reduce using rule 78 (data_structure -> data_structure_array .)
    GREATER_THAN    reduce using rule 78 (data_structure -> data_structure_array .)


state 71

    (98) factor -> indexing .

    TIMES           reduce using rule 98 (factor -> indexing .)
    DIVIDE          reduce using rule 98 (factor -> indexing .)
    PLUS            reduce using rule 98 (factor -> indexing .)
    MINUS           reduce using rule 98 (factor -> indexing .)
    SEMICOLON       reduce using rule 98 (factor -> indexing .)
    RPAREN          reduce using rule 98 (factor -> indexing .)
    COMMA           reduce using rule 98 (factor -> indexing .)
    RSQBRACKET      reduce using rule 98 (factor -> indexing .)


state 72

    (99) factor -> function_call .

    TIMES           reduce using rule 99 (factor -> function_call .)
    DIVIDE          reduce using rule 99 (factor -> function_call .)
    PLUS            reduce using rule 99 (factor -> function_call .)
    MINUS           reduce using rule 99 (factor -> function_call .)
    SEMICOLON       reduce using rule 99 (factor -> function_call .)
    RPAREN          reduce using rule 99 (factor -> function_call .)
    COMMA           reduce using rule 99 (factor -> function_call .)
    RSQBRACKET      reduce using rule 99 (factor -> function_call .)


state 73

    (100) factor -> STRING .

    TIMES           reduce using rule 100 (factor -> STRING .)
    DIVIDE          reduce using rule 100 (factor -> STRING .)
    PLUS            reduce using rule 100 (factor -> STRING .)
    MINUS           reduce using rule 100 (factor -> STRING .)
    SEMICOLON       reduce using rule 100 (factor -> STRING .)
    RPAREN          reduce using rule 100 (factor -> STRING .)
    COMMA           reduce using rule 100 (factor -> STRING .)
    RSQBRACKET      reduce using rule 100 (factor -> STRING .)


state 74

    (79) data_structure_list -> LIST . LESS_THAN data_type GREATER_THAN

    LESS_THAN       shift and go to state 118


state 75

    (101) type -> FLOAT_TYPE .

    TIMES           reduce using rule 101 (type -> FLOAT_TYPE .)
    DIVIDE          reduce using rule 101 (type -> FLOAT_TYPE .)
    PLUS            reduce using rule 101 (type -> FLOAT_TYPE .)
    MINUS           reduce using rule 101 (type -> FLOAT_TYPE .)
    SEMICOLON       reduce using rule 101 (type -> FLOAT_TYPE .)
    RPAREN          reduce using rule 101 (type -> FLOAT_TYPE .)
    COMMA           reduce using rule 101 (type -> FLOAT_TYPE .)
    RSQBRACKET      reduce using rule 101 (type -> FLOAT_TYPE .)
    OR              reduce using rule 101 (type -> FLOAT_TYPE .)
    AND             reduce using rule 101 (type -> FLOAT_TYPE .)
    NOT             reduce using rule 101 (type -> FLOAT_TYPE .)
    GREATER_THAN    reduce using rule 101 (type -> FLOAT_TYPE .)
    LESS_THAN       reduce using rule 101 (type -> FLOAT_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 101 (type -> FLOAT_TYPE .)
    LESS_EQUALS_THAN reduce using rule 101 (type -> FLOAT_TYPE .)
    EQUALITY        reduce using rule 101 (type -> FLOAT_TYPE .)
    DIFFERENT       reduce using rule 101 (type -> FLOAT_TYPE .)


state 76

    (102) type -> DOUBLE_TYPE .

    TIMES           reduce using rule 102 (type -> DOUBLE_TYPE .)
    DIVIDE          reduce using rule 102 (type -> DOUBLE_TYPE .)
    PLUS            reduce using rule 102 (type -> DOUBLE_TYPE .)
    MINUS           reduce using rule 102 (type -> DOUBLE_TYPE .)
    SEMICOLON       reduce using rule 102 (type -> DOUBLE_TYPE .)
    RPAREN          reduce using rule 102 (type -> DOUBLE_TYPE .)
    COMMA           reduce using rule 102 (type -> DOUBLE_TYPE .)
    RSQBRACKET      reduce using rule 102 (type -> DOUBLE_TYPE .)
    OR              reduce using rule 102 (type -> DOUBLE_TYPE .)
    AND             reduce using rule 102 (type -> DOUBLE_TYPE .)
    NOT             reduce using rule 102 (type -> DOUBLE_TYPE .)
    GREATER_THAN    reduce using rule 102 (type -> DOUBLE_TYPE .)
    LESS_THAN       reduce using rule 102 (type -> DOUBLE_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 102 (type -> DOUBLE_TYPE .)
    LESS_EQUALS_THAN reduce using rule 102 (type -> DOUBLE_TYPE .)
    EQUALITY        reduce using rule 102 (type -> DOUBLE_TYPE .)
    DIFFERENT       reduce using rule 102 (type -> DOUBLE_TYPE .)


state 77

    (103) type -> DECIMAL_TYPE .

    TIMES           reduce using rule 103 (type -> DECIMAL_TYPE .)
    DIVIDE          reduce using rule 103 (type -> DECIMAL_TYPE .)
    PLUS            reduce using rule 103 (type -> DECIMAL_TYPE .)
    MINUS           reduce using rule 103 (type -> DECIMAL_TYPE .)
    SEMICOLON       reduce using rule 103 (type -> DECIMAL_TYPE .)
    RPAREN          reduce using rule 103 (type -> DECIMAL_TYPE .)
    COMMA           reduce using rule 103 (type -> DECIMAL_TYPE .)
    RSQBRACKET      reduce using rule 103 (type -> DECIMAL_TYPE .)
    OR              reduce using rule 103 (type -> DECIMAL_TYPE .)
    AND             reduce using rule 103 (type -> DECIMAL_TYPE .)
    NOT             reduce using rule 103 (type -> DECIMAL_TYPE .)
    GREATER_THAN    reduce using rule 103 (type -> DECIMAL_TYPE .)
    LESS_THAN       reduce using rule 103 (type -> DECIMAL_TYPE .)
    GREATER_EQUALS_THAN reduce using rule 103 (type -> DECIMAL_TYPE .)
    LESS_EQUALS_THAN reduce using rule 103 (type -> DECIMAL_TYPE .)
    EQUALITY        reduce using rule 103 (type -> DECIMAL_TYPE .)
    DIFFERENT       reduce using rule 103 (type -> DECIMAL_TYPE .)


state 78

    (8) class -> modifier STATIC CLASS CLASSOBJECT block .

    $end            reduce using rule 8 (class -> modifier STATIC CLASS CLASSOBJECT block .)


state 79

    (13) block -> LBRACKET body RBRACKET .

    $end            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    ELSE            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    IF              reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    ID              reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    CLASSOBJECT     reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    RETURN          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    WHILE           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    FOR             reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    PUBLIC          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    PRIVATE         reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    PROTECTED       reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    INTERNAL        reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    INT             reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    FLOAT           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    BOOL            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    BYTE            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    CHAR            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    SBYTE           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DECIMAL         reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DOUBLE          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LONG            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    SHORT           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    UINT            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LPAREN          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LSQBRACKET      reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    STRING          reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    LIST            reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    FLOAT_TYPE      reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DOUBLE_TYPE     reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    DECIMAL_TYPE    reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    INTEGER_TYPE    reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    MINUS           reduce using rule 13 (block -> LBRACKET body RBRACKET .)
    RBRACKET        reduce using rule 13 (block -> LBRACKET body RBRACKET .)


state 80

    (14) body -> lines SEMICOLON .
    (15) body -> lines SEMICOLON . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CLASSOBJECT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for INTERNAL resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for BYTE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SBYTE resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for SHORT resolved as shift
  ! shift/reduce conflict for UINT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQBRACKET resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for DECIMAL_TYPE resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 14 (body -> lines SEMICOLON .)
    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

  ! IF              [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! ID              [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! CLASSOBJECT     [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! RETURN          [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! WHILE           [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! FOR             [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! PUBLIC          [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! PRIVATE         [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! PROTECTED       [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! INTERNAL        [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! INT             [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! BOOL            [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! BYTE            [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! CHAR            [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! SBYTE           [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! DECIMAL         [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! DOUBLE          [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! LONG            [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! SHORT           [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! UINT            [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! LPAREN          [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! LSQBRACKET      [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! STRING          [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! LIST            [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! FLOAT_TYPE      [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! DOUBLE_TYPE     [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! DECIMAL_TYPE    [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! INTEGER_TYPE    [ reduce using rule 14 (body -> lines SEMICOLON .) ]
  ! MINUS           [ reduce using rule 14 (body -> lines SEMICOLON .) ]

    lines                          shift and go to state 28
    body                           shift and go to state 119
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 81

    (29) function -> function body .

    IF              reduce using rule 29 (function -> function body .)
    ID              reduce using rule 29 (function -> function body .)
    CLASSOBJECT     reduce using rule 29 (function -> function body .)
    RETURN          reduce using rule 29 (function -> function body .)
    WHILE           reduce using rule 29 (function -> function body .)
    FOR             reduce using rule 29 (function -> function body .)
    PUBLIC          reduce using rule 29 (function -> function body .)
    PRIVATE         reduce using rule 29 (function -> function body .)
    PROTECTED       reduce using rule 29 (function -> function body .)
    INTERNAL        reduce using rule 29 (function -> function body .)
    INT             reduce using rule 29 (function -> function body .)
    FLOAT           reduce using rule 29 (function -> function body .)
    BOOL            reduce using rule 29 (function -> function body .)
    BYTE            reduce using rule 29 (function -> function body .)
    CHAR            reduce using rule 29 (function -> function body .)
    SBYTE           reduce using rule 29 (function -> function body .)
    DECIMAL         reduce using rule 29 (function -> function body .)
    DOUBLE          reduce using rule 29 (function -> function body .)
    LONG            reduce using rule 29 (function -> function body .)
    SHORT           reduce using rule 29 (function -> function body .)
    UINT            reduce using rule 29 (function -> function body .)
    LPAREN          reduce using rule 29 (function -> function body .)
    LSQBRACKET      reduce using rule 29 (function -> function body .)
    STRING          reduce using rule 29 (function -> function body .)
    LIST            reduce using rule 29 (function -> function body .)
    FLOAT_TYPE      reduce using rule 29 (function -> function body .)
    DOUBLE_TYPE     reduce using rule 29 (function -> function body .)
    DECIMAL_TYPE    reduce using rule 29 (function -> function body .)
    INTEGER_TYPE    reduce using rule 29 (function -> function body .)
    MINUS           reduce using rule 29 (function -> function body .)
    RBRACKET        reduce using rule 29 (function -> function body .)


state 82

    (87) expression -> expression PLUS . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    ID              shift and go to state 122
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 87

    term                           shift and go to state 120
    factor                         shift and go to state 57
    type                           shift and go to state 50
    object_access                  shift and go to state 121
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 83

    (88) expression -> expression MINUS . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    ID              shift and go to state 122
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 87

    term                           shift and go to state 123
    factor                         shift and go to state 57
    type                           shift and go to state 50
    object_access                  shift and go to state 121
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 84

    (43) if -> IF LPAREN . logical_expression RPAREN block
    (44) if -> IF LPAREN . logical_expression RPAREN block body
    (45) if -> IF LPAREN . logical_expression RPAREN block elseif
    (46) if -> IF LPAREN . logical_expression RPAREN block else
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_expression             shift and go to state 125
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 85

    (94) factor -> LPAREN expression . RPAREN
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RPAREN          shift and go to state 134
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 86

    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    RPAREN          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    SEMICOLON       reduce using rule 97 (factor -> ID .)
    LSQBRACKET      shift and go to state 135
    LPAREN          reduce using rule 23 (names -> ID .)


state 87

    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID
    (24) names -> CLASSOBJECT .

    DOT             shift and go to state 101
    LPAREN          reduce using rule 24 (names -> CLASSOBJECT .)


state 88

    (55) loop_for -> loop_for body .

    IF              reduce using rule 55 (loop_for -> loop_for body .)
    ID              reduce using rule 55 (loop_for -> loop_for body .)
    CLASSOBJECT     reduce using rule 55 (loop_for -> loop_for body .)
    RETURN          reduce using rule 55 (loop_for -> loop_for body .)
    WHILE           reduce using rule 55 (loop_for -> loop_for body .)
    FOR             reduce using rule 55 (loop_for -> loop_for body .)
    PUBLIC          reduce using rule 55 (loop_for -> loop_for body .)
    PRIVATE         reduce using rule 55 (loop_for -> loop_for body .)
    PROTECTED       reduce using rule 55 (loop_for -> loop_for body .)
    INTERNAL        reduce using rule 55 (loop_for -> loop_for body .)
    INT             reduce using rule 55 (loop_for -> loop_for body .)
    FLOAT           reduce using rule 55 (loop_for -> loop_for body .)
    BOOL            reduce using rule 55 (loop_for -> loop_for body .)
    BYTE            reduce using rule 55 (loop_for -> loop_for body .)
    CHAR            reduce using rule 55 (loop_for -> loop_for body .)
    SBYTE           reduce using rule 55 (loop_for -> loop_for body .)
    DECIMAL         reduce using rule 55 (loop_for -> loop_for body .)
    DOUBLE          reduce using rule 55 (loop_for -> loop_for body .)
    LONG            reduce using rule 55 (loop_for -> loop_for body .)
    SHORT           reduce using rule 55 (loop_for -> loop_for body .)
    UINT            reduce using rule 55 (loop_for -> loop_for body .)
    LPAREN          reduce using rule 55 (loop_for -> loop_for body .)
    LSQBRACKET      reduce using rule 55 (loop_for -> loop_for body .)
    STRING          reduce using rule 55 (loop_for -> loop_for body .)
    LIST            reduce using rule 55 (loop_for -> loop_for body .)
    FLOAT_TYPE      reduce using rule 55 (loop_for -> loop_for body .)
    DOUBLE_TYPE     reduce using rule 55 (loop_for -> loop_for body .)
    DECIMAL_TYPE    reduce using rule 55 (loop_for -> loop_for body .)
    INTEGER_TYPE    reduce using rule 55 (loop_for -> loop_for body .)
    MINUS           reduce using rule 55 (loop_for -> loop_for body .)
    RBRACKET        reduce using rule 55 (loop_for -> loop_for body .)


state 89

    (25) function -> modifier data_type . names LPAREN declarations RPAREN block
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 137
    CLASSOBJECT     shift and go to state 138

    names                          shift and go to state 136

state 90

    (26) function -> modifier VOID . names LPAREN declarations RPAREN block
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 137
    CLASSOBJECT     shift and go to state 138

    names                          shift and go to state 139

state 91

    (27) function -> modifier STATIC . data_type names LPAREN declarations RPAREN block
    (28) function -> modifier STATIC . VOID names LPAREN declarations RPAREN block
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    VOID            shift and go to state 141
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    data_type                      shift and go to state 140
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 92

    (81) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    LSQBRACKET      shift and go to state 102


state 93

    (82) assignment -> data_type ID . EQUALS expression
    (109) declaration -> data_type ID .

    EQUALS          shift and go to state 142
    SEMICOLON       reduce using rule 109 (declaration -> data_type ID .)


state 94

    (33) function_call -> names LPAREN . RPAREN
    (34) function_call -> names LPAREN . arguments RPAREN
    (35) arguments -> . expression
    (36) arguments -> . expression COMMA arguments
    (37) arguments -> . names
    (38) arguments -> . names COMMA arguments
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (23) names -> . ID
    (24) names -> . CLASSOBJECT
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN

    RPAREN          shift and go to state 143
    ID              shift and go to state 116
    CLASSOBJECT     shift and go to state 117
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    names                          shift and go to state 115
    arguments                      shift and go to state 144
    expression                     shift and go to state 114
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 95

    (83) assignment -> ID EQUALS . expression
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    expression                     shift and go to state 145
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 96

    (85) assignment -> ID PLUSONE .

    SEMICOLON       reduce using rule 85 (assignment -> ID PLUSONE .)
    RPAREN          reduce using rule 85 (assignment -> ID PLUSONE .)


state 97

    (130) indexing_asign -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> ID LSQBRACKET . ID RSQBRACKET
    (132) indexing_asign -> ID LSQBRACKET . expression RSQBRACKET
    (127) indexing -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID LSQBRACKET . ID RSQBRACKET
    (129) indexing -> ID LSQBRACKET . expression RSQBRACKET
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    INTEGER_TYPE    shift and go to state 147
    ID              shift and go to state 146
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    MINUS           shift and go to state 48

    expression                     shift and go to state 148
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 98

    (9) object_access -> ID DOT . ID
    (11) object_access -> ID DOT . CLASSOBJECT

    ID              shift and go to state 149
    CLASSOBJECT     shift and go to state 150


state 99

    (84) assignment -> indexing_asign EQUALS . expression
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    expression                     shift and go to state 151
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 100

    (86) assignment -> CLASSOBJECT ID .

    SEMICOLON       reduce using rule 86 (assignment -> CLASSOBJECT ID .)
    RPAREN          reduce using rule 86 (assignment -> CLASSOBJECT ID .)


state 101

    (10) object_access -> CLASSOBJECT DOT . CLASSOBJECT
    (12) object_access -> CLASSOBJECT DOT . ID

    CLASSOBJECT     shift and go to state 152
    ID              shift and go to state 153


state 102

    (81) data_structure_array -> CLASSOBJECT LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 154


state 103

    (41) expression -> object_access LPAREN . expression RPAREN
    (42) expression -> object_access LPAREN . RPAREN
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    RPAREN          shift and go to state 156
    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    object_access                  shift and go to state 46
    expression                     shift and go to state 155
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 104

    (90) term -> term TIMES . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    ID              shift and go to state 122
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 87

    factor                         shift and go to state 157
    type                           shift and go to state 50
    object_access                  shift and go to state 121
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 105

    (91) term -> term DIVIDE . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    ID              shift and go to state 122
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 87

    factor                         shift and go to state 158
    type                           shift and go to state 50
    object_access                  shift and go to state 121
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 106

    (105) type -> MINUS type .

    TIMES           reduce using rule 105 (type -> MINUS type .)
    DIVIDE          reduce using rule 105 (type -> MINUS type .)
    PLUS            reduce using rule 105 (type -> MINUS type .)
    MINUS           reduce using rule 105 (type -> MINUS type .)
    SEMICOLON       reduce using rule 105 (type -> MINUS type .)
    RPAREN          reduce using rule 105 (type -> MINUS type .)
    COMMA           reduce using rule 105 (type -> MINUS type .)
    RSQBRACKET      reduce using rule 105 (type -> MINUS type .)
    OR              reduce using rule 105 (type -> MINUS type .)
    AND             reduce using rule 105 (type -> MINUS type .)
    NOT             reduce using rule 105 (type -> MINUS type .)
    GREATER_THAN    reduce using rule 105 (type -> MINUS type .)
    LESS_THAN       reduce using rule 105 (type -> MINUS type .)
    GREATER_EQUALS_THAN reduce using rule 105 (type -> MINUS type .)
    LESS_EQUALS_THAN reduce using rule 105 (type -> MINUS type .)
    EQUALITY        reduce using rule 105 (type -> MINUS type .)
    DIFFERENT       reduce using rule 105 (type -> MINUS type .)


state 107

    (30) return -> RETURN ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 30 (return -> RETURN ID .)
    SEMICOLON       reduce using rule 30 (return -> RETURN ID .)
    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    LSQBRACKET      shift and go to state 135
    LPAREN          reduce using rule 23 (names -> ID .)

  ! SEMICOLON       [ reduce using rule 97 (factor -> ID .) ]


state 108

    (31) return -> RETURN type .
    (93) factor -> type .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 31 (return -> RETURN type .)
    SEMICOLON       reduce using rule 31 (return -> RETURN type .)
    TIMES           reduce using rule 93 (factor -> type .)
    DIVIDE          reduce using rule 93 (factor -> type .)
    PLUS            reduce using rule 93 (factor -> type .)
    MINUS           reduce using rule 93 (factor -> type .)

  ! SEMICOLON       [ reduce using rule 93 (factor -> type .) ]


state 109

    (32) return -> RETURN expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 32 (return -> RETURN expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 110

    (56) while_loop -> WHILE LPAREN . logical_expression RPAREN block
    (57) while_loop -> WHILE LPAREN . logical_expression RPAREN block body
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_expression             shift and go to state 159
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 111

    (54) loop_for -> FOR LPAREN . assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    ID              shift and go to state 162
    CLASSOBJECT     shift and go to state 163
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74

    assignment                     shift and go to state 160
    data_type                      shift and go to state 161
    indexing_asign                 shift and go to state 44
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 112

    (80) data_structure_array -> primitive LSQBRACKET . RSQBRACKET

    RSQBRACKET      shift and go to state 164


state 113

    (95) factor -> LSQBRACKET arguments . RSQBRACKET

    RSQBRACKET      shift and go to state 165


state 114

    (35) arguments -> expression .
    (36) arguments -> expression . COMMA arguments
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RSQBRACKET      reduce using rule 35 (arguments -> expression .)
    RPAREN          reduce using rule 35 (arguments -> expression .)
    COMMA           shift and go to state 166
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 115

    (37) arguments -> names .
    (38) arguments -> names . COMMA arguments
    (33) function_call -> names . LPAREN RPAREN
    (34) function_call -> names . LPAREN arguments RPAREN

    RSQBRACKET      reduce using rule 37 (arguments -> names .)
    RPAREN          reduce using rule 37 (arguments -> names .)
    COMMA           shift and go to state 167
    LPAREN          shift and go to state 94


state 116

    (23) names -> ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET

  ! reduce/reduce conflict for COMMA resolved using rule 23 (names -> ID .)
  ! reduce/reduce conflict for RSQBRACKET resolved using rule 23 (names -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 23 (names -> ID .)
    COMMA           reduce using rule 23 (names -> ID .)
    LPAREN          reduce using rule 23 (names -> ID .)
    RSQBRACKET      reduce using rule 23 (names -> ID .)
    RPAREN          reduce using rule 23 (names -> ID .)
    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    LSQBRACKET      shift and go to state 135

  ! COMMA           [ reduce using rule 97 (factor -> ID .) ]
  ! RSQBRACKET      [ reduce using rule 97 (factor -> ID .) ]
  ! RPAREN          [ reduce using rule 97 (factor -> ID .) ]


state 117

    (24) names -> CLASSOBJECT .
    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID

    COMMA           reduce using rule 24 (names -> CLASSOBJECT .)
    LPAREN          reduce using rule 24 (names -> CLASSOBJECT .)
    RSQBRACKET      reduce using rule 24 (names -> CLASSOBJECT .)
    RPAREN          reduce using rule 24 (names -> CLASSOBJECT .)
    DOT             shift and go to state 101


state 118

    (79) data_structure_list -> LIST LESS_THAN . data_type GREATER_THAN
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    data_type                      shift and go to state 168
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 119

    (15) body -> lines SEMICOLON body .

    RBRACKET        reduce using rule 15 (body -> lines SEMICOLON body .)
    IF              reduce using rule 15 (body -> lines SEMICOLON body .)
    ID              reduce using rule 15 (body -> lines SEMICOLON body .)
    CLASSOBJECT     reduce using rule 15 (body -> lines SEMICOLON body .)
    RETURN          reduce using rule 15 (body -> lines SEMICOLON body .)
    WHILE           reduce using rule 15 (body -> lines SEMICOLON body .)
    FOR             reduce using rule 15 (body -> lines SEMICOLON body .)
    PUBLIC          reduce using rule 15 (body -> lines SEMICOLON body .)
    PRIVATE         reduce using rule 15 (body -> lines SEMICOLON body .)
    PROTECTED       reduce using rule 15 (body -> lines SEMICOLON body .)
    INTERNAL        reduce using rule 15 (body -> lines SEMICOLON body .)
    INT             reduce using rule 15 (body -> lines SEMICOLON body .)
    FLOAT           reduce using rule 15 (body -> lines SEMICOLON body .)
    BOOL            reduce using rule 15 (body -> lines SEMICOLON body .)
    BYTE            reduce using rule 15 (body -> lines SEMICOLON body .)
    CHAR            reduce using rule 15 (body -> lines SEMICOLON body .)
    SBYTE           reduce using rule 15 (body -> lines SEMICOLON body .)
    DECIMAL         reduce using rule 15 (body -> lines SEMICOLON body .)
    DOUBLE          reduce using rule 15 (body -> lines SEMICOLON body .)
    LONG            reduce using rule 15 (body -> lines SEMICOLON body .)
    SHORT           reduce using rule 15 (body -> lines SEMICOLON body .)
    UINT            reduce using rule 15 (body -> lines SEMICOLON body .)
    LPAREN          reduce using rule 15 (body -> lines SEMICOLON body .)
    LSQBRACKET      reduce using rule 15 (body -> lines SEMICOLON body .)
    STRING          reduce using rule 15 (body -> lines SEMICOLON body .)
    LIST            reduce using rule 15 (body -> lines SEMICOLON body .)
    FLOAT_TYPE      reduce using rule 15 (body -> lines SEMICOLON body .)
    DOUBLE_TYPE     reduce using rule 15 (body -> lines SEMICOLON body .)
    DECIMAL_TYPE    reduce using rule 15 (body -> lines SEMICOLON body .)
    INTEGER_TYPE    reduce using rule 15 (body -> lines SEMICOLON body .)
    MINUS           reduce using rule 15 (body -> lines SEMICOLON body .)


state 120

    (87) expression -> expression PLUS term .
    (90) term -> term . TIMES factor
    (91) term -> term . DIVIDE factor

    PLUS            reduce using rule 87 (expression -> expression PLUS term .)
    MINUS           reduce using rule 87 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 87 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 87 (expression -> expression PLUS term .)
    COMMA           reduce using rule 87 (expression -> expression PLUS term .)
    RSQBRACKET      reduce using rule 87 (expression -> expression PLUS term .)
    TIMES           shift and go to state 104
    DIVIDE          shift and go to state 105


state 121

    (96) factor -> object_access .

    TIMES           reduce using rule 96 (factor -> object_access .)
    DIVIDE          reduce using rule 96 (factor -> object_access .)
    PLUS            reduce using rule 96 (factor -> object_access .)
    MINUS           reduce using rule 96 (factor -> object_access .)
    SEMICOLON       reduce using rule 96 (factor -> object_access .)
    RPAREN          reduce using rule 96 (factor -> object_access .)
    COMMA           reduce using rule 96 (factor -> object_access .)
    RSQBRACKET      reduce using rule 96 (factor -> object_access .)


state 122

    (97) factor -> ID .
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    SEMICOLON       reduce using rule 97 (factor -> ID .)
    RPAREN          reduce using rule 97 (factor -> ID .)
    COMMA           reduce using rule 97 (factor -> ID .)
    RSQBRACKET      reduce using rule 97 (factor -> ID .)
    DOT             shift and go to state 98
    LSQBRACKET      shift and go to state 135
    LPAREN          reduce using rule 23 (names -> ID .)


state 123

    (88) expression -> expression MINUS term .
    (90) term -> term . TIMES factor
    (91) term -> term . DIVIDE factor

    PLUS            reduce using rule 88 (expression -> expression MINUS term .)
    MINUS           reduce using rule 88 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 88 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 88 (expression -> expression MINUS term .)
    COMMA           reduce using rule 88 (expression -> expression MINUS term .)
    RSQBRACKET      reduce using rule 88 (expression -> expression MINUS term .)
    TIMES           shift and go to state 104
    DIVIDE          shift and go to state 105


state 124

    (67) logical_factor -> LPAREN . logical_expression RPAREN
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_expression             shift and go to state 169
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 125

    (43) if -> IF LPAREN logical_expression . RPAREN block
    (44) if -> IF LPAREN logical_expression . RPAREN block body
    (45) if -> IF LPAREN logical_expression . RPAREN block elseif
    (46) if -> IF LPAREN logical_expression . RPAREN block else
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

    RPAREN          shift and go to state 170
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

    logical_operator               shift and go to state 171

state 126

    (58) logical_expression -> logical_factor . logical_operator logical_expression
    (60) logical_expression -> logical_factor .
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS_THAN resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    RPAREN          reduce using rule 60 (logical_expression -> logical_factor .)
    SEMICOLON       reduce using rule 60 (logical_expression -> logical_factor .)
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

  ! OR              [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! AND             [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! NOT             [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! GREATER_THAN    [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! LESS_THAN       [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! GREATER_EQUALS_THAN [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! LESS_EQUALS_THAN [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! EQUALITY        [ reduce using rule 60 (logical_expression -> logical_factor .) ]
  ! DIFFERENT       [ reduce using rule 60 (logical_expression -> logical_factor .) ]

    logical_operator               shift and go to state 181

state 127

    (61) logical_factor -> TRUE .

    OR              reduce using rule 61 (logical_factor -> TRUE .)
    AND             reduce using rule 61 (logical_factor -> TRUE .)
    NOT             reduce using rule 61 (logical_factor -> TRUE .)
    GREATER_THAN    reduce using rule 61 (logical_factor -> TRUE .)
    LESS_THAN       reduce using rule 61 (logical_factor -> TRUE .)
    GREATER_EQUALS_THAN reduce using rule 61 (logical_factor -> TRUE .)
    LESS_EQUALS_THAN reduce using rule 61 (logical_factor -> TRUE .)
    EQUALITY        reduce using rule 61 (logical_factor -> TRUE .)
    DIFFERENT       reduce using rule 61 (logical_factor -> TRUE .)
    RPAREN          reduce using rule 61 (logical_factor -> TRUE .)
    SEMICOLON       reduce using rule 61 (logical_factor -> TRUE .)


state 128

    (62) logical_factor -> FALSE .

    OR              reduce using rule 62 (logical_factor -> FALSE .)
    AND             reduce using rule 62 (logical_factor -> FALSE .)
    NOT             reduce using rule 62 (logical_factor -> FALSE .)
    GREATER_THAN    reduce using rule 62 (logical_factor -> FALSE .)
    LESS_THAN       reduce using rule 62 (logical_factor -> FALSE .)
    GREATER_EQUALS_THAN reduce using rule 62 (logical_factor -> FALSE .)
    LESS_EQUALS_THAN reduce using rule 62 (logical_factor -> FALSE .)
    EQUALITY        reduce using rule 62 (logical_factor -> FALSE .)
    DIFFERENT       reduce using rule 62 (logical_factor -> FALSE .)
    RPAREN          reduce using rule 62 (logical_factor -> FALSE .)
    SEMICOLON       reduce using rule 62 (logical_factor -> FALSE .)


state 129

    (63) logical_factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT

    OR              reduce using rule 63 (logical_factor -> ID .)
    AND             reduce using rule 63 (logical_factor -> ID .)
    NOT             reduce using rule 63 (logical_factor -> ID .)
    GREATER_THAN    reduce using rule 63 (logical_factor -> ID .)
    LESS_THAN       reduce using rule 63 (logical_factor -> ID .)
    GREATER_EQUALS_THAN reduce using rule 63 (logical_factor -> ID .)
    LESS_EQUALS_THAN reduce using rule 63 (logical_factor -> ID .)
    EQUALITY        reduce using rule 63 (logical_factor -> ID .)
    DIFFERENT       reduce using rule 63 (logical_factor -> ID .)
    RPAREN          reduce using rule 63 (logical_factor -> ID .)
    SEMICOLON       reduce using rule 63 (logical_factor -> ID .)
    LSQBRACKET      shift and go to state 135
    DOT             shift and go to state 98


state 130

    (64) logical_factor -> indexing .

    OR              reduce using rule 64 (logical_factor -> indexing .)
    AND             reduce using rule 64 (logical_factor -> indexing .)
    NOT             reduce using rule 64 (logical_factor -> indexing .)
    GREATER_THAN    reduce using rule 64 (logical_factor -> indexing .)
    LESS_THAN       reduce using rule 64 (logical_factor -> indexing .)
    GREATER_EQUALS_THAN reduce using rule 64 (logical_factor -> indexing .)
    LESS_EQUALS_THAN reduce using rule 64 (logical_factor -> indexing .)
    EQUALITY        reduce using rule 64 (logical_factor -> indexing .)
    DIFFERENT       reduce using rule 64 (logical_factor -> indexing .)
    RPAREN          reduce using rule 64 (logical_factor -> indexing .)
    SEMICOLON       reduce using rule 64 (logical_factor -> indexing .)


state 131

    (65) logical_factor -> type .

    OR              reduce using rule 65 (logical_factor -> type .)
    AND             reduce using rule 65 (logical_factor -> type .)
    NOT             reduce using rule 65 (logical_factor -> type .)
    GREATER_THAN    reduce using rule 65 (logical_factor -> type .)
    LESS_THAN       reduce using rule 65 (logical_factor -> type .)
    GREATER_EQUALS_THAN reduce using rule 65 (logical_factor -> type .)
    LESS_EQUALS_THAN reduce using rule 65 (logical_factor -> type .)
    EQUALITY        reduce using rule 65 (logical_factor -> type .)
    DIFFERENT       reduce using rule 65 (logical_factor -> type .)
    RPAREN          reduce using rule 65 (logical_factor -> type .)
    SEMICOLON       reduce using rule 65 (logical_factor -> type .)


state 132

    (66) logical_factor -> object_access .

    OR              reduce using rule 66 (logical_factor -> object_access .)
    AND             reduce using rule 66 (logical_factor -> object_access .)
    NOT             reduce using rule 66 (logical_factor -> object_access .)
    GREATER_THAN    reduce using rule 66 (logical_factor -> object_access .)
    LESS_THAN       reduce using rule 66 (logical_factor -> object_access .)
    GREATER_EQUALS_THAN reduce using rule 66 (logical_factor -> object_access .)
    LESS_EQUALS_THAN reduce using rule 66 (logical_factor -> object_access .)
    EQUALITY        reduce using rule 66 (logical_factor -> object_access .)
    DIFFERENT       reduce using rule 66 (logical_factor -> object_access .)
    RPAREN          reduce using rule 66 (logical_factor -> object_access .)
    SEMICOLON       reduce using rule 66 (logical_factor -> object_access .)


state 133

    (10) object_access -> CLASSOBJECT . DOT CLASSOBJECT
    (12) object_access -> CLASSOBJECT . DOT ID

    DOT             shift and go to state 101


state 134

    (94) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 94 (factor -> LPAREN expression RPAREN .)
    RSQBRACKET      reduce using rule 94 (factor -> LPAREN expression RPAREN .)


state 135

    (127) indexing -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID LSQBRACKET . ID RSQBRACKET
    (129) indexing -> ID LSQBRACKET . expression RSQBRACKET
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    INTEGER_TYPE    shift and go to state 183
    ID              shift and go to state 182
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    MINUS           shift and go to state 48

    expression                     shift and go to state 184
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 136

    (25) function -> modifier data_type names . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 185


state 137

    (23) names -> ID .

    LPAREN          reduce using rule 23 (names -> ID .)


state 138

    (24) names -> CLASSOBJECT .

    LPAREN          reduce using rule 24 (names -> CLASSOBJECT .)


state 139

    (26) function -> modifier VOID names . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 186


state 140

    (27) function -> modifier STATIC data_type . names LPAREN declarations RPAREN block
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 137
    CLASSOBJECT     shift and go to state 138

    names                          shift and go to state 187

state 141

    (28) function -> modifier STATIC VOID . names LPAREN declarations RPAREN block
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 137
    CLASSOBJECT     shift and go to state 138

    names                          shift and go to state 188

state 142

    (82) assignment -> data_type ID EQUALS . expression
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    ID              shift and go to state 86
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    expression                     shift and go to state 189
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 143

    (33) function_call -> names LPAREN RPAREN .

    TIMES           reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    DIVIDE          reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    PLUS            reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    MINUS           reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    SEMICOLON       reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    RPAREN          reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    COMMA           reduce using rule 33 (function_call -> names LPAREN RPAREN .)
    RSQBRACKET      reduce using rule 33 (function_call -> names LPAREN RPAREN .)


state 144

    (34) function_call -> names LPAREN arguments . RPAREN

    RPAREN          shift and go to state 190


state 145

    (83) assignment -> ID EQUALS expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 83 (assignment -> ID EQUALS expression .)
    RPAREN          reduce using rule 83 (assignment -> ID EQUALS expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 146

    (131) indexing_asign -> ID LSQBRACKET ID . RSQBRACKET
    (128) indexing -> ID LSQBRACKET ID . RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

  ! shift/reduce conflict for RSQBRACKET resolved as shift
    RSQBRACKET      shift and go to state 191
    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    LSQBRACKET      shift and go to state 135
    LPAREN          reduce using rule 23 (names -> ID .)

  ! RSQBRACKET      [ reduce using rule 97 (factor -> ID .) ]


state 147

    (130) indexing_asign -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET
    (127) indexing -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET
    (104) type -> INTEGER_TYPE .

  ! shift/reduce conflict for RSQBRACKET resolved as shift
    RSQBRACKET      shift and go to state 192
    TIMES           reduce using rule 104 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 104 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 104 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 104 (type -> INTEGER_TYPE .)

  ! RSQBRACKET      [ reduce using rule 104 (type -> INTEGER_TYPE .) ]


state 148

    (132) indexing_asign -> ID LSQBRACKET expression . RSQBRACKET
    (129) indexing -> ID LSQBRACKET expression . RSQBRACKET
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RSQBRACKET      shift and go to state 193
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 149

    (9) object_access -> ID DOT ID .

    LPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    TIMES           reduce using rule 9 (object_access -> ID DOT ID .)
    DIVIDE          reduce using rule 9 (object_access -> ID DOT ID .)
    PLUS            reduce using rule 9 (object_access -> ID DOT ID .)
    MINUS           reduce using rule 9 (object_access -> ID DOT ID .)
    SEMICOLON       reduce using rule 9 (object_access -> ID DOT ID .)
    RPAREN          reduce using rule 9 (object_access -> ID DOT ID .)
    COMMA           reduce using rule 9 (object_access -> ID DOT ID .)
    RSQBRACKET      reduce using rule 9 (object_access -> ID DOT ID .)
    OR              reduce using rule 9 (object_access -> ID DOT ID .)
    AND             reduce using rule 9 (object_access -> ID DOT ID .)
    NOT             reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_THAN    reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_THAN       reduce using rule 9 (object_access -> ID DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    LESS_EQUALS_THAN reduce using rule 9 (object_access -> ID DOT ID .)
    EQUALITY        reduce using rule 9 (object_access -> ID DOT ID .)
    DIFFERENT       reduce using rule 9 (object_access -> ID DOT ID .)


state 150

    (11) object_access -> ID DOT CLASSOBJECT .

    LPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    TIMES           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    PLUS            reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    MINUS           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    RPAREN          reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    COMMA           reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    RSQBRACKET      reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    OR              reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    AND             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    NOT             reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)
    DIFFERENT       reduce using rule 11 (object_access -> ID DOT CLASSOBJECT .)


state 151

    (84) assignment -> indexing_asign EQUALS expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 84 (assignment -> indexing_asign EQUALS expression .)
    RPAREN          reduce using rule 84 (assignment -> indexing_asign EQUALS expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 152

    (10) object_access -> CLASSOBJECT DOT CLASSOBJECT .

    LPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    TIMES           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    DIVIDE          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    PLUS            reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    MINUS           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    SEMICOLON       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    RPAREN          reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    COMMA           reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    RSQBRACKET      reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    OR              reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    AND             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    NOT             reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_THAN    reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_THAN       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    GREATER_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    LESS_EQUALS_THAN reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    EQUALITY        reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)
    DIFFERENT       reduce using rule 10 (object_access -> CLASSOBJECT DOT CLASSOBJECT .)


state 153

    (12) object_access -> CLASSOBJECT DOT ID .

    LPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    TIMES           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    DIVIDE          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    PLUS            reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    MINUS           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    SEMICOLON       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    RPAREN          reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    COMMA           reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    RSQBRACKET      reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    OR              reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    AND             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    NOT             reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_THAN    reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_THAN       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    GREATER_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    LESS_EQUALS_THAN reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    EQUALITY        reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)
    DIFFERENT       reduce using rule 12 (object_access -> CLASSOBJECT DOT ID .)


state 154

    (81) data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .

    ID              reduce using rule 81 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)
    CLASSOBJECT     reduce using rule 81 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)
    GREATER_THAN    reduce using rule 81 (data_structure_array -> CLASSOBJECT LSQBRACKET RSQBRACKET .)


state 155

    (41) expression -> object_access LPAREN expression . RPAREN
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RPAREN          shift and go to state 194
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 156

    (42) expression -> object_access LPAREN RPAREN .

    PLUS            reduce using rule 42 (expression -> object_access LPAREN RPAREN .)
    MINUS           reduce using rule 42 (expression -> object_access LPAREN RPAREN .)
    SEMICOLON       reduce using rule 42 (expression -> object_access LPAREN RPAREN .)
    RPAREN          reduce using rule 42 (expression -> object_access LPAREN RPAREN .)
    COMMA           reduce using rule 42 (expression -> object_access LPAREN RPAREN .)
    RSQBRACKET      reduce using rule 42 (expression -> object_access LPAREN RPAREN .)


state 157

    (90) term -> term TIMES factor .

    TIMES           reduce using rule 90 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 90 (term -> term TIMES factor .)
    PLUS            reduce using rule 90 (term -> term TIMES factor .)
    MINUS           reduce using rule 90 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 90 (term -> term TIMES factor .)
    RPAREN          reduce using rule 90 (term -> term TIMES factor .)
    COMMA           reduce using rule 90 (term -> term TIMES factor .)
    RSQBRACKET      reduce using rule 90 (term -> term TIMES factor .)


state 158

    (91) term -> term DIVIDE factor .

    TIMES           reduce using rule 91 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 91 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 91 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 91 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 91 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 91 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 91 (term -> term DIVIDE factor .)
    RSQBRACKET      reduce using rule 91 (term -> term DIVIDE factor .)


state 159

    (56) while_loop -> WHILE LPAREN logical_expression . RPAREN block
    (57) while_loop -> WHILE LPAREN logical_expression . RPAREN block body
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

    RPAREN          shift and go to state 195
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

    logical_operator               shift and go to state 171

state 160

    (54) loop_for -> FOR LPAREN assignment . SEMICOLON logical_expression SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 196


state 161

    (82) assignment -> data_type . ID EQUALS expression

    ID              shift and go to state 197


state 162

    (83) assignment -> ID . EQUALS expression
    (85) assignment -> ID . PLUSONE
    (130) indexing_asign -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> ID . LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> ID . LSQBRACKET expression RSQBRACKET

    EQUALS          shift and go to state 95
    PLUSONE         shift and go to state 96
    LSQBRACKET      shift and go to state 198


state 163
state 163

    (86) assignment -> CLASSOBJECT . ID
    (81) data_structure_array -> CLASSOBJECT . LSQBRACKET RSQBRACKET

    ID              shift and go to state 100
    LSQBRACKET      shift and go to state 102


state 164

    (80) data_structure_array -> primitive LSQBRACKET RSQBRACKET .

    ID              reduce using rule 80 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)
    CLASSOBJECT     reduce using rule 80 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)
    GREATER_THAN    reduce using rule 80 (data_structure_array -> primitive LSQBRACKET RSQBRACKET .)


state 165

    (95) factor -> LSQBRACKET arguments RSQBRACKET .

    TIMES           reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    DIVIDE          reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    PLUS            reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    MINUS           reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    SEMICOLON       reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    RPAREN          reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    COMMA           reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)
    RSQBRACKET      reduce using rule 95 (factor -> LSQBRACKET arguments RSQBRACKET .)


state 166

    (36) arguments -> expression COMMA . arguments
    (35) arguments -> . expression
    (36) arguments -> . expression COMMA arguments
    (37) arguments -> . names
    (38) arguments -> . names COMMA arguments
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (23) names -> . ID
    (24) names -> . CLASSOBJECT
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN

    ID              shift and go to state 116
    CLASSOBJECT     shift and go to state 117
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    expression                     shift and go to state 114
    arguments                      shift and go to state 199
    names                          shift and go to state 115
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 167

    (38) arguments -> names COMMA . arguments
    (35) arguments -> . expression
    (36) arguments -> . expression COMMA arguments
    (37) arguments -> . names
    (38) arguments -> . names COMMA arguments
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (23) names -> . ID
    (24) names -> . CLASSOBJECT
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN

    ID              shift and go to state 116
    CLASSOBJECT     shift and go to state 117
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

    names                          shift and go to state 115
    arguments                      shift and go to state 200
    expression                     shift and go to state 114
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 168

    (79) data_structure_list -> LIST LESS_THAN data_type . GREATER_THAN

    GREATER_THAN    shift and go to state 201


state 169

    (67) logical_factor -> LPAREN logical_expression . RPAREN
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

    RPAREN          shift and go to state 202
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

    logical_operator               shift and go to state 171

state 170

    (43) if -> IF LPAREN logical_expression RPAREN . block
    (44) if -> IF LPAREN logical_expression RPAREN . block body
    (45) if -> IF LPAREN logical_expression RPAREN . block elseif
    (46) if -> IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 203

state 171

    (59) logical_expression -> logical_expression logical_operator . logical_expression
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_expression             shift and go to state 204
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 172

    (68) logical_operator -> OR .

    TRUE            reduce using rule 68 (logical_operator -> OR .)
    FALSE           reduce using rule 68 (logical_operator -> OR .)
    ID              reduce using rule 68 (logical_operator -> OR .)
    LPAREN          reduce using rule 68 (logical_operator -> OR .)
    FLOAT_TYPE      reduce using rule 68 (logical_operator -> OR .)
    DOUBLE_TYPE     reduce using rule 68 (logical_operator -> OR .)
    DECIMAL_TYPE    reduce using rule 68 (logical_operator -> OR .)
    INTEGER_TYPE    reduce using rule 68 (logical_operator -> OR .)
    MINUS           reduce using rule 68 (logical_operator -> OR .)
    CLASSOBJECT     reduce using rule 68 (logical_operator -> OR .)


state 173

    (69) logical_operator -> AND .

    TRUE            reduce using rule 69 (logical_operator -> AND .)
    FALSE           reduce using rule 69 (logical_operator -> AND .)
    ID              reduce using rule 69 (logical_operator -> AND .)
    LPAREN          reduce using rule 69 (logical_operator -> AND .)
    FLOAT_TYPE      reduce using rule 69 (logical_operator -> AND .)
    DOUBLE_TYPE     reduce using rule 69 (logical_operator -> AND .)
    DECIMAL_TYPE    reduce using rule 69 (logical_operator -> AND .)
    INTEGER_TYPE    reduce using rule 69 (logical_operator -> AND .)
    MINUS           reduce using rule 69 (logical_operator -> AND .)
    CLASSOBJECT     reduce using rule 69 (logical_operator -> AND .)


state 174

    (70) logical_operator -> NOT .

    TRUE            reduce using rule 70 (logical_operator -> NOT .)
    FALSE           reduce using rule 70 (logical_operator -> NOT .)
    ID              reduce using rule 70 (logical_operator -> NOT .)
    LPAREN          reduce using rule 70 (logical_operator -> NOT .)
    FLOAT_TYPE      reduce using rule 70 (logical_operator -> NOT .)
    DOUBLE_TYPE     reduce using rule 70 (logical_operator -> NOT .)
    DECIMAL_TYPE    reduce using rule 70 (logical_operator -> NOT .)
    INTEGER_TYPE    reduce using rule 70 (logical_operator -> NOT .)
    MINUS           reduce using rule 70 (logical_operator -> NOT .)
    CLASSOBJECT     reduce using rule 70 (logical_operator -> NOT .)


state 175

    (71) logical_operator -> GREATER_THAN .

    TRUE            reduce using rule 71 (logical_operator -> GREATER_THAN .)
    FALSE           reduce using rule 71 (logical_operator -> GREATER_THAN .)
    ID              reduce using rule 71 (logical_operator -> GREATER_THAN .)
    LPAREN          reduce using rule 71 (logical_operator -> GREATER_THAN .)
    FLOAT_TYPE      reduce using rule 71 (logical_operator -> GREATER_THAN .)
    DOUBLE_TYPE     reduce using rule 71 (logical_operator -> GREATER_THAN .)
    DECIMAL_TYPE    reduce using rule 71 (logical_operator -> GREATER_THAN .)
    INTEGER_TYPE    reduce using rule 71 (logical_operator -> GREATER_THAN .)
    MINUS           reduce using rule 71 (logical_operator -> GREATER_THAN .)
    CLASSOBJECT     reduce using rule 71 (logical_operator -> GREATER_THAN .)


state 176

    (72) logical_operator -> LESS_THAN .

    TRUE            reduce using rule 72 (logical_operator -> LESS_THAN .)
    FALSE           reduce using rule 72 (logical_operator -> LESS_THAN .)
    ID              reduce using rule 72 (logical_operator -> LESS_THAN .)
    LPAREN          reduce using rule 72 (logical_operator -> LESS_THAN .)
    FLOAT_TYPE      reduce using rule 72 (logical_operator -> LESS_THAN .)
    DOUBLE_TYPE     reduce using rule 72 (logical_operator -> LESS_THAN .)
    DECIMAL_TYPE    reduce using rule 72 (logical_operator -> LESS_THAN .)
    INTEGER_TYPE    reduce using rule 72 (logical_operator -> LESS_THAN .)
    MINUS           reduce using rule 72 (logical_operator -> LESS_THAN .)
    CLASSOBJECT     reduce using rule 72 (logical_operator -> LESS_THAN .)


state 177
state 177

    (73) logical_operator -> GREATER_EQUALS_THAN .

    TRUE            reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    FALSE           reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    ID              reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    LPAREN          reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    MINUS           reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 73 (logical_operator -> GREATER_EQUALS_THAN .)


state 178

    (74) logical_operator -> LESS_EQUALS_THAN .

    TRUE            reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    FALSE           reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    ID              reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    LPAREN          reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    FLOAT_TYPE      reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    DOUBLE_TYPE     reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    DECIMAL_TYPE    reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    INTEGER_TYPE    reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    MINUS           reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)
    CLASSOBJECT     reduce using rule 74 (logical_operator -> LESS_EQUALS_THAN .)


state 179

    (75) logical_operator -> EQUALITY .

    TRUE            reduce using rule 75 (logical_operator -> EQUALITY .)
    FALSE           reduce using rule 75 (logical_operator -> EQUALITY .)
    ID              reduce using rule 75 (logical_operator -> EQUALITY .)
    LPAREN          reduce using rule 75 (logical_operator -> EQUALITY .)
    FLOAT_TYPE      reduce using rule 75 (logical_operator -> EQUALITY .)
    DOUBLE_TYPE     reduce using rule 75 (logical_operator -> EQUALITY .)
    DECIMAL_TYPE    reduce using rule 75 (logical_operator -> EQUALITY .)
    INTEGER_TYPE    reduce using rule 75 (logical_operator -> EQUALITY .)
    MINUS           reduce using rule 75 (logical_operator -> EQUALITY .)
    CLASSOBJECT     reduce using rule 75 (logical_operator -> EQUALITY .)


state 180

    (76) logical_operator -> DIFFERENT .

    TRUE            reduce using rule 76 (logical_operator -> DIFFERENT .)
    FALSE           reduce using rule 76 (logical_operator -> DIFFERENT .)
    ID              reduce using rule 76 (logical_operator -> DIFFERENT .)
    LPAREN          reduce using rule 76 (logical_operator -> DIFFERENT .)
    FLOAT_TYPE      reduce using rule 76 (logical_operator -> DIFFERENT .)
    DOUBLE_TYPE     reduce using rule 76 (logical_operator -> DIFFERENT .)
    DECIMAL_TYPE    reduce using rule 76 (logical_operator -> DIFFERENT .)
    INTEGER_TYPE    reduce using rule 76 (logical_operator -> DIFFERENT .)
    MINUS           reduce using rule 76 (logical_operator -> DIFFERENT .)
    CLASSOBJECT     reduce using rule 76 (logical_operator -> DIFFERENT .)


state 181

    (58) logical_expression -> logical_factor logical_operator . logical_expression
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_factor                 shift and go to state 126
    logical_expression             shift and go to state 205
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 182

    (128) indexing -> ID LSQBRACKET ID . RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

  ! shift/reduce conflict for RSQBRACKET resolved as shift
    RSQBRACKET      shift and go to state 206
    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    LSQBRACKET      shift and go to state 135
    LPAREN          reduce using rule 23 (names -> ID .)

  ! RSQBRACKET      [ reduce using rule 97 (factor -> ID .) ]


state 183

    (127) indexing -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET
    (104) type -> INTEGER_TYPE .

  ! shift/reduce conflict for RSQBRACKET resolved as shift
    RSQBRACKET      shift and go to state 207
    TIMES           reduce using rule 104 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 104 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 104 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 104 (type -> INTEGER_TYPE .)

  ! RSQBRACKET      [ reduce using rule 104 (type -> INTEGER_TYPE .) ]


state 184

    (129) indexing -> ID LSQBRACKET expression . RSQBRACKET
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RSQBRACKET      shift and go to state 208
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 185

    (25) function -> modifier data_type names LPAREN . declarations RPAREN block
    (106) declarations -> . declaration
    (107) declarations -> . declaration COMMA
    (108) declarations -> . declaration COMMA declarations
    (109) declaration -> . data_type ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    data_type                      shift and go to state 209
    declarations                   shift and go to state 210
    declaration                    shift and go to state 211
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 186

    (26) function -> modifier VOID names LPAREN . declarations RPAREN block
    (106) declarations -> . declaration
    (107) declarations -> . declaration COMMA
    (108) declarations -> . declaration COMMA declarations
    (109) declaration -> . data_type ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    declarations                   shift and go to state 212
    declaration                    shift and go to state 211
    data_type                      shift and go to state 209
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 187

    (27) function -> modifier STATIC data_type names . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 213


state 188

    (28) function -> modifier STATIC VOID names . LPAREN declarations RPAREN block

    LPAREN          shift and go to state 214


state 189

    (82) assignment -> data_type ID EQUALS expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 82 (assignment -> data_type ID EQUALS expression .)
    RPAREN          reduce using rule 82 (assignment -> data_type ID EQUALS expression .)
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 190

    (34) function_call -> names LPAREN arguments RPAREN .

    TIMES           reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    PLUS            reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    MINUS           reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    COMMA           reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)
    RSQBRACKET      reduce using rule 34 (function_call -> names LPAREN arguments RPAREN .)


state 191

    (131) indexing_asign -> ID LSQBRACKET ID RSQBRACKET .
    (128) indexing -> ID LSQBRACKET ID RSQBRACKET .

    EQUALS          reduce using rule 131 (indexing_asign -> ID LSQBRACKET ID RSQBRACKET .)
    TIMES           reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    DIVIDE          reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    PLUS            reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    MINUS           reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    SEMICOLON       reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)


state 192

    (130) indexing_asign -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .
    (127) indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .

    EQUALS          reduce using rule 130 (indexing_asign -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    TIMES           reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    DIVIDE          reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    PLUS            reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    MINUS           reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    SEMICOLON       reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)


state 193

    (132) indexing_asign -> ID LSQBRACKET expression RSQBRACKET .
    (129) indexing -> ID LSQBRACKET expression RSQBRACKET .

    EQUALS          reduce using rule 132 (indexing_asign -> ID LSQBRACKET expression RSQBRACKET .)
    TIMES           reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    DIVIDE          reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    PLUS            reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    MINUS           reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    SEMICOLON       reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    RPAREN          reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    COMMA           reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    RSQBRACKET      reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    OR              reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    AND             reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    NOT             reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    GREATER_THAN    reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    LESS_THAN       reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    EQUALITY        reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    DIFFERENT       reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)


state 191

    (41) expression -> object_access LPAREN expression RPAREN .

    PLUS            reduce using rule 41 (expression -> object_access LPAREN expression RPAREN .)
    MINUS           reduce using rule 41 (expression -> object_access LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 41 (expression -> object_access LPAREN expression RPAREN .)
    RPAREN          reduce using rule 41 (expression -> object_access LPAREN expression RPAREN .)
    COMMA           reduce using rule 41 (expression -> object_access LPAREN expression RPAREN .)
    RSQBRACKET      reduce using rule 41 (expression -> object_access LPAREN expression RPAREN .)


state 195

    (56) while_loop -> WHILE LPAREN logical_expression RPAREN . block
    (57) while_loop -> WHILE LPAREN logical_expression RPAREN . block body
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 215

state 196

    (54) loop_for -> FOR LPAREN assignment SEMICOLON . logical_expression SEMICOLON assignment RPAREN block
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_expression             shift and go to state 216
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 197

    (82) assignment -> data_type ID . EQUALS expression

    EQUALS          shift and go to state 142


state 198

    (130) indexing_asign -> ID LSQBRACKET . INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> ID LSQBRACKET . ID RSQBRACKET
    (132) indexing_asign -> ID LSQBRACKET . expression RSQBRACKET
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

    INTEGER_TYPE    shift and go to state 218
    ID              shift and go to state 217
    CLASSOBJECT     shift and go to state 87
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    MINUS           shift and go to state 48

    expression                     shift and go to state 219
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    factor                         shift and go to state 57
    type                           shift and go to state 50
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72
    names                          shift and go to state 42

state 199

    (36) arguments -> expression COMMA arguments .

    RSQBRACKET      reduce using rule 36 (arguments -> expression COMMA arguments .)
    RPAREN          reduce using rule 36 (arguments -> expression COMMA arguments .)


state 200

    (38) arguments -> names COMMA arguments .

    RSQBRACKET      reduce using rule 38 (arguments -> names COMMA arguments .)
    RPAREN          reduce using rule 38 (arguments -> names COMMA arguments .)


state 201

    (79) data_structure_list -> LIST LESS_THAN data_type GREATER_THAN .

    ID              reduce using rule 79 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN .)
    CLASSOBJECT     reduce using rule 79 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN .)
    GREATER_THAN    reduce using rule 79 (data_structure_list -> LIST LESS_THAN data_type GREATER_THAN .)


state 202

    (67) logical_factor -> LPAREN logical_expression RPAREN .

    OR              reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    AND             reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    NOT             reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_THAN    reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_THAN       reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    GREATER_EQUALS_THAN reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    LESS_EQUALS_THAN reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    EQUALITY        reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    DIFFERENT       reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    RPAREN          reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)
    SEMICOLON       reduce using rule 67 (logical_factor -> LPAREN logical_expression RPAREN .)


state 199

    (43) if -> IF LPAREN logical_expression RPAREN block .
    (44) if -> IF LPAREN logical_expression RPAREN block . body
    (45) if -> IF LPAREN logical_expression RPAREN block . elseif
    (46) if -> IF LPAREN logical_expression RPAREN block . else
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (47) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (48) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (49) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (50) else -> . ELSE block
    (51) else -> . ELSE block body
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CLASSOBJECT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for INTERNAL resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for BYTE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SBYTE resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for SHORT resolved as shift
  ! shift/reduce conflict for UINT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQBRACKET resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for DECIMAL_TYPE resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 223
    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

  ! IF              [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! ID              [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! CLASSOBJECT     [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! RETURN          [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! WHILE           [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! FOR             [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! PUBLIC          [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! PRIVATE         [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! PROTECTED       [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! INTERNAL        [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! INT             [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! FLOAT           [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! BOOL            [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! BYTE            [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! CHAR            [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! SBYTE           [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! DECIMAL         [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! DOUBLE          [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! LONG            [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! SHORT           [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! UINT            [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! LPAREN          [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! LSQBRACKET      [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! STRING          [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! LIST            [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! FLOAT_TYPE      [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! DOUBLE_TYPE     [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! DECIMAL_TYPE    [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! INTEGER_TYPE    [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]
  ! MINUS           [ reduce using rule 43 (if -> IF LPAREN logical_expression RPAREN block .) ]

    body                           shift and go to state 220
    elseif                         shift and go to state 221
    else                           shift and go to state 222
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 204

    (59) logical_expression -> logical_expression logical_operator logical_expression .
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS_THAN resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    RPAREN          reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .)
    SEMICOLON       reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .)
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

  ! OR              [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! AND             [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! NOT             [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! GREATER_THAN    [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! LESS_THAN       [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! GREATER_EQUALS_THAN [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! LESS_EQUALS_THAN [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! EQUALITY        [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]
  ! DIFFERENT       [ reduce using rule 59 (logical_expression -> logical_expression logical_operator logical_expression .) ]

    logical_operator               shift and go to state 171

state 205

    (58) logical_expression -> logical_factor logical_operator logical_expression .
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for GREATER_EQUALS_THAN resolved as shift
  ! shift/reduce conflict for LESS_EQUALS_THAN resolved as shift
  ! shift/reduce conflict for EQUALITY resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    RPAREN          reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .)
    SEMICOLON       reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .)
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

  ! OR              [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! AND             [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! NOT             [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! GREATER_THAN    [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! LESS_THAN       [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! GREATER_EQUALS_THAN [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! LESS_EQUALS_THAN [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! EQUALITY        [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]
  ! DIFFERENT       [ reduce using rule 58 (logical_expression -> logical_factor logical_operator logical_expression .) ]

    logical_operator               shift and go to state 171

state 206

    (128) indexing -> ID LSQBRACKET ID RSQBRACKET .

    TIMES           reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    DIVIDE          reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    RPAREN          reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    PLUS            reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    MINUS           reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    SEMICOLON       reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    COMMA           reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    RSQBRACKET      reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    OR              reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    AND             reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    NOT             reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_THAN    reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_THAN       reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    EQUALITY        reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)
    DIFFERENT       reduce using rule 128 (indexing -> ID LSQBRACKET ID RSQBRACKET .)


state 207

    (127) indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .

    TIMES           reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    DIVIDE          reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    RPAREN          reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    PLUS            reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    MINUS           reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    SEMICOLON       reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    COMMA           reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    RSQBRACKET      reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    OR              reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    AND             reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    NOT             reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_THAN    reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_THAN       reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    EQUALITY        reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)
    DIFFERENT       reduce using rule 127 (indexing -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)


state 208

    (129) indexing -> ID LSQBRACKET expression RSQBRACKET .

    TIMES           reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    DIVIDE          reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    RPAREN          reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    PLUS            reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    MINUS           reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    SEMICOLON       reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    COMMA           reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    RSQBRACKET      reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    OR              reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    AND             reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    NOT             reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    GREATER_THAN    reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    LESS_THAN       reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    GREATER_EQUALS_THAN reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    LESS_EQUALS_THAN reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    EQUALITY        reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)
    DIFFERENT       reduce using rule 129 (indexing -> ID LSQBRACKET expression RSQBRACKET .)


state 209

    (109) declaration -> data_type . ID

    ID              shift and go to state 224


state 210

    (25) function -> modifier data_type names LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 225


state 211

    (106) declarations -> declaration .
    (107) declarations -> declaration . COMMA
    (108) declarations -> declaration . COMMA declarations

    RPAREN          reduce using rule 106 (declarations -> declaration .)
    COMMA           shift and go to state 226


state 212

    (26) function -> modifier VOID names LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 227


state 213

    (27) function -> modifier STATIC data_type names LPAREN . declarations RPAREN block
    (106) declarations -> . declaration
    (107) declarations -> . declaration COMMA
    (108) declarations -> . declaration COMMA declarations
    (109) declaration -> . data_type ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    data_type                      shift and go to state 209
    declarations                   shift and go to state 228
    declaration                    shift and go to state 211
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 214

    (28) function -> modifier STATIC VOID names LPAREN . declarations RPAREN block
    (106) declarations -> . declaration
    (107) declarations -> . declaration COMMA
    (108) declarations -> . declaration COMMA declarations
    (109) declaration -> . data_type ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    declarations                   shift and go to state 229
    declaration                    shift and go to state 211
    data_type                      shift and go to state 209
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 215

    (56) while_loop -> WHILE LPAREN logical_expression RPAREN block .
    (57) while_loop -> WHILE LPAREN logical_expression RPAREN block . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CLASSOBJECT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for INTERNAL resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for BYTE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SBYTE resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for SHORT resolved as shift
  ! shift/reduce conflict for UINT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQBRACKET resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for DECIMAL_TYPE resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .)
    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

  ! IF              [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! ID              [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! CLASSOBJECT     [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! RETURN          [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! WHILE           [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! FOR             [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! PUBLIC          [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! PRIVATE         [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! PROTECTED       [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! INTERNAL        [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! INT             [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! FLOAT           [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! BOOL            [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! BYTE            [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! CHAR            [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! SBYTE           [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! DECIMAL         [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! DOUBLE          [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! LONG            [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! SHORT           [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! UINT            [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! LPAREN          [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! LSQBRACKET      [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! STRING          [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! LIST            [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! FLOAT_TYPE      [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! DOUBLE_TYPE     [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! DECIMAL_TYPE    [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! INTEGER_TYPE    [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]
  ! MINUS           [ reduce using rule 56 (while_loop -> WHILE LPAREN logical_expression RPAREN block .) ]

    body                           shift and go to state 230
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 216

    (54) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression . SEMICOLON assignment RPAREN block
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

    SEMICOLON       shift and go to state 231
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

    logical_operator               shift and go to state 171

state 217

    (131) indexing_asign -> ID LSQBRACKET ID . RSQBRACKET
    (9) object_access -> ID . DOT ID
    (11) object_access -> ID . DOT CLASSOBJECT
    (97) factor -> ID .
    (127) indexing -> ID . LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> ID . LSQBRACKET ID RSQBRACKET
    (129) indexing -> ID . LSQBRACKET expression RSQBRACKET
    (23) names -> ID .

  ! shift/reduce conflict for RSQBRACKET resolved as shift
    RSQBRACKET      shift and go to state 232
    DOT             shift and go to state 98
    TIMES           reduce using rule 97 (factor -> ID .)
    DIVIDE          reduce using rule 97 (factor -> ID .)
    PLUS            reduce using rule 97 (factor -> ID .)
    MINUS           reduce using rule 97 (factor -> ID .)
    LSQBRACKET      shift and go to state 135
    LPAREN          reduce using rule 23 (names -> ID .)

  ! RSQBRACKET      [ reduce using rule 97 (factor -> ID .) ]


state 218

    (130) indexing_asign -> ID LSQBRACKET INTEGER_TYPE . RSQBRACKET
    (104) type -> INTEGER_TYPE .

  ! shift/reduce conflict for RSQBRACKET resolved as shift
    RSQBRACKET      shift and go to state 233
    TIMES           reduce using rule 104 (type -> INTEGER_TYPE .)
    DIVIDE          reduce using rule 104 (type -> INTEGER_TYPE .)
    PLUS            reduce using rule 104 (type -> INTEGER_TYPE .)
    MINUS           reduce using rule 104 (type -> INTEGER_TYPE .)

  ! RSQBRACKET      [ reduce using rule 104 (type -> INTEGER_TYPE .) ]


state 219

    (132) indexing_asign -> ID LSQBRACKET expression . RSQBRACKET
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RSQBRACKET      shift and go to state 234
    PLUS            shift and go to state 82
    MINUS           shift and go to state 83


state 220

    (44) if -> IF LPAREN logical_expression RPAREN block body .

    RBRACKET        reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    IF              reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    ID              reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    CLASSOBJECT     reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    RETURN          reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    WHILE           reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    FOR             reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    PUBLIC          reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    PRIVATE         reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    PROTECTED       reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    INTERNAL        reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    INT             reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    FLOAT           reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    BOOL            reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    BYTE            reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    CHAR            reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    SBYTE           reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    DECIMAL         reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    DOUBLE          reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    LONG            reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    SHORT           reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    UINT            reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    LPAREN          reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    LSQBRACKET      reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    STRING          reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    LIST            reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    FLOAT_TYPE      reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    DOUBLE_TYPE     reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    DECIMAL_TYPE    reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    INTEGER_TYPE    reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)
    MINUS           reduce using rule 44 (if -> IF LPAREN logical_expression RPAREN block body .)


state 221

    (45) if -> IF LPAREN logical_expression RPAREN block elseif .

    RBRACKET        reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    IF              reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    ID              reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    CLASSOBJECT     reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    RETURN          reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    WHILE           reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    FOR             reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    PUBLIC          reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    PRIVATE         reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    PROTECTED       reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    INTERNAL        reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    INT             reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    FLOAT           reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    BOOL            reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    BYTE            reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    CHAR            reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    SBYTE           reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    DECIMAL         reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    DOUBLE          reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    LONG            reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    SHORT           reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    UINT            reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    LPAREN          reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    LSQBRACKET      reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    STRING          reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    LIST            reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    FLOAT_TYPE      reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    DOUBLE_TYPE     reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    DECIMAL_TYPE    reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    INTEGER_TYPE    reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)
    MINUS           reduce using rule 45 (if -> IF LPAREN logical_expression RPAREN block elseif .)


state 222

    (46) if -> IF LPAREN logical_expression RPAREN block else .

    RBRACKET        reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    IF              reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    ID              reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    CLASSOBJECT     reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    RETURN          reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    WHILE           reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    FOR             reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    PUBLIC          reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    PRIVATE         reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    PROTECTED       reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    INTERNAL        reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    INT             reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    FLOAT           reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    BOOL            reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    BYTE            reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    CHAR            reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    SBYTE           reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    DECIMAL         reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    DOUBLE          reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    LONG            reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    SHORT           reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    UINT            reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    LPAREN          reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    LSQBRACKET      reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    STRING          reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    LIST            reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    FLOAT_TYPE      reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    DOUBLE_TYPE     reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    DECIMAL_TYPE    reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    INTEGER_TYPE    reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)
    MINUS           reduce using rule 46 (if -> IF LPAREN logical_expression RPAREN block else .)


state 223

    (47) elseif -> ELSE . IF LPAREN logical_expression RPAREN block
    (48) elseif -> ELSE . IF LPAREN logical_expression RPAREN block elseif
    (49) elseif -> ELSE . IF LPAREN logical_expression RPAREN block else
    (50) else -> ELSE . block
    (51) else -> ELSE . block body
    (13) block -> . LBRACKET body RBRACKET

    IF              shift and go to state 235
    LBRACKET        shift and go to state 25

    block                          shift and go to state 236

state 224

    (109) declaration -> data_type ID .

    COMMA           reduce using rule 109 (declaration -> data_type ID .)
    RPAREN          reduce using rule 109 (declaration -> data_type ID .)


state 225

    (25) function -> modifier data_type names LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 237

state 226

    (107) declarations -> declaration COMMA .
    (108) declarations -> declaration COMMA . declarations
    (106) declarations -> . declaration
    (107) declarations -> . declaration COMMA
    (108) declarations -> . declaration COMMA declarations
    (109) declaration -> . data_type ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    RPAREN          reduce using rule 107 (declarations -> declaration COMMA .)
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74
    CLASSOBJECT     shift and go to state 92

    declaration                    shift and go to state 211
    declarations                   shift and go to state 238
    data_type                      shift and go to state 209
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 227

    (26) function -> modifier VOID names LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 239

state 228

    (27) function -> modifier STATIC data_type names LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 240


state 229

    (28) function -> modifier STATIC VOID names LPAREN declarations . RPAREN block

    RPAREN          shift and go to state 241


state 230

    (57) while_loop -> WHILE LPAREN logical_expression RPAREN block body .

    RBRACKET        reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    IF              reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    ID              reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    CLASSOBJECT     reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    RETURN          reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    WHILE           reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    FOR             reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    PUBLIC          reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    PRIVATE         reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    PROTECTED       reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    INTERNAL        reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    INT             reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    FLOAT           reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    BOOL            reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    BYTE            reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    CHAR            reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    SBYTE           reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    DECIMAL         reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    DOUBLE          reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    LONG            reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    SHORT           reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    UINT            reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    LPAREN          reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    LSQBRACKET      reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    STRING          reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    LIST            reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    FLOAT_TYPE      reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    DOUBLE_TYPE     reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    DECIMAL_TYPE    reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    INTEGER_TYPE    reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)
    MINUS           reduce using rule 57 (while_loop -> WHILE LPAREN logical_expression RPAREN block body .)


state 231

    (54) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON . assignment RPAREN block
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET

    ID              shift and go to state 162
    CLASSOBJECT     shift and go to state 163
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LIST            shift and go to state 74

    assignment                     shift and go to state 242
    data_type                      shift and go to state 161
    indexing_asign                 shift and go to state 44
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70

state 232

    (131) indexing_asign -> ID LSQBRACKET ID RSQBRACKET .

    EQUALS          reduce using rule 131 (indexing_asign -> ID LSQBRACKET ID RSQBRACKET .)


state 233

    (130) indexing_asign -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .

    EQUALS          reduce using rule 130 (indexing_asign -> ID LSQBRACKET INTEGER_TYPE RSQBRACKET .)


state 234

    (132) indexing_asign -> ID LSQBRACKET expression RSQBRACKET .

    EQUALS          reduce using rule 132 (indexing_asign -> ID LSQBRACKET expression RSQBRACKET .)


state 235

    (47) elseif -> ELSE IF . LPAREN logical_expression RPAREN block
    (48) elseif -> ELSE IF . LPAREN logical_expression RPAREN block elseif
    (49) elseif -> ELSE IF . LPAREN logical_expression RPAREN block else

    LPAREN          shift and go to state 243


state 236

    (50) else -> ELSE block .
    (51) else -> ELSE block . body
    (14) body -> . lines SEMICOLON
    (15) body -> . lines SEMICOLON body
    (16) body -> . if
    (17) body -> . loop
    (18) body -> . function
    (19) lines -> . assignment
    (20) lines -> . expression
    (21) lines -> . declaration
    (22) lines -> . return
    (43) if -> . IF LPAREN logical_expression RPAREN block
    (44) if -> . IF LPAREN logical_expression RPAREN block body
    (45) if -> . IF LPAREN logical_expression RPAREN block elseif
    (46) if -> . IF LPAREN logical_expression RPAREN block else
    (52) loop -> . while_loop
    (53) loop -> . loop_for
    (25) function -> . modifier data_type names LPAREN declarations RPAREN block
    (26) function -> . modifier VOID names LPAREN declarations RPAREN block
    (27) function -> . modifier STATIC data_type names LPAREN declarations RPAREN block
    (28) function -> . modifier STATIC VOID names LPAREN declarations RPAREN block
    (29) function -> . function body
    (82) assignment -> . data_type ID EQUALS expression
    (83) assignment -> . ID EQUALS expression
    (84) assignment -> . indexing_asign EQUALS expression
    (85) assignment -> . ID PLUSONE
    (86) assignment -> . CLASSOBJECT ID
    (41) expression -> . object_access LPAREN expression RPAREN
    (42) expression -> . object_access LPAREN RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (109) declaration -> . data_type ID
    (30) return -> . RETURN ID
    (31) return -> . RETURN type
    (32) return -> . RETURN expression
    (56) while_loop -> . WHILE LPAREN logical_expression RPAREN block
    (57) while_loop -> . WHILE LPAREN logical_expression RPAREN block body
    (54) loop_for -> . FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block
    (55) loop_for -> . loop_for body
    (110) modifier -> . PUBLIC
    (111) modifier -> . PRIVATE
    (112) modifier -> . PROTECTED
    (113) modifier -> . INTERNAL
    (114) data_type -> . primitive
    (115) data_type -> . data_structure
    (130) indexing_asign -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (131) indexing_asign -> . ID LSQBRACKET ID RSQBRACKET
    (132) indexing_asign -> . ID LSQBRACKET expression RSQBRACKET
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (116) primitive -> . INT
    (117) primitive -> . FLOAT
    (118) primitive -> . BOOL
    (119) primitive -> . BYTE
    (120) primitive -> . CHAR
    (121) primitive -> . SBYTE
    (122) primitive -> . DECIMAL
    (123) primitive -> . DOUBLE
    (124) primitive -> . LONG
    (125) primitive -> . SHORT
    (126) primitive -> . UINT
    (77) data_structure -> . data_structure_list
    (78) data_structure -> . data_structure_array
    (93) factor -> . type
    (94) factor -> . LPAREN expression RPAREN
    (95) factor -> . LSQBRACKET arguments RSQBRACKET
    (96) factor -> . object_access
    (97) factor -> . ID
    (98) factor -> . indexing
    (99) factor -> . function_call
    (100) factor -> . STRING
    (79) data_structure_list -> . LIST LESS_THAN data_type GREATER_THAN
    (80) data_structure_array -> . primitive LSQBRACKET RSQBRACKET
    (81) data_structure_array -> . CLASSOBJECT LSQBRACKET RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (33) function_call -> . names LPAREN RPAREN
    (34) function_call -> . names LPAREN arguments RPAREN
    (23) names -> . ID
    (24) names -> . CLASSOBJECT

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for CLASSOBJECT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for PROTECTED resolved as shift
  ! shift/reduce conflict for INTERNAL resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for BYTE resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for SBYTE resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for LONG resolved as shift
  ! shift/reduce conflict for SHORT resolved as shift
  ! shift/reduce conflict for UINT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQBRACKET resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for LIST resolved as shift
  ! shift/reduce conflict for FLOAT_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for DECIMAL_TYPE resolved as shift
  ! shift/reduce conflict for INTEGER_TYPE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RBRACKET        reduce using rule 50 (else -> ELSE block .)
    IF              shift and go to state 36
    ID              shift and go to state 43
    CLASSOBJECT     shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    PUBLIC          shift and go to state 10
    PRIVATE         shift and go to state 11
    PROTECTED       shift and go to state 12
    INTERNAL        shift and go to state 13
    INT             shift and go to state 58
    FLOAT           shift and go to state 59
    BOOL            shift and go to state 60
    BYTE            shift and go to state 61
    CHAR            shift and go to state 62
    SBYTE           shift and go to state 63
    DECIMAL         shift and go to state 64
    DOUBLE          shift and go to state 65
    LONG            shift and go to state 66
    SHORT           shift and go to state 67
    UINT            shift and go to state 68
    LPAREN          shift and go to state 37
    LSQBRACKET      shift and go to state 55
    STRING          shift and go to state 73
    LIST            shift and go to state 74
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48

  ! IF              [ reduce using rule 50 (else -> ELSE block .) ]
  ! ID              [ reduce using rule 50 (else -> ELSE block .) ]
  ! CLASSOBJECT     [ reduce using rule 50 (else -> ELSE block .) ]
  ! RETURN          [ reduce using rule 50 (else -> ELSE block .) ]
  ! WHILE           [ reduce using rule 50 (else -> ELSE block .) ]
  ! FOR             [ reduce using rule 50 (else -> ELSE block .) ]
  ! PUBLIC          [ reduce using rule 50 (else -> ELSE block .) ]
  ! PRIVATE         [ reduce using rule 50 (else -> ELSE block .) ]
  ! PROTECTED       [ reduce using rule 50 (else -> ELSE block .) ]
  ! INTERNAL        [ reduce using rule 50 (else -> ELSE block .) ]
  ! INT             [ reduce using rule 50 (else -> ELSE block .) ]
  ! FLOAT           [ reduce using rule 50 (else -> ELSE block .) ]
  ! BOOL            [ reduce using rule 50 (else -> ELSE block .) ]
  ! BYTE            [ reduce using rule 50 (else -> ELSE block .) ]
  ! CHAR            [ reduce using rule 50 (else -> ELSE block .) ]
  ! SBYTE           [ reduce using rule 50 (else -> ELSE block .) ]
  ! DECIMAL         [ reduce using rule 50 (else -> ELSE block .) ]
  ! DOUBLE          [ reduce using rule 50 (else -> ELSE block .) ]
  ! LONG            [ reduce using rule 50 (else -> ELSE block .) ]
  ! SHORT           [ reduce using rule 50 (else -> ELSE block .) ]
  ! UINT            [ reduce using rule 50 (else -> ELSE block .) ]
  ! LPAREN          [ reduce using rule 50 (else -> ELSE block .) ]
  ! LSQBRACKET      [ reduce using rule 50 (else -> ELSE block .) ]
  ! STRING          [ reduce using rule 50 (else -> ELSE block .) ]
  ! LIST            [ reduce using rule 50 (else -> ELSE block .) ]
  ! FLOAT_TYPE      [ reduce using rule 50 (else -> ELSE block .) ]
  ! DOUBLE_TYPE     [ reduce using rule 50 (else -> ELSE block .) ]
  ! DECIMAL_TYPE    [ reduce using rule 50 (else -> ELSE block .) ]
  ! INTEGER_TYPE    [ reduce using rule 50 (else -> ELSE block .) ]
  ! MINUS           [ reduce using rule 50 (else -> ELSE block .) ]

    body                           shift and go to state 244
    lines                          shift and go to state 28
    if                             shift and go to state 29
    loop                           shift and go to state 30
    function                       shift and go to state 31
    assignment                     shift and go to state 32
    expression                     shift and go to state 33
    declaration                    shift and go to state 34
    return                         shift and go to state 35
    while_loop                     shift and go to state 38
    loop_for                       shift and go to state 39
    modifier                       shift and go to state 40
    data_type                      shift and go to state 41
    names                          shift and go to state 42
    indexing_asign                 shift and go to state 44
    object_access                  shift and go to state 46
    term                           shift and go to state 47
    type                           shift and go to state 50
    primitive                      shift and go to state 53
    data_structure                 shift and go to state 54
    factor                         shift and go to state 57
    data_structure_list            shift and go to state 69
    data_structure_array           shift and go to state 70
    indexing                       shift and go to state 71
    function_call                  shift and go to state 72

state 237

    (25) function -> modifier data_type names LPAREN declarations RPAREN block .

    IF              reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    ID              reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    CLASSOBJECT     reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    RETURN          reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    WHILE           reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    FOR             reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    PUBLIC          reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    PRIVATE         reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    PROTECTED       reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    INTERNAL        reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    INT             reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    FLOAT           reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    BOOL            reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    BYTE            reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    CHAR            reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    SBYTE           reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    DECIMAL         reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    DOUBLE          reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    LONG            reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    SHORT           reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    UINT            reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    LPAREN          reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    LSQBRACKET      reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    STRING          reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    LIST            reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    FLOAT_TYPE      reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    DOUBLE_TYPE     reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    DECIMAL_TYPE    reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    INTEGER_TYPE    reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    MINUS           reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)
    RBRACKET        reduce using rule 25 (function -> modifier data_type names LPAREN declarations RPAREN block .)


state 238

    (108) declarations -> declaration COMMA declarations .

    RPAREN          reduce using rule 108 (declarations -> declaration COMMA declarations .)


state 239

    (26) function -> modifier VOID names LPAREN declarations RPAREN block .

    IF              reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    ID              reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    CLASSOBJECT     reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    RETURN          reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    WHILE           reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    FOR             reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    PUBLIC          reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    PRIVATE         reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    PROTECTED       reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    INTERNAL        reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    INT             reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    FLOAT           reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    BOOL            reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    BYTE            reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    CHAR            reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    SBYTE           reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    DECIMAL         reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    DOUBLE          reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    LONG            reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    SHORT           reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    UINT            reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    LPAREN          reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    LSQBRACKET      reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    STRING          reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    LIST            reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    FLOAT_TYPE      reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    DOUBLE_TYPE     reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    DECIMAL_TYPE    reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    INTEGER_TYPE    reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    MINUS           reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)
    RBRACKET        reduce using rule 26 (function -> modifier VOID names LPAREN declarations RPAREN block .)


state 240

    (27) function -> modifier STATIC data_type names LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 245

state 241

    (28) function -> modifier STATIC VOID names LPAREN declarations RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 246

state 242

    (54) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment . RPAREN block

    RPAREN          shift and go to state 247


state 243

    (47) elseif -> ELSE IF LPAREN . logical_expression RPAREN block
    (48) elseif -> ELSE IF LPAREN . logical_expression RPAREN block elseif
    (49) elseif -> ELSE IF LPAREN . logical_expression RPAREN block else
    (58) logical_expression -> . logical_factor logical_operator logical_expression
    (59) logical_expression -> . logical_expression logical_operator logical_expression
    (60) logical_expression -> . logical_factor
    (61) logical_factor -> . TRUE
    (62) logical_factor -> . FALSE
    (63) logical_factor -> . ID
    (64) logical_factor -> . indexing
    (65) logical_factor -> . type
    (66) logical_factor -> . object_access
    (67) logical_factor -> . LPAREN logical_expression RPAREN
    (127) indexing -> . ID LSQBRACKET INTEGER_TYPE RSQBRACKET
    (128) indexing -> . ID LSQBRACKET ID RSQBRACKET
    (129) indexing -> . ID LSQBRACKET expression RSQBRACKET
    (101) type -> . FLOAT_TYPE
    (102) type -> . DOUBLE_TYPE
    (103) type -> . DECIMAL_TYPE
    (104) type -> . INTEGER_TYPE
    (105) type -> . MINUS type
    (9) object_access -> . ID DOT ID
    (10) object_access -> . CLASSOBJECT DOT CLASSOBJECT
    (11) object_access -> . ID DOT CLASSOBJECT
    (12) object_access -> . CLASSOBJECT DOT ID

    TRUE            shift and go to state 127
    FALSE           shift and go to state 128
    ID              shift and go to state 129
    LPAREN          shift and go to state 124
    FLOAT_TYPE      shift and go to state 75
    DOUBLE_TYPE     shift and go to state 76
    DECIMAL_TYPE    shift and go to state 77
    INTEGER_TYPE    shift and go to state 56
    MINUS           shift and go to state 48
    CLASSOBJECT     shift and go to state 133

    logical_expression             shift and go to state 248
    logical_factor                 shift and go to state 126
    indexing                       shift and go to state 130
    type                           shift and go to state 131
    object_access                  shift and go to state 132

state 244

    (51) else -> ELSE block body .

    IF              reduce using rule 51 (else -> ELSE block body .)
    ID              reduce using rule 51 (else -> ELSE block body .)
    CLASSOBJECT     reduce using rule 51 (else -> ELSE block body .)
    RETURN          reduce using rule 51 (else -> ELSE block body .)
    WHILE           reduce using rule 51 (else -> ELSE block body .)
    FOR             reduce using rule 51 (else -> ELSE block body .)
    PUBLIC          reduce using rule 51 (else -> ELSE block body .)
    PRIVATE         reduce using rule 51 (else -> ELSE block body .)
    PROTECTED       reduce using rule 51 (else -> ELSE block body .)
    INTERNAL        reduce using rule 51 (else -> ELSE block body .)
    INT             reduce using rule 51 (else -> ELSE block body .)
    FLOAT           reduce using rule 51 (else -> ELSE block body .)
    BOOL            reduce using rule 51 (else -> ELSE block body .)
    BYTE            reduce using rule 51 (else -> ELSE block body .)
    CHAR            reduce using rule 51 (else -> ELSE block body .)
    SBYTE           reduce using rule 51 (else -> ELSE block body .)
    DECIMAL         reduce using rule 51 (else -> ELSE block body .)
    DOUBLE          reduce using rule 51 (else -> ELSE block body .)
    LONG            reduce using rule 51 (else -> ELSE block body .)
    SHORT           reduce using rule 51 (else -> ELSE block body .)
    UINT            reduce using rule 51 (else -> ELSE block body .)
    LPAREN          reduce using rule 51 (else -> ELSE block body .)
    LSQBRACKET      reduce using rule 51 (else -> ELSE block body .)
    STRING          reduce using rule 51 (else -> ELSE block body .)
    LIST            reduce using rule 51 (else -> ELSE block body .)
    FLOAT_TYPE      reduce using rule 51 (else -> ELSE block body .)
    DOUBLE_TYPE     reduce using rule 51 (else -> ELSE block body .)
    DECIMAL_TYPE    reduce using rule 51 (else -> ELSE block body .)
    INTEGER_TYPE    reduce using rule 51 (else -> ELSE block body .)
    MINUS           reduce using rule 51 (else -> ELSE block body .)
    RBRACKET        reduce using rule 51 (else -> ELSE block body .)


state 245

    (27) function -> modifier STATIC data_type names LPAREN declarations RPAREN block .

    IF              reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    ID              reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    CLASSOBJECT     reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    RETURN          reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    WHILE           reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    FOR             reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    PUBLIC          reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    PRIVATE         reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    PROTECTED       reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    INTERNAL        reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    INT             reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    FLOAT           reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    BOOL            reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    BYTE            reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    CHAR            reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    SBYTE           reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    DECIMAL         reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    DOUBLE          reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    LONG            reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    SHORT           reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    UINT            reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    LPAREN          reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    LSQBRACKET      reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    STRING          reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    LIST            reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    FLOAT_TYPE      reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    DOUBLE_TYPE     reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    DECIMAL_TYPE    reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    INTEGER_TYPE    reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    MINUS           reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)
    RBRACKET        reduce using rule 27 (function -> modifier STATIC data_type names LPAREN declarations RPAREN block .)


state 246

    (28) function -> modifier STATIC VOID names LPAREN declarations RPAREN block .

    IF              reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    ID              reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    CLASSOBJECT     reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    RETURN          reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    WHILE           reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    FOR             reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    PUBLIC          reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    PRIVATE         reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    PROTECTED       reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    INTERNAL        reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    INT             reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    FLOAT           reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    BOOL            reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    BYTE            reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    CHAR            reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    SBYTE           reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    DECIMAL         reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    DOUBLE          reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    LONG            reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    SHORT           reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    UINT            reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    LPAREN          reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    LSQBRACKET      reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    STRING          reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    LIST            reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    FLOAT_TYPE      reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    DOUBLE_TYPE     reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    DECIMAL_TYPE    reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    INTEGER_TYPE    reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    MINUS           reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)
    RBRACKET        reduce using rule 28 (function -> modifier STATIC VOID names LPAREN declarations RPAREN block .)


state 247

    (54) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN . block
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 249

state 248

    (47) elseif -> ELSE IF LPAREN logical_expression . RPAREN block
    (48) elseif -> ELSE IF LPAREN logical_expression . RPAREN block elseif
    (49) elseif -> ELSE IF LPAREN logical_expression . RPAREN block else
    (59) logical_expression -> logical_expression . logical_operator logical_expression
    (68) logical_operator -> . OR
    (69) logical_operator -> . AND
    (70) logical_operator -> . NOT
    (71) logical_operator -> . GREATER_THAN
    (72) logical_operator -> . LESS_THAN
    (73) logical_operator -> . GREATER_EQUALS_THAN
    (74) logical_operator -> . LESS_EQUALS_THAN
    (75) logical_operator -> . EQUALITY
    (76) logical_operator -> . DIFFERENT

    RPAREN          shift and go to state 250
    OR              shift and go to state 172
    AND             shift and go to state 173
    NOT             shift and go to state 174
    GREATER_THAN    shift and go to state 175
    LESS_THAN       shift and go to state 176
    GREATER_EQUALS_THAN shift and go to state 177
    LESS_EQUALS_THAN shift and go to state 178
    EQUALITY        shift and go to state 179
    DIFFERENT       shift and go to state 180

    logical_operator               shift and go to state 171

state 249

    (54) loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .

    IF              reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    ID              reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    CLASSOBJECT     reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    RETURN          reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    WHILE           reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    FOR             reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    PUBLIC          reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    PRIVATE         reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    PROTECTED       reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    INTERNAL        reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    INT             reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    FLOAT           reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    BOOL            reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    BYTE            reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    CHAR            reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    SBYTE           reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    DECIMAL         reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    DOUBLE          reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    LONG            reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    SHORT           reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    UINT            reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    LPAREN          reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    LSQBRACKET      reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    STRING          reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    LIST            reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    FLOAT_TYPE      reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    DOUBLE_TYPE     reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    DECIMAL_TYPE    reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    INTEGER_TYPE    reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    MINUS           reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)
    RBRACKET        reduce using rule 54 (loop_for -> FOR LPAREN assignment SEMICOLON logical_expression SEMICOLON assignment RPAREN block .)


state 250

    (47) elseif -> ELSE IF LPAREN logical_expression RPAREN . block
    (48) elseif -> ELSE IF LPAREN logical_expression RPAREN . block elseif
    (49) elseif -> ELSE IF LPAREN logical_expression RPAREN . block else
    (13) block -> . LBRACKET body RBRACKET

    LBRACKET        shift and go to state 25

    block                          shift and go to state 251

state 251

    (47) elseif -> ELSE IF LPAREN logical_expression RPAREN block .
    (48) elseif -> ELSE IF LPAREN logical_expression RPAREN block . elseif
    (49) elseif -> ELSE IF LPAREN logical_expression RPAREN block . else
    (47) elseif -> . ELSE IF LPAREN logical_expression RPAREN block
    (48) elseif -> . ELSE IF LPAREN logical_expression RPAREN block elseif
    (49) elseif -> . ELSE IF LPAREN logical_expression RPAREN block else
    (50) else -> . ELSE block
    (51) else -> . ELSE block body

    IF              reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    ID              reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    CLASSOBJECT     reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    RETURN          reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    WHILE           reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    FOR             reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    PUBLIC          reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    PRIVATE         reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    PROTECTED       reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    INTERNAL        reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    INT             reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    FLOAT           reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    BOOL            reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    BYTE            reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    CHAR            reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    SBYTE           reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    DECIMAL         reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    DOUBLE          reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    LONG            reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    SHORT           reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    UINT            reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    LPAREN          reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    LSQBRACKET      reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    STRING          reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    LIST            reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    FLOAT_TYPE      reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    DOUBLE_TYPE     reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    DECIMAL_TYPE    reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    INTEGER_TYPE    reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    MINUS           reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    RBRACKET        reduce using rule 47 (elseif -> ELSE IF LPAREN logical_expression RPAREN block .)
    ELSE            shift and go to state 223

    elseif                         shift and go to state 252
    else                           shift and go to state 253

state 252

    (48) elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .

    IF              reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    ID              reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    CLASSOBJECT     reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    RETURN          reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    WHILE           reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    FOR             reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    PUBLIC          reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    PRIVATE         reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    PROTECTED       reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    INTERNAL        reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    INT             reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    FLOAT           reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    BOOL            reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    BYTE            reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    CHAR            reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    SBYTE           reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    DECIMAL         reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    DOUBLE          reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    LONG            reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    SHORT           reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    UINT            reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    LPAREN          reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    LSQBRACKET      reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    STRING          reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    LIST            reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    FLOAT_TYPE      reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    DOUBLE_TYPE     reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    DECIMAL_TYPE    reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    INTEGER_TYPE    reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    MINUS           reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)
    RBRACKET        reduce using rule 48 (elseif -> ELSE IF LPAREN logical_expression RPAREN block elseif .)


state 253

    (49) elseif -> ELSE IF LPAREN logical_expression RPAREN block else .

    IF              reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    ID              reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    CLASSOBJECT     reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    RETURN          reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    WHILE           reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    FOR             reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    PUBLIC          reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    PRIVATE         reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    PROTECTED       reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    INTERNAL        reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    INT             reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    FLOAT           reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    BOOL            reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    BYTE            reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    CHAR            reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    SBYTE           reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    DECIMAL         reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    DOUBLE          reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    LONG            reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    SHORT           reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    UINT            reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    LPAREN          reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    LSQBRACKET      reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    STRING          reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    LIST            reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    FLOAT_TYPE      reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    DOUBLE_TYPE     reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    DECIMAL_TYPE    reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    INTEGER_TYPE    reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    MINUS           reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)
    RBRACKET        reduce using rule 49 (elseif -> ELSE IF LPAREN logical_expression RPAREN block else .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 31 resolved as shift
WARNING: shift/reduce conflict for ID in state 31 resolved as shift
WARNING: shift/reduce conflict for CLASSOBJECT in state 31 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 31 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 31 resolved as shift
WARNING: shift/reduce conflict for FOR in state 31 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 31 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 31 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 31 resolved as shift
WARNING: shift/reduce conflict for INTERNAL in state 31 resolved as shift
WARNING: shift/reduce conflict for INT in state 31 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 31 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 31 resolved as shift
WARNING: shift/reduce conflict for BYTE in state 31 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 31 resolved as shift
WARNING: shift/reduce conflict for SBYTE in state 31 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 31 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 31 resolved as shift
WARNING: shift/reduce conflict for LONG in state 31 resolved as shift
WARNING: shift/reduce conflict for SHORT in state 31 resolved as shift
WARNING: shift/reduce conflict for UINT in state 31 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 31 resolved as shift
WARNING: shift/reduce conflict for LSQBRACKET in state 31 resolved as shift
WARNING: shift/reduce conflict for STRING in state 31 resolved as shift
WARNING: shift/reduce conflict for LIST in state 31 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 31 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 31 resolved as shift
WARNING: shift/reduce conflict for DECIMAL_TYPE in state 31 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 31 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 31 resolved as shift
WARNING: shift/reduce conflict for IF in state 39 resolved as shift
WARNING: shift/reduce conflict for ID in state 39 resolved as shift
WARNING: shift/reduce conflict for CLASSOBJECT in state 39 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 39 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 39 resolved as shift
WARNING: shift/reduce conflict for FOR in state 39 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 39 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 39 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 39 resolved as shift
WARNING: shift/reduce conflict for INTERNAL in state 39 resolved as shift
WARNING: shift/reduce conflict for INT in state 39 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 39 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 39 resolved as shift
WARNING: shift/reduce conflict for BYTE in state 39 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 39 resolved as shift
WARNING: shift/reduce conflict for SBYTE in state 39 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 39 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 39 resolved as shift
WARNING: shift/reduce conflict for LONG in state 39 resolved as shift
WARNING: shift/reduce conflict for SHORT in state 39 resolved as shift
WARNING: shift/reduce conflict for UINT in state 39 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 39 resolved as shift
WARNING: shift/reduce conflict for LSQBRACKET in state 39 resolved as shift
WARNING: shift/reduce conflict for STRING in state 39 resolved as shift
WARNING: shift/reduce conflict for LIST in state 39 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 39 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 39 resolved as shift
WARNING: shift/reduce conflict for DECIMAL_TYPE in state 39 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 39 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 39 resolved as shift
WARNING: shift/reduce conflict for IF in state 80 resolved as shift
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for CLASSOBJECT in state 80 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 80 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 80 resolved as shift
WARNING: shift/reduce conflict for FOR in state 80 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 80 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 80 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 80 resolved as shift
WARNING: shift/reduce conflict for INTERNAL in state 80 resolved as shift
WARNING: shift/reduce conflict for INT in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 80 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 80 resolved as shift
WARNING: shift/reduce conflict for BYTE in state 80 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 80 resolved as shift
WARNING: shift/reduce conflict for SBYTE in state 80 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 80 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 80 resolved as shift
WARNING: shift/reduce conflict for LONG in state 80 resolved as shift
WARNING: shift/reduce conflict for SHORT in state 80 resolved as shift
WARNING: shift/reduce conflict for UINT in state 80 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 80 resolved as shift
WARNING: shift/reduce conflict for LSQBRACKET in state 80 resolved as shift
WARNING: shift/reduce conflict for STRING in state 80 resolved as shift
WARNING: shift/reduce conflict for LIST in state 80 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 80 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 80 resolved as shift
WARNING: shift/reduce conflict for DECIMAL_TYPE in state 80 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for NOT in state 126 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 126 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 126 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS_THAN in state 126 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS_THAN in state 126 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 126 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 126 resolved as shift
WARNING: shift/reduce conflict for RSQBRACKET in state 146 resolved as shift
WARNING: shift/reduce conflict for RSQBRACKET in state 147 resolved as shift
WARNING: shift/reduce conflict for RSQBRACKET in state 182 resolved as shift
WARNING: shift/reduce conflict for RSQBRACKET in state 183 resolved as shift
WARNING: shift/reduce conflict for IF in state 203 resolved as shift
WARNING: shift/reduce conflict for ID in state 203 resolved as shift
WARNING: shift/reduce conflict for CLASSOBJECT in state 203 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 203 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 203 resolved as shift
WARNING: shift/reduce conflict for FOR in state 203 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 203 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 203 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 203 resolved as shift
WARNING: shift/reduce conflict for INTERNAL in state 203 resolved as shift
WARNING: shift/reduce conflict for INT in state 203 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 203 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 203 resolved as shift
WARNING: shift/reduce conflict for BYTE in state 203 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 203 resolved as shift
WARNING: shift/reduce conflict for SBYTE in state 203 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 203 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 203 resolved as shift
WARNING: shift/reduce conflict for LONG in state 203 resolved as shift
WARNING: shift/reduce conflict for SHORT in state 203 resolved as shift
WARNING: shift/reduce conflict for UINT in state 203 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 203 resolved as shift
WARNING: shift/reduce conflict for LSQBRACKET in state 203 resolved as shift
WARNING: shift/reduce conflict for STRING in state 203 resolved as shift
WARNING: shift/reduce conflict for LIST in state 203 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 203 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 203 resolved as shift
WARNING: shift/reduce conflict for DECIMAL_TYPE in state 203 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 203 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 203 resolved as shift
WARNING: shift/reduce conflict for OR in state 204 resolved as shift
WARNING: shift/reduce conflict for AND in state 204 resolved as shift
WARNING: shift/reduce conflict for NOT in state 204 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 204 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 204 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS_THAN in state 204 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS_THAN in state 204 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 204 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 204 resolved as shift
WARNING: shift/reduce conflict for OR in state 205 resolved as shift
WARNING: shift/reduce conflict for AND in state 205 resolved as shift
WARNING: shift/reduce conflict for NOT in state 205 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 205 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 205 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUALS_THAN in state 205 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUALS_THAN in state 205 resolved as shift
WARNING: shift/reduce conflict for EQUALITY in state 205 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 205 resolved as shift
WARNING: shift/reduce conflict for IF in state 215 resolved as shift
WARNING: shift/reduce conflict for ID in state 215 resolved as shift
WARNING: shift/reduce conflict for CLASSOBJECT in state 215 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 215 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 215 resolved as shift
WARNING: shift/reduce conflict for FOR in state 215 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 215 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 215 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 215 resolved as shift
WARNING: shift/reduce conflict for INTERNAL in state 215 resolved as shift
WARNING: shift/reduce conflict for INT in state 215 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 215 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 215 resolved as shift
WARNING: shift/reduce conflict for BYTE in state 215 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 215 resolved as shift
WARNING: shift/reduce conflict for SBYTE in state 215 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 215 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 215 resolved as shift
WARNING: shift/reduce conflict for LONG in state 215 resolved as shift
WARNING: shift/reduce conflict for SHORT in state 215 resolved as shift
WARNING: shift/reduce conflict for UINT in state 215 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 215 resolved as shift
WARNING: shift/reduce conflict for LSQBRACKET in state 215 resolved as shift
WARNING: shift/reduce conflict for STRING in state 215 resolved as shift
WARNING: shift/reduce conflict for LIST in state 215 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 215 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 215 resolved as shift
WARNING: shift/reduce conflict for DECIMAL_TYPE in state 215 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 215 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 215 resolved as shift
WARNING: shift/reduce conflict for RSQBRACKET in state 217 resolved as shift
WARNING: shift/reduce conflict for RSQBRACKET in state 218 resolved as shift
WARNING: shift/reduce conflict for IF in state 236 resolved as shift
WARNING: shift/reduce conflict for ID in state 236 resolved as shift
WARNING: shift/reduce conflict for CLASSOBJECT in state 236 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 236 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 236 resolved as shift
WARNING: shift/reduce conflict for FOR in state 236 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 236 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 236 resolved as shift
WARNING: shift/reduce conflict for PROTECTED in state 236 resolved as shift
WARNING: shift/reduce conflict for INTERNAL in state 236 resolved as shift
WARNING: shift/reduce conflict for INT in state 236 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 236 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 236 resolved as shift
WARNING: shift/reduce conflict for BYTE in state 236 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 236 resolved as shift
WARNING: shift/reduce conflict for SBYTE in state 236 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 236 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 236 resolved as shift
WARNING: shift/reduce conflict for LONG in state 236 resolved as shift
WARNING: shift/reduce conflict for SHORT in state 236 resolved as shift
WARNING: shift/reduce conflict for UINT in state 236 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 236 resolved as shift
WARNING: shift/reduce conflict for LSQBRACKET in state 236 resolved as shift
WARNING: shift/reduce conflict for STRING in state 236 resolved as shift
WARNING: shift/reduce conflict for LIST in state 236 resolved as shift
WARNING: shift/reduce conflict for FLOAT_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for DECIMAL_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for INTEGER_TYPE in state 236 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 236 resolved as shift
WARNING: reduce/reduce conflict in state 107 resolved using rule (return -> RETURN ID)
WARNING: rejected rule (factor -> ID) in state 107
WARNING: reduce/reduce conflict in state 108 resolved using rule (return -> RETURN type)
WARNING: rejected rule (factor -> type) in state 108
WARNING: reduce/reduce conflict in state 116 resolved using rule (names -> ID)
WARNING: rejected rule (factor -> ID) in state 116
